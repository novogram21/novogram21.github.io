<!DOCTYPE html>
<html lang="ru">
<head>
    <link rel="manifest" href="manifest.json">
    <meta name="theme-color" content="#1f1f1f" media="(prefers-color-scheme: dark)">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <meta name="apple-mobile-web-app-capable" content="yes">

    <meta name="color-scheme" content="dark">
    <meta name="theme-color" content="#1f1f1f">
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover">
    <title>Novogram</title>
    <link rel="icon" type="image/png" sizes="192x192" href="icon-192.png">
    <style>
        * {
            box-sizing: border-box;
            /* Убираем синий фон при тапе на мобильных устройствах */
            -webkit-tap-highlight-color: transparent !important;
            /* Убираем синюю рамку фокуса вокруг кнопок и полей */
            outline: none !important;
        }

        html {
            /* Тот самый цвет, чтобы системная зона слилась с приложением */
            background-color: #121316 !important;
        }

        /* --- ЗАПРЕТ КОПИРОВАНИЯ И ВЫДЕЛЕНИЯ --- */
        body {
            -webkit-user-select: none; /* Safari */
            -moz-user-select: none; /* Firefox */
            -ms-user-select: none; /* IE10+/Edge */
            user-select: none; /* Standard */
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, sans-serif;
            background: #121212;
            color: #eee;
            margin: 0;
            display: flex;
            /* --- ПРАВИЛЬНАЯ ФИКСАЦИЯ ДЛЯ iOS PWA --- */
            position: relative;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            height: 100dvh;
            padding-bottom: env(safe-area-inset-bottom);
            box-sizing: border-box; /* чтобы padding не ломал height */
            width: 100%;
            /* УБРАТЬ: height: 100dvh; - в PWA он работает криво */
            /* Подстраховка для Safari */
            min-height: -webkit-fill-available;
            overflow: hidden;
            overscroll-behavior-y: none;
        }

            /* Фикс чёрной полосы под Home Indicator на iPhone в PWA */
            body::after {
                content: '';
                position: fixed;
                bottom: 0;
                left: 0;
                right: 0;
                height: env(safe-area-inset-bottom);
                background-color: #17181c; /* цвет как у input-bar снизу */
                z-index: 9999;
            }


            /* --- ЭФФЕКТ ДОЛГОГО НАЖАТИЯ (iOS СТИЛЬ) --- */

            /* Плавно размываем и затемняем всё вокруг */
            body.chat-blur-active .chat-header,
            body.chat-blur-active .input-bar,
            body.chat-blur-active .floating-date,
            body.chat-blur-active .chat-date-separator {
                filter: blur(4px) brightness(0.7);
                pointer-events: none;
                transition: all 0.3s ease;
            }

            /* Размываем все сообщения, КРОМЕ выделенного */
            body.chat-blur-active .msg:not(.msg-highlighted) {
                filter: blur(4px) brightness(0.7);
                pointer-events: none;
            }

        /* Само сообщение */
        .msg {
            transition: transform 0.2s ease, filter 0.3s ease, brightness 0.3s ease;
            -webkit-touch-callout: none; /* Отключаем системное меню копирования iOS */
            -webkit-user-select: none;
            user-select: none;
        }

        /* Эффект "выдавливания" выбранного сообщения */
        .msg-highlighted {
            transform: scale(1.03) !important;
            box-shadow: 0 10px 35px rgba(0,0,0,0.6);
            z-index: 1000; /* Поднимаем над остальными */
        }

        /* Разрешаем выделять текст только в инпутах и текстареях */
        input, textarea {
            -webkit-user-select: text !important;
            -moz-user-select: text !important;
            -ms-user-select: text !important;
            user-select: text !important;
        }






        /* =========================================
                  ОПТИМИЗАЦИЯ ДЛЯ МОБИЛЬНОГО ПРИЛОЖЕНИЯ
                  ========================================= */
        .is-app .chat-date-separator,
        .is-app .floating-date {
            /* Отключаем тяжелое размытие в WebView, оно вызывает тормоза на Android */
            backdrop-filter: none !important;
            -webkit-backdrop-filter: none !important;
            /* Делаем фон чуть более плотным, чтобы компенсировать отсутствие блюра */
            background: rgba(40, 40, 40, 0.95) !important;
        }

        .is-app .messages {
            /* Включаем аппаратное ускорение скролла */
            -webkit-overflow-scrolling: touch;
            will-change: scroll-position;
        }


        /* Авторизация */
        .auth-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: #121212;
            z-index: 6000;
            display: flex;
            justify-content: center;
            align-items: center;
        }

        .auth-box {
            width: 300px;
            padding: 25px;
            background: #2d2d2d;
            border-radius: 12px;
            text-align: center;
            border: 1px solid #444;
        }

            .auth-box input {
                width: 100%;
                padding: 12px;
                margin: 8px 0;
                background: #444;
                border: 1px solid #555;
                color: white;
                border-radius: 6px;
            }

            .auth-box button {
                width: 100%;
                padding: 12px;
                background: #007bff;
                color: white;
                border: none;
                border-radius: 6px;
                cursor: pointer;
                font-weight: bold;
                margin-top: 10px;
            }




        .sidebar {
            width: 340px;
            background: #17181c;
            border-right: 1px solid rgba(255, 255, 255, 0.04);
            display: flex;
            flex-direction: column;
            z-index: 10;
            height: 100%; /* Фон сайдбара физически уйдет в самый низ */
        }


        .profile-bar {
            padding: calc(env(safe-area-inset-top) + 16px) 15px 10px 15px !important;
            background: transparent !important;
            display: flex;
            align-items: center;
            gap: 12px;
        }


        /* Кнопка в сайдбаре */
        #profileBtn {
            width: 46px;
            height: 46px;
            border-radius: 50%;
            background: #1c1c1e !important;
            border: 1px solid rgba(255,255,255,0.05) !important;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            flex-shrink: 0;
            overflow: hidden;
            padding: 0;
            box-shadow: 0 4px 12px rgba(0,0,0,0.3); /* Объемная тень */
            transition: transform 0.2s ease, box-shadow 0.2s ease;
        }

            #profileBtn:hover {
                transform: scale(1.05);
                box-shadow: 0 6px 16px rgba(0,0,0,0.5);
            }

            #profileBtn:active {
                transform: scale(0.92);
            }


        /* Контейнер внутри кнопки */
        #myAvatarSmall {
            width: 100%;
            height: 100%;
            display: flex;
            align-items: center;
            justify-content: center;
        }


            /* Сама картинка */
            #myAvatarSmall img {
                width: 100%;
                height: 100%;
                object-fit: cover; /* Чтобы фото не сплющивалось, а заполняло круг */
                display: block;
            }


        #searchInput {
            width: 100%;
            height: 46px !important;
            padding: 0 20px !important;
            border-radius: 23px !important;
            border: 1px solid rgba(255,255,255,0.04) !important;
            background: #15171b !important;
            color: white !important;
            font-size: 14px !important;
            outline: none;
            transition: all 0.3s cubic-bezier(0.25, 0.8, 0.25, 1) !important;
            box-shadow: inset 0 2px 5px rgba(0,0,0,0.1);
        }

            #searchInput:focus {
                background: #1c1f26 !important;
                border-color: rgba(115, 106, 240, 0.4) !important;
                box-shadow: 0 0 0 3px rgba(115, 106, 240, 0.15), inset 0 2px 5px rgba(0,0,0,0.1) !important;
            }

        .tabs {
            display: flex;
            justify-content: flex-start; /* НОВОЕ: Выравниваем аккуратно по левому краю */
            background: transparent !important;
            padding: 5px 15px 12px 15px;
            gap: 10px;
        }

        .tab {
            /* НОВОЕ: Убрали flex: 1, чтобы они не растягивались на всю ширину */
            padding: 8px 20px; /* Отступы по бокам от текста */
            text-align: center;
            border-radius: 20px; /* Делаем их круглыми "таблетками" */
            background: #15171b;
            color: #8e8e93;
            font-size: 13px;
            font-weight: 600;
            position: relative;
            cursor: pointer;
            transition: all 0.3s cubic-bezier(0.25, 0.8, 0.25, 1);
            border: 1px solid rgba(255,255,255,0.02);
            white-space: nowrap; /* Чтобы текст всегда был в одну строку */
        }

            .tab.active {
                background: rgba(115, 106, 240, 0.12);
                color: #736AF0 !important;
                border-color: rgba(115, 106, 240, 0.2);
                box-shadow: 0 4px 10px rgba(115, 106, 240, 0.1);
            }



        .tab-badge {
            top: -4px !important;
            right: -2px !important;
            box-shadow: 0 2px 6px rgba(255, 68, 68, 0.4);
            border: 2px solid #0a0c10; /* Эффект прорези */
        }

            .tab-badge.hidden {
                display: block !important;
                opacity: 0 !important;
                transform: scale(0) !important;
            }

        .list-container {
            flex: 1;
            overflow-y: auto;
            /* Внутренний отступ, чтобы список чатов не залезал за home indicator */
            padding: 0 10px calc(10px + env(safe-area-inset-bottom)) 10px;
        }

            .list-container::-webkit-scrollbar {
                width: 4px;
            }

            .list-container::-webkit-scrollbar-thumb {
                background: rgba(255,255,255,0.1);
                border-radius: 10px;
            }

        /* 3. Папки (Табы как в мобильном Telegram) */
        .tabs-container {
            width: 100%;
            border-bottom: 1px solid rgba(255, 255, 255, 0.04);
            background: transparent;
        }

            .tabs-container.hidden {
                display: none !important;
            }

        .tabs-scroll {
            display: flex;
            gap: 0; /* Убираем пробелы, используем внутренние отступы табов */
            padding: 0 10px;
            overflow-x: auto;
            scroll-behavior: smooth;
            -webkit-overflow-scrolling: touch;
            scrollbar-width: none;
            cursor: grab; /* Курсор в виде "руки" для перетаскивания на ПК */
        }

            .tabs-scroll.is-dragging {
                cursor: grabbing;
                scroll-behavior: auto; /* Отключаем плавность при ручном перетаскивании */
            }

            .tabs-scroll::-webkit-scrollbar {
                display: none;
            }


        /* ==========================================
                          АНИМАЦИИ ДЛЯ ПАПОК (TELEGRAM STYLE)
                          ========================================== */

        /* 1. Эффект "всплеска" (Ripple) при нажатии на вкладку */
        .tab {
            position: relative;
            overflow: hidden; /* Чтобы круг не вылезал за границы */
        }

            .tab::before {
                content: "";
                position: absolute;
                top: 50%;
                left: 50%;
                width: 100%;
                height: 100%;
                background: rgba(115, 106, 240, 0.2);
                border-radius: 50px;
                transform: translate(-50%, -50%) scale(0);
                opacity: 0;
                transition: transform 0.4s ease, opacity 0.4s ease;
                z-index: -1;
            }

            .tab:active::before {
                transform: translate(-50%, -50%) scale(2);
                opacity: 1;
                transition: 0s; /* Моментально появляется при касании */
            }

        /* 2. Анимации выезда списков (справа налево и слева направо) */
        @keyframes slideInRight {
            from {
                opacity: 0;
                transform: translateX(25px);
            }

            to {
                opacity: 1;
                transform: translateX(0);
            }
        }

        @keyframes slideInLeft {
            from {
                opacity: 0;
                transform: translateX(-25px);
            }

            to {
                opacity: 1;
                transform: translateX(0);
            }
        }

        /* Классы, которые мы будем вешать через JS */
        .slide-right {
            animation: slideInRight 0.25s cubic-bezier(0.25, 0.8, 0.25, 1) forwards;
        }

        .slide-left {
            animation: slideInLeft 0.25s cubic-bezier(0.25, 0.8, 0.25, 1) forwards;
        }

        /* Сама вкладка: невысокая, но длинная */
        .tab {
            padding: 0 20px;
            height: 46px;
            display: flex;
            align-items: center;
            justify-content: center;
            color: #8e8e93;
            font-size: 15px;
            font-weight: 500;
            cursor: pointer;
            white-space: nowrap;
            background: transparent !important;
            border: none !important;
            border-radius: 0 !important;
            box-shadow: none !important;
            border-bottom: 3px solid transparent !important;
            transition: color 0.3s ease, border-bottom-color 0.3s ease;
            user-select: none;
            /* --- ЖЕСТКОЕ УДАЛЕНИЕ СИСТЕМНЫХ ОБВОДОК НА ТЕЛЕФОНЕ --- */
            -webkit-tap-highlight-color: rgba(0,0,0,0) !important;
            -webkit-tap-highlight-color: transparent !important;
            outline: none !important;
        }

            .tab:focus, .tab:active {
                outline: none !important;
                background: transparent !important;
            }

            .tab::before {
                display: none !important;
            }

            .tab:hover {
                color: #b0b0b5;
            }

            .tab.active {
                color: #736AF0 !important;
                border-bottom: 3px solid #736AF0 !important;
            }

        /* Счетчик рядом со словом */
        .tab-badge {
            position: relative !important;
            top: 0 !important;
            margin-left: 8px;
            padding: 2px 7px;
            border-radius: 10px;
            font-size: 11.5px;
            font-weight: bold;
            background: rgba(115, 106, 240, 0.15) !important;
            color: #736AF0 !important;
            border: none !important;
            box-shadow: none !important;
        }

        .tab.active .tab-badge {
            background: #736AF0 !important;
            color: white !important;
        }



        /* Эффект нажатия для новой кнопки "Заявки" */
        #requestsBtnTop:hover {
            transform: scale(1.05);
        }

        #requestsBtnTop:active {
            transform: scale(0.92);
        }

        /* Элемент списка чатов (НОВЫЙ ДИЗАЙН) */

        /* Элемент списка чатов */
        .user-item {
            padding: 10px 12px;
            border-bottom: none !important; /* Убираем уродливые полосы */
            display: grid;
            grid-template-columns: 52px 1fr auto;
            grid-template-rows: auto auto;
            column-gap: 12px;
            align-items: center;
            cursor: pointer;
            min-height: 72px;
            border-radius: 16px; /* Современное сильное скругление */
            margin-bottom: 2px; /* Воздух между диалогами */
            background: transparent;
            transition: transform 0.2s cubic-bezier(0.25, 0.8, 0.25, 1), background 0.2s;
        }

            .user-item:hover {
                background: rgba(255, 255, 255, 0.04); /* Мягкое осветление при наведении */
                transform: scale(0.99); /* Легкое вдавливание как в iOS */
            }

            .user-item:active {
                background: rgba(255, 255, 255, 0.07);
                transform: scale(0.97);
            }

        .user-item-avatar {
            grid-column: 1;
            grid-row: 1 / span 2;
            width: 52px;
            height: 52px;
            border-radius: 50%;
            object-fit: cover;
            box-shadow: 0 3px 10px rgba(0,0,0,0.3); /* Тень для объема аватарок */
            border: 1px solid rgba(255,255,255,0.05);
        }

        .user-name {
            grid-column: 2;
            grid-row: 1;
            font-weight: 600;
            font-size: 15.5px;
            color: #ffffff;
            margin-bottom: 3px;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
            align-self: end;
            letter-spacing: -0.2px; /* Делает шрифт более собранным и дорогим */
        }

        .last-msg-row {
            grid-column: 2;
            grid-row: 2;
            display: flex;
            align-items: center;
            overflow: hidden;
            align-self: start;
        }

        .last-msg {
            font-size: 13.5px;
            color: #8e8e93; /* Классический серый текст из Apple-дизайна */
            font-weight: 400;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
            max-width: 100%;
        }


        .meta-column {
            grid-column: 3;
            grid-row: 1 / span 2;
            display: flex;
            flex-direction: column;
            align-items: flex-end;
            justify-content: center;
            gap: 6px;
            min-width: 55px;
        }

        .last-msg-date {
            font-size: 12px;
            color: #8e8e93;
            font-weight: 500;
        }




        /* Контейнер для нижней части правой колонки (Галочки ИЛИ Счетчик) */
        .meta-bottom-row {
            display: flex;
            align-items: center;
            justify-content: flex-end;
            height: 20px; /* Фиксированная высота */
        }




        /* Галочки - теперь белые и в правом углу */
        .list-ticks {
            display: inline-flex;
            font-size: 14px; /* Чуть крупнее */
            color: white !important; /* Принудительно белые */
        }

            .list-ticks span {
                color: white !important;
            }

        .badge-count {
            background: #736AF0;
            color: white;
            font-size: 12px;
            padding: 2px 9px;
            border-radius: 12px;
            font-weight: bold;
            min-width: 20px;
            text-align: center;
            line-height: 1.2;
            /* Настройки плавной анимации */
            display: block !important;
            opacity: 1;
            transform: scale(1);
            transform-origin: center;
            transition: opacity 0.2s ease, transform 0.3s cubic-bezier(0.175, 0.885, 0.32, 1.275), max-width 0.2s ease, min-width 0.2s ease, padding 0.2s ease, margin 0.2s ease;
            max-width: 40px;
            overflow: hidden;
            white-space: nowrap;
        }

            /* Состояние, когда скрипт прячет счетчик (прочитано) */
            .badge-count.hidden {
                display: block !important; /* Блокируем резкое скрытие */
                opacity: 0 !important;
                transform: scale(0) !important; /* Схлопываем в точку */
                max-width: 0 !important;
                min-width: 0 !important;
                padding-left: 0 !important;
                padding-right: 0 !important;
                margin-left: 0 !important; /* Убираем отступ */
                border: none !important;
            }

        .chat-area {
            flex: 1;
            display: flex;
            flex-direction: column;
            background: transparent;
            position: relative;
            z-index: 1;
        }




        /* Фон с паттерном для пустого экрана "Выберите чат" */
        #noChat {
            height: 100%;
            display: flex;
            align-items: center;
            justify-content: center;
            color: #555;
            position: relative;
            overflow: hidden;
        }

        #noChat {
            height: 100%;
            display: flex;
            align-items: center;
            justify-content: center;
            color: #aaa;
            position: relative;
            overflow: hidden;
            background-color: #0a0c10;
        }

            #noChat > div {
                position: relative;
                z-index: 2;
                font-size: 18px;
                font-weight: 500;
            }

        @keyframes scrollPattern {
            0% {
                transform: translate(0, 0);
            }

            100% {
                transform: translate(-10%, -10%);
            }
        }

        .chat-header {
            /* Добавляем env(safe-area-inset-top) чтобы шапка опускалась ниже системных часов */
            padding: calc(8px + env(safe-area-inset-top)) 15px 8px 15px;
            background: #17181c;
            border-bottom: 1px solid #101010;
            display: flex;
            justify-content: space-between;
            align-items: center;
            min-height: calc(56px + env(safe-area-inset-top)); /* Увеличиваем высоту на размер челки */
        }

        .chat-header-left {
            display: flex;
            align-items: center;
            gap: 12px;
            flex: 1;
            overflow: hidden;
            cursor: pointer;
        }

        .chat-header-avatar {
            width: 40px;
            height: 40px;
            border-radius: 50%;
            background: #333;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 18px;
            flex-shrink: 0;
            overflow: hidden;
        }



        .back-btn {
            display: none;
            background: none;
            border: none;
            cursor: pointer;
            padding: 5px;
            margin-left: -5px;
            border-radius: 50%;
            transition: background 0.2s;
        }

            .back-btn:active {
                background: rgba(255,255,255,0.1);
            }

        .chat-header-info {
            display: flex;
            flex-direction: column;
            justify-content: center;
            gap: 2px;
            overflow: hidden;
        }

        .chat-title {
            font-weight: 600;
            font-size: 15px;
            color: #fff;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
        }



        .chat-status {
            font-size: 13px;
            color: #aaa;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
        }

        .chat-header-actions {
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .header-icon-btn {
            background: none;
            border: none;
            padding: 8px;
            border-radius: 50%;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: background 0.2s;
        }

            .header-icon-btn:hover {
                background: rgba(255, 255, 255, 0.08);
            }

            .header-icon-btn:active {
                background: rgba(255, 255, 255, 0.15);
            }

        /* --- СВАЙП ВЛЕВО ДЛЯ ОТВЕТА (TELEGRAM STYLE) --- */
        .messages {
            overflow-x: hidden !important; /* Важно, чтобы при свайпе не появлялся ползунок */
        }

        .msg-deleting {
            opacity: 0 !important;
            transform: scale(0.8) !important;
            /* Переопределяем анимацию, чтобы схлопывалась высота и отступы */
            transition: all 0.3s cubic-bezier(0.25, 0.8, 0.25, 1) !important;
        }

        .msg {
            transition: transform 0.25s cubic-bezier(0.25, 0.8, 0.25, 1);
        }



            .msg.swiping {
                transition: none !important; /* Отключаем плавность, пока палец двигает сообщение */
            }

        .swipe-reply-icon {
            position: absolute;
            right: -45px; /* Прячем за правым краем сообщения */
            top: 50%;
            margin-top: -15px; /* Центрируем */
            width: 30px;
            height: 30px;
            background: rgba(255, 255, 255, 0.15);
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 14px;
            transform: scale(0.5);
            opacity: 0;
            transition: transform 0.2s cubic-bezier(0.175, 0.885, 0.32, 1.275), opacity 0.2s, background 0.2s;
            z-index: -1;
        }

            .swipe-reply-icon.active {
                transform: scale(1);
                opacity: 1;
                background: #736AF0; /* Окрашиваем в фирменный цвет при активации */
            }

        .messages {
            flex: 1;
            padding: 20px;
            overflow-y: auto;
            display: flex;
            flex-direction: column;
            gap: 8px;
            width: 100%;
            max-width: 900px;
            margin: 0 auto;
            background: transparent;
            position: relative;
            z-index: 1;
            /* ВАЖНО: Это гарантирует, что список не будет больше выделенного ему места */
            min-height: 0;
            height: 0; /* Флекс сам растянет его до нужного размера */
            transition: opacity 0.15s ease-out;
        }

            .messages.visible {
                opacity: 1;
            }

            .messages::before {
                content: "";
                margin-top: auto;
            }




            /* Важно! Сообщения должны быть ВЫШЕ фона */
            .messages > * {
                position: relative;
                z-index: 1;
            }



        /* --- НОВАЯ ПАНЕЛЬ ВВОДА (TELEGRAM STYLE) --- */
        .input-bar {
            width: 100%;
            max-width: 900px;
            margin: 0 auto;
            background: #17181c; /* Цвет панели */
            min-height: 56px;
            padding: 8px;
            display: flex;
            align-items: flex-end; /* Выравнивание по низу */
            gap: 8px;
            position: relative;
            z-index: 5;
            padding: 8px 8px calc(8px + env(safe-area-inset-bottom)) 8px;
        }

        /* Скругленный плавающий бар ТОЛЬКО для веб-версии (ПК) */
        @media (min-width: 769px) {
            .input-bar {
                border-radius: 16px;
                margin: 0 auto 20px auto; /* Центрируем и делаем отступ снизу */
                width: calc(100% - 40px); /* Отступы по бокам */
            }
        }

        /* Серый блок ввода */
        .input-wrapper {
            flex: 1; /* Занимает все доступное место */
            background: #21232b; /* Дорогой темный оттенок в тон фону */
            border-radius: 20px; /* Скругление */
            display: flex;
            align-items: center;
            min-height: 42px;
            padding: 0 12px;
            transition: border-color 0.2s, background 0.2s;
            border: 1px solid transparent;
        }

            .input-wrapper:focus-within {
                border-color: transparent;
                background: #262933; /* Чуть светлеет при вводе текста */
            }

            /* Поле ввода текста */
            .input-wrapper textarea {
                flex: 1;
                background: transparent;
                border: none;
                color: white;
                font-size: 16px;
                padding: 10px 0;
                line-height: 20px;
                height: 40px; /* Строго 1 строка (20px текст + 20px отступы) */
                min-height: 40px;
                max-height: 100px;
                outline: none;
                resize: none;
                font-family: inherit;
                overflow-y: hidden; /* ВАЖНО: Убивает фантомный скроллбар, делающий 2 строки */
                scrollbar-width: none;
                box-sizing: border-box;
                display: block;
                -webkit-user-select: text !important;
                user-select: text !important;
            }

                .input-wrapper textarea::-webkit-scrollbar {
                    display: none;
                }

        /* Кнопки иконки (Скрепка и Смайл) */
        .tg-icon-btn-input {
            position: relative; /* <--- ВАЖНОЕ ДОБАВЛЕНИЕ */
            width: 36px;
            height: 36px;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            background: transparent;
            border: none;
            color: #8e8e93;
            padding: 0;
            flex-shrink: 0;
            border-radius: 50%;
            transition: transform 0.15s cubic-bezier(0.2, 0.85, 0.3, 1), background-color 0.15s ease, color 0.15s ease;
            -webkit-tap-highlight-color: transparent !important;
            outline: none !important;
            overflow: hidden; /* <--- ВАЖНОЕ ДОБАВЛЕНИЕ: чтобы инпут не вылезал за края кнопки */
        }

            .tg-icon-btn-input:hover {
                color: #ffffff;
            }

            .tg-icon-btn-input:active {
                transform: scale(0.85); /* Мягко проваливается */
                background-color: rgba(255, 255, 255, 0.08); /* Появляется легкий круглый фон */
                color: #ffffff; /* Иконка загорается белым */
            }

            .tg-icon-btn-input svg {
                width: 24px;
                height: 24px;
                fill: currentColor;
                transition: fill 0.15s ease;
            }

        /* Круглая кнопка справа (Микрофон / Самолетик) */
        .main-action-btn {
            width: 48px;
            height: 48px;
            border-radius: 50%;
            border: none;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            flex-shrink: 0;
            -webkit-tap-highlight-color: transparent !important;
            outline: none !important;
            /* Плавная анимация изменения размера, цвета и тени */
            transition: transform 0.15s cubic-bezier(0.2, 0.85, 0.3, 1), background-color 0.15s ease, box-shadow 0.15s ease;
        }

        /* Стиль для микрофона (серый фон) */
        .btn-mic {
            background: #21232b;
            color: #8e8e93;
            box-shadow: 0 2px 8px rgba(0,0,0,0.2); /* Легкая тень */
        }

            .btn-mic:active {
                transform: scale(0.88);
                background: #262933;
                color: #ffffff;
                box-shadow: 0 1px 4px rgba(0,0,0,0.3);
            }

        .btn-send {
            background: #736AF0; /* Фирменный фиолетовый */
            color: white;
            box-shadow: 0 4px 15px rgba(115, 106, 240, 0.4); /* Дорогое цветное свечение */
        }

            .btn-send:active {
                transform: scale(0.88);
                background: #5e55cd; /* Чуть темнеет при нажатии */
                box-shadow: 0 2px 8px rgba(115, 106, 240, 0.5);
            }

        .hidden {
            display: none !important;
        }








        .voice-btn {
            background: #21232b;
            color: #8e8e93;
        }

            .voice-btn:hover {
                background: #262933;
                color: #ffffff;
            }

        .send-btn {
            background: #007bff; /* Синий для отправки */
            color: white;
            padding-left: 5px; /* Визуально центрируем стрелочку */
        }

            .send-btn:hover {
                background: #0056b3;
            }






        /* Общие стили для сообщения */
        .msg {
            max-width: 75%;
            padding: 8px 12px;
            border-radius: 12px;
            font-size: 15px;
            line-height: 1.4;
            position: relative;
            cursor: pointer;
            word-wrap: break-word; /* Чтобы длинные слова переносились */
        }




        /* Свои сообщения (справа) - фиолетовые */
        .msg-me {
            align-self: flex-end;
            background: #736AF0; /* Красивый фиолетовый цвет как на скриншоте */
            color: white;
            border-bottom-right-radius: 2px;
        }




        /* Чужие сообщения (слева) - серые */
        .msg-other {
            align-self: flex-start;
            background: #21232b; /* Премиальный оттенок, как у поля ввода */
            color: white;
            border-bottom-left-radius: 2px;
        }




        /* Системные сообщения (даты и служебные) */
        .msg-sys {
            align-self: center;
            background: rgba(0, 0, 0, 0.35); /* Чистый прозрачный цвет вместо серого */
            font-size: 12px;
            color: #ccc;
            padding: 4px 12px;
            border-radius: 12px;
            margin: 8px 0;
            backdrop-filter: blur(5px);
        }

        /* --- СТИЛИ ДЛЯ ЗВОНКОВ В ЧАТЕ (TELEGRAM STYLE) --- */
        .chat-call-card {
            display: flex;
            align-items: center;
            gap: 12px;
            padding: 4px 10px 4px 4px;
            min-width: 170px;
        }

        .call-icon-wrapper {
            width: 40px;
            height: 40px;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            flex-shrink: 0;
            background: rgba(255, 255, 255, 0.1);
        }

        .msg-me .call-icon-wrapper {
            background: rgba(255, 255, 255, 0.2);
        }

        .call-info {
            display: flex;
            flex-direction: column;
            gap: 2px;
        }

        .call-title {
            font-weight: 600;
            font-size: 15px;
            color: white;
            line-height: 1.1;
        }

        .call-time {
            font-size: 13px;
            display: flex;
            align-items: center;
            line-height: 1;
        }



        /* Блок мета-информации (время + галочки) */

        /* Мета-информация (время + галочки) */

        /* Мета-информация (время + галочки) */
        .msg-meta {
            float: right;
            margin-left: 7px;
            margin-top: 6px;
            display: inline-flex;
            align-items: center;
            gap: 3px;
            vertical-align: bottom;
            position: relative;
            top: 3px;
            white-space: nowrap; /* Важно: запрещает перенос на новую строку внутри мета-блока */
            height: 14px;
            line-height: 1;
        }

        .msg-time {
            font-size: 11px;
            color: rgba(255, 255, 255, 0.6);
            margin-right: 2px;
        }

        .msg-ticks {
            font-size: 12px;
            color: white; /* Всегда белые */
            display: none;
            font-weight: bold;
        }

        .msg-me .msg-ticks {
            display: inline-block;
        }




        /* Прочитанные галочки (теперь они тоже белые, цвет не меняется) */
        .tick-read {
            color: white;
        }




        /* Шторки */
        .overlay-sheet {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0,0,0,0.5);
            z-index: 4999;
            display: none;
        }

        .search-section-title {
            padding: 15px 12px 8px 0px;
            font-size: 13px;
            font-weight: 600;
            color: #736AF0; /* Твой фирменный фиолетовый */
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }

        .action-sheet {
            /* Оставляем старые стили */
            position: fixed;
            bottom: 0;
            left: 0;
            width: 100%;
            background: #1f1f1f;
            border-top-left-radius: 16px;
            border-top-right-radius: 16px;
            padding: 20px;
            z-index: 5000;
            transform: translateY(100%);
            /* ДОБАВЛЯЕМ ЭТО: скрываем от таба/фокуса, когда закрыто */
            visibility: hidden;
            transition: transform 0.3s, visibility 0s linear 0.3s;
        }

            .action-sheet.open {
                transform: translateY(0);
                /* ДОБАВЛЯЕМ ЭТО: показываем сразу при открытии */
                visibility: visible;
                transition: transform 0.3s, visibility 0s;
            }

        .action-btn {
            background: #2d2d2d;
            border: none;
            padding: 15px;
            color: white;
            border-radius: 12px;
            font-size: 16px;
            cursor: pointer;
            text-align: center;
        }

            .action-btn:active {
                background: #333;
            }

            .action-btn.delete {
                color: #ff4444;
            }

        .sheet-title {
            color: #777;
            font-size: 13px;
            text-align: center;
            margin-bottom: 5px;
        }




        /* Профиль Шторка */
        .profile-option {
            background: #2d2d2d;
            padding: 15px;
            border-radius: 10px;
            margin-bottom: 10px;
        }

            .profile-option h3 {
                margin: 0 0 10px 0;
                font-size: 15px;
                color: #ddd;
            }

        .profile-input-group {
            display: flex;
            gap: 10px;
        }

        /* ==========================================
        ПРЕМИУМ ДИЗАЙН ЗВОНКОВ
        ========================================== */
        .call-screen {
            background: linear-gradient(135deg, #121316 0%, #1c1c1e 100%);
        }

        .premium-call-header {
            position: absolute;
            top: calc(env(safe-area-inset-top) + 40px);
            left: 0;
            right: 0;
            display: flex;
            flex-direction: column;
            align-items: center;
            z-index: 4005;
            pointer-events: none; /* Чтобы не мешало кликать по видео */
            text-shadow: 0 2px 15px rgba(0,0,0,0.8);
        }

        .call-name-display {
            font-size: 26px;
            font-weight: 600;
            color: #ffffff;
            letter-spacing: -0.5px;
            margin-bottom: 6px;
        }

        .call-status-row {
            display: flex;
            gap: 8px;
            align-items: center;
            background: rgba(0, 0, 0, 0.3);
            backdrop-filter: blur(10px);
            -webkit-backdrop-filter: blur(10px);
            padding: 6px 14px;
            border-radius: 20px;
        }

        #callStatusText {
            font-size: 15px;
            color: rgba(255, 255, 255, 0.85);
            font-weight: 500;
        }

        #callTimer {
            font-size: 15px;
            color: #fff;
            font-weight: bold;
            font-variant-numeric: tabular-nums;
        }

        .call-ping-display {
            margin-top: 10px;
            font-size: 12px;
            color: #10b981;
            opacity: 0.8;
        }

        /* Островок кнопок */
        .premium-call-controls {
            position: absolute;
            bottom: calc(env(safe-area-inset-bottom) + 30px);
            left: 50%;
            transform: translateX(-50%);
            display: flex;
            gap: 15px;
            background: rgba(28, 28, 30, 0.65);
            backdrop-filter: blur(25px);
            -webkit-backdrop-filter: blur(25px);
            padding: 12px 20px;
            border-radius: 40px;
            border: 1px solid rgba(255, 255, 255, 0.1);
            box-shadow: 0 10px 40px rgba(0,0,0,0.5);
            z-index: 4005;
        }

        /* Сами кнопки */
        .premium-btn {
            width: 52px;
            height: 52px;
            border-radius: 50%;
            border: none;
            background: rgba(255, 255, 255, 0.15);
            color: white;
            display: flex;
            justify-content: center;
            align-items: center;
            cursor: pointer;
            transition: all 0.2s cubic-bezier(0.25, 0.8, 0.25, 1);
            -webkit-tap-highlight-color: transparent;
        }

            .premium-btn svg {
                width: 24px;
                height: 24px;
                stroke-width: 2px;
            }

            .premium-btn:hover {
                background: rgba(255, 255, 255, 0.25);
            }

            .premium-btn:active {
                transform: scale(0.9);
            }

            /* Активное состояние (когда выключен микрофон или камера) */
            .premium-btn.muted-state {
                background: #ffffff;
                color: #1c1c1e;
            }

            /* Кнопка сброса вызова */
            .premium-btn.btn-hangup {
                background: #ff4444;
                box-shadow: 0 4px 15px rgba(255, 68, 68, 0.4);
                margin-left: 5px;
            }

                .premium-btn.btn-hangup:hover {
                    background: #ff595a;
                }

                .premium-btn.btn-hangup svg {
                    transform: rotate(135deg); /* Поворачиваем трубку вниз */
                    stroke-width: 2.5px;
                }

        /* Красивое мини-видео (PiP) */
        .local-video-container {
            border: 1px solid rgba(255,255,255,0.15) !important;
            box-shadow: 0 15px 35px rgba(0,0,0,0.6) !important;
            border-radius: 20px !important;
            overflow: hidden;
            bottom: calc(env(safe-area-inset-bottom) + 110px) !important; /* Поднимаем над островком */
        }


        /* Звонки */
        .call-screen {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: #000;
            z-index: 4000;
            display: none;
            flex-direction: column;
            transition: opacity 0.5s;
        }

        .video-grid {
            flex: 1;
            display: flex;
            justify-content: center;
            align-items: center;
            position: relative;
            width: 100%;
            height: 100%;
            background: #000;
        }

        #remoteVideo {
            width: 100%;
            height: 100%;
            object-fit: contain;
            background: #000;
        }

        .local-video-container {
            position: absolute;
            bottom: 160px;
            right: 20px;
            /* УВЕЛИЧЕННЫЕ РАЗМЕРЫ */
            width: 140px; /* Было 100px */
            height: 210px; /* Было 150px (пропорция 2:3 сохранена) */
            /* КРАСИВОЕ СКРУГЛЕНИЕ */
            border-radius: 18px; /* Сильнее скруглено (было 10px) */
            overflow: hidden;
            /* УТОНЧЕННАЯ РАМКА */
            border: 2px solid rgba(255, 255, 255, 0.2); /* Полупрозрачная белая рамка выглядит стильнее */
            /* ТЕНЬ ДЛЯ ОБЪЕМА */
            box-shadow: 0 8px 25px rgba(0,0,0,0.6);
            z-index: 4002;
            display: block;
            transition: all 0.3s cubic-bezier(0.25, 0.8, 0.25, 1); /* Плавная анимация */
        }

        #localVideo {
            width: 100% !important;
            height: 100% !important;
            object-fit: cover !important; /* <--- Убирает черные полосы, обрезая лишнее */
            position: absolute; /* <--- Фиксирует видео в углу контейнера */
            top: 0;
            left: 0;
            background: #000;
        }

            #localVideo.mirror {
                transform: scaleX(-1);
            }

        .controls {
            position: absolute;
            bottom: 0;
            left: 0;
            width: 100%;
            display: flex;
            justify-content: center;
            gap: 15px;
            padding: 20px 10px 40px 10px;
            z-index: 4003;
            background: #18191c;
            border-top-left-radius: 16px;
            border-top-right-radius: 16px;
        }

        .control-item {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 8px;
            width: 70px;
        }

        .control-label {
            font-size: 11px;
            color: #b5bac1;
            white-space: nowrap;
        }

        .btn-circle {
            width: 56px;
            height: 56px;
            border-radius: 50%;
            border: none;
            cursor: pointer;
            display: flex;
            justify-content: center;
            align-items: center;
            font-size: 24px;
            transition: 0.2s;
            background: #2b2d31;
            color: #dbdee1;
        }

            .btn-circle:active {
                transform: scale(0.95);
            }

        .btn-active-white {
            background: #f2f3f5 !important;
            color: #313338 !important;
        }

        .btn-hangup {
            background: #da373c !important;
            color: white !important;
        }

        .btn-screen-on {
            background: #248046 !important;
            color: white !important;
        }

        .incoming-call {
            position: fixed;
            top: 20px;
            left: 50%;
            transform: translateX(-50%);
            background: #222;
            padding: 15px 25px;
            border-radius: 30px;
            z-index: 5000;
            display: none;
            align-items: center;
            gap: 20px;
            box-shadow: 0 10px 30px rgba(0,0,0,0.8);
            border: 1px solid #444;
            width: 90%;
            max-width: 400px;
            justify-content: space-between;
        }

        .timer-badge {
            position: absolute;
            top: 40px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(0,0,0,0.6);
            padding: 10px 20px;
            border-radius: 20px;
            color: #fff;
            z-index: 4003;
            pointer-events: none;
            display: flex;
            flex-direction: column;
            align-items: center;
            min-width: 120px;
        }

        #callStatusText {
            font-size: 12px;
            color: #ccc;
            margin-bottom: 5px;
            text-transform: uppercase;
            letter-spacing: 1px;
        }

        #callTimer {
            font-size: 18px;
            font-family: monospace;
            font-weight: bold;
        }

        #callPing {
            font-size: 11px;
            color: #4caf50;
            margin-top: 5px;
            opacity: 0.9;
        }

        .hidden {
            display: none !important;
        }

        @media (max-width: 768px) {
            .sidebar {
                width: 100%;
                border-right: none;
                transition: transform 0.35s ease;
            }

                /* Сайдбар плавно отъезжает влево при открытии чата */
                .sidebar.hidden-mobile {
                    transform: translateX(-30%);
                    pointer-events: none;
                }

            .chat-area {
                display: flex !important;
                width: 100%;
                position: fixed;
                top: 0;
                left: 0;
                height: 100%;
                z-index: 100;
                /* Смягчили фон для мобильной версии */
                background-color: #121316 !important;
                transform: translateX(100%);
                visibility: hidden;
                transition: transform 0.35s cubic-bezier(0.25, 1, 0.5, 1), visibility 0.35s;
            }

                /* Копируем ваши красивые эмодзи-обои прямо на непрозрачный фон чата */
                .chat-area::before {
                    content: "";
                    position: absolute;
                    top: 0;
                    left: 0;
                    width: 100%;
                    height: 100%;
                    opacity: 0.7;
                    pointer-events: none;
                    z-index: -1;
                    background-image: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' width='500' height='500' viewBox='0 0 500 500'%3E%3Cstyle%3E text %7B font-family: 'Segoe UI Emoji', 'Apple Color Emoji', sans-serif; %7D %3C/style%3E%3C!-- ИКОНКИ --%3E%3Ctext x='40' y='60' font-size='36' fill='%234a9eff' fill-opacity='0.4' transform='rotate(12 40 60)'%3E🎮%3C/text%3E%3Ctext x='380' y='120' font-size='40' fill='%237c3aed' fill-opacity='0.35' transform='rotate(-15 380 120)'%3E🚀%3C/text%3E%3Ctext x='220' y='400' font-size='38' fill='%2306b6d4' fill-opacity='0.4' transform='rotate(8 220 400)'%3E🎧%3C/text%3E%3Ctext x='180' y='90' font-size='28' fill='%23ec4899' fill-opacity='0.35' transform='rotate(-10 180 90)'%3E💡%3C/text%3E%3Ctext x='90' y='250' font-size='30' fill='%2310b981' fill-opacity='0.3' transform='rotate(20 90 250)'%3E🍕%3C/text%3E%3Ctext x='340' y='320' font-size='26' fill='%23f59e0b' fill-opacity='0.35' transform='rotate(-8 340 320)'%3E⚽%3C/text%3E%3Ctext x='420' y='450' font-size='32' fill='%236366f1' fill-opacity='0.4' transform='rotate(15 420 450)'%3E📷%3C/text%3E%3Ctext x='300' y='180' font-size='20' fill='%238b5cf6' fill-opacity='0.25' transform='rotate(-20 300 180)'%3E🎸%3C/text%3E%3Ctext x='150' y='350' font-size='22' fill='%2314b8a6' fill-opacity='0.3' transform='rotate(25 150 350)'%3E💻%3C/text%3E%3Ctext x='450' y='260' font-size='18' fill='%23ef4444' fill-opacity='0.3' transform='rotate(-12 450 260)'%3E🏆%3C/text%3E%3Ctext x='60' y='430' font-size='24' fill='%233b82f6' fill-opacity='0.35' transform='rotate(18 60 430)'%3E🎲%3C/text%3E%3Ctext x='280' y='50' font-size='20' fill='%23a855f7' fill-opacity='0.3' transform='rotate(-5 280 50)'%3E👻%3C/text%3E%3C/svg%3E");
                    background-size: 400px 400px;
                }

                /* Легкое затемнение, чтобы текст читался лучше */
                .chat-area::after {
                    content: "";
                    position: absolute;
                    top: 0;
                    left: 0;
                    width: 100%;
                    height: 100%;
                    background: radial-gradient(circle at 50% 50%, rgba(18, 19, 22, 0.4) 0%, rgba(18, 19, 22, 0.85) 100%);
                    pointer-events: none;
                    z-index: -1;
                }

                .chat-area.active {
                    transform: translateX(0);
                    visibility: visible;
                }

            .back-btn {
                display: block;
            }
        }

        /* Анимация плавного появления чата на ПК */
        @keyframes chatContentSlide {
            from {
                opacity: 0;
                transform: translateX(20px);
            }

            to {
                opacity: 1;
                transform: translateX(0);
            }
        }

        .chat-slide-animate {
            animation: chatContentSlide 0.3s cubic-bezier(0.25, 1, 0.5, 1) forwards;
        }

        /* --- Добавьте это ВНЕ медиа-запроса (для красивой анимации на ПК) --- */
        @keyframes chatContentSlide {
            from {
                opacity: 0;
                transform: translateX(20px);
            }

            to {
                opacity: 1;
                transform: translateX(0);
            }
        }

        .chat-slide-animate {
            animation: chatContentSlide 0.3s cubic-bezier(0.25, 1, 0.5, 1) forwards;
        }




        /* Полноэкранный контейнер результатов поиска (стиль Telegram) */
        #searchResults {
            flex: 1;
            overflow-y: auto;
            background: #17181c; /* Цвет как у сайдбара */
            display: none;
            flex-direction: column;
            z-index: 5;
            padding: 10px;
        }

            #searchResults.active {
                display: flex !important;
            }











        /* Стилизация каждого найденного человека */
        .search-item {
            display: flex;
            align-items: center;
            padding: 10px 12px;
            gap: 12px;
            cursor: pointer;
            border-radius: 16px;
            transition: background 0.2s, transform 0.1s;
            margin-bottom: 2px;
        }

            .search-item:hover {
                background: rgba(255, 255, 255, 0.04);
            }

            .search-item:active {
                transform: scale(0.97);
                background: rgba(255, 255, 255, 0.07);
            }

            .search-item img, .search-avatar-placeholder {
                width: 40px;
                height: 40px;
                border-radius: 50%;
                object-fit: cover;
            }

        .search-info {
            flex: 1;
            overflow: hidden;
        }

        .search-name {
            font-weight: bold;
            color: white;
            font-size: 15px;
        }

        .search-sub {
            font-size: 13px;
            color: #888;
        }

        .search-action {
            color: #007bff;
            font-size: 20px;
            padding-right: 5px;
        }




        /* 1. Общий фон для всего приложения */
        #app-background {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: -1;
            background-color: #121316; /* Мягкий базовый цвет */
        }

            #app-background::before {
                content: "";
                position: absolute;
                top: 0;
                left: 0;
                width: 100%;
                height: 100%;
                opacity: 0.5; /* Немного приглушили обои-эмодзи */
                pointer-events: none;
                background-image: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' width='500' height='500' viewBox='0 0 500 500'%3E%3Cstyle%3E text %7B font-family: 'Segoe UI Emoji', 'Apple Color Emoji', sans-serif; %7D %3C/style%3E%3C!-- ИКОНКИ --%3E%3Ctext x='40' y='60' font-size='36' fill='%234a9eff' fill-opacity='0.4' transform='rotate(12 40 60)'%3E🎮%3C/text%3E%3Ctext x='380' y='120' font-size='40' fill='%237c3aed' fill-opacity='0.35' transform='rotate(-15 380 120)'%3E🚀%3C/text%3E%3Ctext x='220' y='400' font-size='38' fill='%2306b6d4' fill-opacity='0.4' transform='rotate(8 220 400)'%3E🎧%3C/text%3E%3Ctext x='180' y='90' font-size='28' fill='%23ec4899' fill-opacity='0.35' transform='rotate(-10 180 90)'%3E💡%3C/text%3E%3Ctext x='90' y='250' font-size='30' fill='%2310b981' fill-opacity='0.3' transform='rotate(20 90 250)'%3E🍕%3C/text%3E%3Ctext x='340' y='320' font-size='26' fill='%23f59e0b' fill-opacity='0.35' transform='rotate(-8 340 320)'%3E⚽%3C/text%3E%3Ctext x='420' y='450' font-size='32' fill='%236366f1' fill-opacity='0.4' transform='rotate(15 420 450)'%3E📷%3C/text%3E%3Ctext x='300' y='180' font-size='20' fill='%238b5cf6' fill-opacity='0.25' transform='rotate(-20 300 180)'%3E🎸%3C/text%3E%3Ctext x='150' y='350' font-size='22' fill='%2314b8a6' fill-opacity='0.3' transform='rotate(25 150 350)'%3E💻%3C/text%3E%3Ctext x='450' y='260' font-size='18' fill='%23ef4444' fill-opacity='0.3' transform='rotate(-12 450 260)'%3E🏆%3C/text%3E%3Ctext x='60' y='430' font-size='24' fill='%233b82f6' fill-opacity='0.35' transform='rotate(18 60 430)'%3E🎲%3C/text%3E%3Ctext x='280' y='50' font-size='20' fill='%23a855f7' fill-opacity='0.3' transform='rotate(-5 280 50)'%3E👻%3C/text%3E%3C/svg%3E");
                background-size: 400px 400px;
            }

            #app-background::after {
                content: "";
                position: absolute;
                top: 0;
                left: 0;
                width: 100%;
                height: 100%;
                /* Мягкий градиент без черноты */
                background: radial-gradient(circle at 50% 50%, rgba(18, 19, 22, 0.4) 0%, rgba(18, 19, 22, 0.85) 100%);
                pointer-events: none;
            }






        .chat-area {
            background: transparent; /* Было 0d1117 */
        }

        #noChat {
            background: transparent; /* Убираем фон отсюда */
            /* Убираем псевдоэлементы ::before и ::after у #noChat, так как теперь есть общий фон */
        }


        .premium-username-wrapper {
            display: flex;
            align-items: center;
            width: 100%;
        }

        .premium-username-prefix {
            color: #736AF0; /* Базовый цвет */
            font-size: 16px;
            font-weight: 600;
            margin-right: 2px;
            user-select: none;
            transition: color 0.3s ease; /* Плавная смена цвета при проверке */
        }

        .premium-status-msg {
            font-size: 13px;
            margin: -12px 0 20px 25px;
            min-height: 20px;
            transition: all 0.3s cubic-bezier(0.25, 0.8, 0.25, 1);
            opacity: 0;
            transform: translateY(-5px); /* Выезжает сверху вниз */
            font-weight: 500;
            pointer-events: none;
            display: flex;
            align-items: center;
            gap: 6px;
        }

            .premium-status-msg.visible {
                opacity: 1;
                transform: translateY(0);
            }

            .premium-status-msg.success {
                color: #10b981; /* Изумрудный */
            }

            .premium-status-msg.error {
                color: #ff595a; /* Красный */
            }

            .premium-status-msg.loading {
                color: #8e8e93; /* Серый */
            }

        /* Маленькая крутилка для статуса проверки */
        .status-spinner-small {
            width: 14px;
            height: 14px;
            border: 2px solid rgba(142, 142, 147, 0.3);
            border-top-color: #8e8e93;
            border-radius: 50%;
            animation: spin 0.8s linear infinite;
            flex-shrink: 0;
        }




        /* Скрываем полосу прокрутки для Chrome, Safari и Opera */
        .messages::-webkit-scrollbar {
            display: none;
        }






        /* PIP drag/resize */
        #localPip {
            /* важно: будет двигаться по left/top внутри .video-grid (она position: relative) */
            touch-action: none;
            user-select: none;
            cursor: grab;
        }

            #localPip.dragging,
            #localPip.resizing {
                transition: none !important; /* чтобы не было "резины" при перетаскивании */
            }

            #localPip.dragging {
                cursor: grabbing;
            }




            /* чтобы drag работал даже если тапаешь по самому видео */
            #localPip > video {
                pointer-events: none;
            }




            /* Ручка ресайза */
            #localPip .pip-resize-handle {
                position: absolute;
                right: 8px;
                bottom: 8px;
                width: 22px;
                height: 22px;
                border-radius: 7px;
                cursor: nwse-resize;
                background: rgba(255,255,255,0.16);
                border: 1px solid rgba(255,255,255,0.22);
                box-shadow: 0 6px 16px rgba(0,0,0,0.35);
                backdrop-filter: blur(8px);
            }




                /* небольшой “блик”, чтобы выглядело как UI-элемент */
                #localPip .pip-resize-handle::after {
                    content: "";
                    position: absolute;
                    inset: 6px;
                    border-right: 2px solid rgba(255,255,255,0.55);
                    border-bottom: 2px solid rgba(255,255,255,0.55);
                    border-radius: 2px;
                    transform: rotate(0deg);
                }




        /* Принудительное скрытие кнопок */
        .control-item-hidden {
            display: none !important;
        }




        /* Стили для картинок в чате */
        .chat-media-img {
            max-width: 240px; /* Ограничиваем ширину */
            max-height: 300px; /* Ограничиваем высоту */
            border-radius: 12px;
            cursor: pointer;
            display: block;
            margin-bottom: 2px;
            object-fit: cover;
            background: #222; /* Фон пока грузится */
        }




        /* Стили для файлов */
        .chat-file-card {
            display: flex;
            align-items: center;
            gap: 12px;
            padding: 10px;
            background: rgba(255, 255, 255, 0.08); /* Полупрозрачная подложка */
            border-radius: 10px;
            text-decoration: none;
            max-width: 260px;
            transition: 0.2s;
            border: 1px solid rgba(255,255,255,0.1);
        }

            .chat-file-card:hover {
                background: rgba(255, 255, 255, 0.12);
            }

        .file-icon {
            font-size: 24px;
            width: 40px;
            height: 40px;
            background: rgba(255, 255, 255, 0.1);
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            flex-shrink: 0;
        }

        .file-info {
            display: flex;
            flex-direction: column;
            overflow: hidden;
        }

        .file-name {
            color: white;
            font-size: 14px;
            font-weight: 600;
        }

        .file-action {
            color: #8faebf;
            font-size: 11px;
            margin-top: 2px;
        }




        /* Исправление для галочек поверх картинки (опционально) */
        .msg-meta {
            display: inline-block;
            vertical-align: bottom;
            margin-left: 5px;
        }




        /* --- СТИЛИ ДЛЯ КАРТИНОК В ЧАТЕ --- */
        .chat-media-img {
            /* Делаем их крупнее */
            width: 100%;
            max-width: 320px; /* Было 240, стало шире */
            height: auto; /* Авто-высота, чтобы не искажалось */
            max-height: 400px;
            border-radius: 12px;
            cursor: zoom-in; /* Курсор лупы */
            display: block;
            object-fit: cover;
            box-shadow: 0 4px 10px rgba(0,0,0,0.3); /* Тень для красоты */
            transition: transform 0.2s;
        }

            .chat-media-img:active {
                transform: scale(0.98); /* Эффект нажатия */
            }

        .media-container {
            overflow: hidden;
            border-radius: 12px;
            background: transparent; /* Убираем черный фон */
            display: inline-block;
        }




        /* --- СТИЛИ ДЛЯ ВСПЛЫВАЮЩЕГО ОКНА (LIGHTBOX) --- */
        .image-viewer {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.9); /* Темный фон */
            z-index: 9999; /* Поверх всего */
            display: none; /* Скрыто по умолчанию */
            justify-content: center;
            align-items: center;
            opacity: 0;
            transition: opacity 0.3s;
            backdrop-filter: blur(5px); /* Размытие фона */
        }

            .image-viewer.active {
                display: flex;
                opacity: 1;
            }

            .image-viewer img {
                max-width: 95%;
                max-height: 95%;
                border-radius: 8px;
                box-shadow: 0 0 20px rgba(0,0,0,0.5);
                transform: scale(0.9);
                transition: transform 0.3s;
            }

            .image-viewer.active img {
                transform: scale(1);
            }

        .close-viewer-btn {
            position: absolute;
            top: 20px;
            right: 30px;
            color: white;
            font-size: 40px;
            font-weight: bold;
            cursor: pointer;
            z-index: 10000;
        }


        /* --- ПЛАВАЮЩАЯ КНОПКА "ВНИЗ" --- */
        .scroll-bottom-btn {
            position: absolute;
            bottom: 95px; /* НОВОЕ: Подняли еще чуть выше над полем ввода */
            /* Отступ 8px (как у микрофона) на телефоне, на ПК выравнивается по чату */
            right: max(8px, calc(50% - 442px));
            width: 48px; /* НОВОЕ: Размер точно как у микрофона (было 44) */
            height: 48px; /* НОВОЕ: Размер точно как у микрофона (было 44) */
            background: #17181c;
            border-radius: 50%;
            border: 1px solid #333;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            box-shadow: 0 4px 15px rgba(0,0,0,0.6);
            z-index: 100;
            opacity: 0;
            transform: scale(0.5) translateY(20px);
            pointer-events: none;
            transition: all 0.3s cubic-bezier(0.25, 0.8, 0.25, 1);
        }

            .scroll-bottom-btn.visible {
                opacity: 1;
                transform: scale(1) translateY(0);
                pointer-events: auto;
            }

            .scroll-bottom-btn:hover {
                background: #2a2a2a;
            }

            .scroll-bottom-btn:active {
                transform: scale(0.9) !important;
            }

            .scroll-bottom-btn svg {
                fill: #aaa;
                width: 26px;
                height: 26px;
            }



        /* Крутилка загрузки */
        .upload-spinner {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 40px;
            height: 40px;
            border: 4px solid rgba(255, 255, 255, 0.3);
            border-radius: 50%;
            border-top-color: white;
            animation: spin 1s linear infinite;
            z-index: 10;
            box-shadow: 0 0 10px rgba(0,0,0,0.5);
        }

        @keyframes spin {
            to {
                transform: translate(-50%, -50%) rotate(360deg);
            }
        }




        /* --- Стили профиля как в Telegram --- */

        /* Фон шапки (зеленый паттерн) */
        .tg-header-bg {
            background: #5a9e57;
            /* ИЗМЕНЕНО: учитываем безопасную зону сверху (челку) */
            padding: calc(10px + env(safe-area-inset-top)) 15px 20px 15px;
            color: white;
            position: relative;
            box-shadow: 0 2px 5px rgba(0,0,0,0.2);
        }

        .tg-header-top {
            display: flex;
            align-items: center;
            gap: 15px;
            margin-bottom: 20px;
        }

        .tg-icon-btn {
            background: none;
            border: none;
            color: white;
            font-size: 20px;
            cursor: pointer;
            padding: 5px;
        }

        .tg-profile-info {
            display: flex;
            align-items: center;
            gap: 20px;
        }




        /* Аватарка */
        .tg-avatar-large {
            width: 70px;
            height: 70px;
            border-radius: 50%;
            background: #333;
            position: relative;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 30px;
            color: #aaa;
            border: 2px solid white; /* Белая обводка как в дизайне */
        }

            .tg-avatar-large img {
                width: 100%;
                height: 100%;
                border-radius: 50%;
                object-fit: cover;
            }

        .tg-avatar-edit-icon {
            position: absolute;
            bottom: -2px;
            right: -2px;
            background: #4a8e4a;
            width: 24px;
            height: 24px;
            border-radius: 50%;
            font-size: 12px;
            display: flex;
            align-items: center;
            justify-content: center;
            border: 2px solid #5a9e57;
        }


        /* --- ПОИСК ВНУТРИ ЧАТА (ТЕЛЕГРАМ СТИЛЬ) --- */
        .chat-search-bar {
            background: #17181c;
            display: flex;
            align-items: center;
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            /* Высота тоже должна учитывать челку */
            height: calc(57px + env(safe-area-inset-top));
            z-index: 20;
            /* Отступ сверху, чтобы текст не наезжал на батарею */
            padding: env(safe-area-inset-top) 5px 0 15px;
        }

            .chat-search-bar.hidden {
                display: none !important;
            }

        .search-glass-icon {
            margin-right: 10px;
            flex-shrink: 0;
        }

        #chatSearchInput {
            flex: 1;
            min-width: 0; /* ВАЖНО: Разрешает инпуту сжиматься на телефонах */
            background: transparent;
            border: none;
            color: white;
            font-size: 16px;
            outline: none;
            padding: 0;
            height: 100%;
        }

            #chatSearchInput::placeholder {
                color: #888;
            }


        .chat-search-count {
            color: #aaa;
            font-size: 14px;
            margin: 0 5px;
            white-space: nowrap;
            flex-shrink: 0; /* Не даем счетчику сжиматься */
        }

        .chat-search-actions {
            display: flex;
            align-items: center;
            gap: 0px; /* Убрали лишние дырки между кнопками */
            flex-shrink: 0; /* ВАЖНО: Не даем блоку с кнопками улетать за экран */
        }

        .chat-search-btn {
            background: none;
            border: none;
            cursor: pointer;
            width: 36px; /* Чуть компактнее для телефона */
            height: 36px;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: background 0.2s;
            padding: 0;
            flex-shrink: 0;
        }

            .chat-search-btn:hover {
                background: rgba(255,255,255,0.08);
            }

            .chat-search-btn:active {
                background: rgba(255,255,255,0.15);
            }

            .chat-search-btn svg {
                transition: fill 0.2s;
            }

            .chat-search-btn:hover svg {
                fill: #fff;
            }

        .search-divider {
            width: 1px;
            height: 24px;
            background: #333;
            margin: 0 5px;
        }

        /* Подсветка текста */
        .highlight {
            background-color: rgba(255, 235, 59, 0.3);
            color: inherit;
            border-radius: 3px;
        }

            .highlight.active-match {
                background-color: #ff9800;
                color: #fff;
            }


        /* Выпадающее меню поиска по чату */
        .chat-search-dropdown {
            position: absolute;
            top: 65px; /* Небольшой отступ вниз от шапки */
            right: 15px; /* Выравниваем по правому краю на ПК */
            width: 360px; /* Аккуратная фиксированная ширина */
            max-height: 50vh; /* Максимум половина экрана в высоту */
            background: #17181c;
            border: 1px solid #333; /* Тонкая рамка */
            border-radius: 12px; /* Скругленные края */
            box-shadow: 0 8px 25px rgba(0,0,0,0.6); /* Красивая объемная тень */
            z-index: 100; /* Поверх всех сообщений */
            overflow-y: auto;
            overflow-x: hidden;
            display: flex;
            flex-direction: column;
        }

        /* Адаптация для телефона (открывается по центру с отступами по краям) */
        @media (max-width: 768px) {
            .chat-search-dropdown {
                left: 10px;
                right: 10px;
                width: auto;
                max-height: 60vh; /* Чуть больше высоты на мобилке */
            }
        }

        .chat-search-dropdown.hidden {
            display: none !important;
        }

        .search-msg-item {
            display: flex;
            padding: 10px 15px;
            cursor: pointer;
            transition: background 0.1s;
            border-bottom: 1px solid rgba(255,255,255,0.05); /* Еле заметная линия между пунктами */
        }

            .search-msg-item:last-child {
                border-bottom: none; /* Убираем линию у последнего элемента */
            }

            .search-msg-item:hover {
                background: #2a2a2a;
            }

            .search-msg-item.active {
                background: #2f2f2f; /* Подсветка выбранного пункта */
            }

        .search-msg-avatar {
            width: 42px;
            height: 42px;
            border-radius: 50%;
            margin-right: 12px;
            flex-shrink: 0;
            object-fit: cover;
            background: #333;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 16px;
        }

        /* Жесткая иерархия слоев для премиум-шторок */
        #profileSheet {
            z-index: 6000 !important;
        }

        #editProfileSheet,
        #generalSettingsSheet {
            z-index: 6010 !important; /* Эти окна всегда ПОВЕРХ профиля */
        }

        .search-msg-content {
            flex: 1;
            overflow: hidden;
            display: flex;
            flex-direction: column;
            justify-content: center;
        }

        .search-msg-header {
            display: flex;
            justify-content: space-between;
            align-items: baseline;
            margin-bottom: 2px;
        }

        .search-msg-name {
            font-weight: 600;
            font-size: 14px;
            color: #fff;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
        }

        .search-msg-time {
            font-size: 12px;
            color: #888;
            flex-shrink: 0;
            margin-left: 10px;
        }

        .search-msg-text {
            font-size: 13px;
            color: #aaa;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
        }

        /* Имя и статус */
        .tg-profile-name-block {
            flex: 1;
            display: flex;
            flex-direction: column;
        }

        .tg-name-input {
            background: transparent;
            border: none;
            color: white;
            font-size: 20px;
            font-weight: 600;
            width: 100%;
            outline: none;
            padding: 0;
        }

            .tg-name-input::placeholder {
                color: rgba(255,255,255,0.6);
            }

        .tg-profile-status {
            color: rgba(255,255,255,0.8);
            font-size: 13px;
            margin-top: 4px;
        }


        /* --- Анимация загрузки диалогов (Telegram style) --- */
        .tg-spinner-container {
            display: flex;
            justify-content: center;
            align-items: center;
            padding: 40px;
            width: 100%;
        }

        .tg-spinner {
            width: 36px;
            height: 36px;
            border: 3px solid rgba(115, 106, 240, 0.2); /* Полупрозрачный фиолетовый */
            border-top-color: #736AF0; /* Яркий фиолетовый */
            border-radius: 50%;
            animation: tg-spin 0.8s linear infinite;
        }

        @keyframes tg-spin {
            to {
                transform: rotate(360deg);
            }
        }

        /* Список настроек */
        .tg-settings-list {
            background: #17212b; /* Темный фон списка */
            padding-top: 10px;
        }

        .tg-section-title {
            color: #7394ae; /* Голубой цвет заголовков */
            font-size: 13px;
            font-weight: bold;
            padding: 15px 20px 5px 20px;
            text-transform: uppercase;
        }

        .tg-item {
            display: flex;
            align-items: center;
            padding: 10px 20px;
            cursor: pointer;
            transition: 0.2s;
        }

            .tg-item:hover {
                background: #202b36;
            }

        .tg-item-icon {
            font-size: 22px;
            width: 40px;
            text-align: center;
            margin-right: 15px;
            color: #8faebf;
        }

        .tg-item-content {
            flex: 1;
            border-bottom: 1px solid #0e1621; /* Разделитель */

            padding-top: 5px;
        }

        .tg-item:last-child .tg-item-content {
            border-bottom: none;
        }

        .tg-input-clean {
            background: transparent;
            border: none;
            color: white;
            font-size: 16px;
            width: 100%;
            outline: none;
            padding: 0;
            margin-bottom: 3px;
        }

        .tg-item-label {
            color: #7f91a4;
            font-size: 12px;
        }

        .tg-item-value {
            color: white;
            font-size: 16px;
            margin-bottom: 3px;
        }

        .tg-divider {
            height: 10px;
            background: #0e1621; /* Темная полоса между секциями */
            margin: 5px 0;
        }



        /* Стили для окна редактирования */
        .full-screen-sheet {
            top: 0;
            height: 100% !important;
            background: #181818 !important;
            display: flex;
            flex-direction: column;
            z-index: 6000;
            transform: translateY(100%);
            transition: transform 0.3s cubic-bezier(0.25, 0.8, 0.25, 1);
            /* ДОБАВЛЕНО: сбрасываем стили родительского action-sheet */
            padding: 0 !important;
            border-radius: 0 !important;
        }

            .full-screen-sheet.open {
                transform: translateY(0);
            }

        .edit-content-scroll {
            flex: 1;
            overflow-y: auto;
            padding: 0;
        }

        /* --- ОКНО ПРЕДУПРЕЖДЕНИЯ ДЛЯ ССЫЛОК --- */
        /* --- ПРЕМИАЛЬНОЕ ОКНО ДЛЯ ССЫЛОК --- */
        .link-modal {
            background: #1c1c1e; /* Фирменный цвет карточки */
            width: 90%;
            max-width: 340px;
            border-radius: 24px; /* Сильное скругление, как в окне обновления */
            padding: 30px 25px;
            box-shadow: 0 10px 40px rgba(0,0,0,0.6);
            display: flex;
            flex-direction: column;
            align-items: center;
            text-align: center;
            transform: scale(0.9);
            animation: scaleUp 0.2s cubic-bezier(0.25, 0.8, 0.25, 1) forwards;
        }

        .link-modal-icon {
            font-size: 64px; /* Большая иконка */
            margin-bottom: 15px;
        }

        .link-modal h3 {
            margin: 0 0 10px 0;
            font-size: 22px;
            color: white;
            font-weight: bold;
        }

        .link-modal p {
            margin: 0 0 20px 0;
            font-size: 14px;
            color: #8e8e93;
            line-height: 1.4;
        }

        .link-url-box {
            background: #121316;
            padding: 12px 15px;
            border-radius: 12px;
            font-size: 14px;
            color: #ffffff;
            word-break: break-all;
            width: 100%;
            max-height: 80px;
            overflow-y: auto;
            margin-bottom: 25px;
            border: 1px solid rgba(255,255,255,0.05);
            box-shadow: inset 0 2px 5px rgba(0,0,0,0.2);
        }

        /* Жестко задаем белый цвет для ссылок внутри чата */
        a.chat-link {
            color: #ffffff !important;
        }

        .link-modal-buttons {
            display: flex;
            flex-direction: column; /* Кнопки друг под другом */
            width: 100%;
            gap: 10px;
        }

        .btn-link-open {
            background: #736AF0;
            color: white;
            font-weight: bold;
            font-size: 16px;
            border-radius: 12px;
            padding: 14px;
            border: none;
            width: 100%;
            cursor: pointer;
            transition: transform 0.2s;
        }

            .btn-link-open:active {
                transform: scale(0.96);
            }

        .btn-link-cancel {
            background: transparent;
            color: #8e8e93;
            font-weight: bold;
            font-size: 16px;
            border: none;
            padding: 14px;
            width: 100%;
            cursor: pointer;
        }

            .btn-link-cancel:active {
                color: white;
            }
        /* Фирменный фиолетовый */

        /* Аватар секция */
        .edit-avatar-section {
            display: flex;
            justify-content: center;
            padding: 30px 0;
            background: #181818;
        }

        .edit-avatar-wrapper {
            width: 100px;
            height: 100px;
            position: relative;
            cursor: pointer;
        }

        /* Премиальный статус шифрования в списке диалогов */
        .premium-encrypted-preview {
            display: inline-flex;
            align-items: center;
            color: #736AF0; /* Наш фирменный цвет */
            font-size: 13.5px;
            font-style: italic;
            animation: pulse-encryption 2s infinite ease-in-out;
        }

        @keyframes pulse-encryption {
            0% {
                opacity: 0.5;
            }

            50% {
                opacity: 1;
            }

            100% {
                opacity: 0.5;
            }
        }


        /* --- СТИЛИ ДЛЯ ЗВОНКОВ В ЧАТЕ --- */
        .chat-call-card {
            display: flex;
            align-items: center;
            gap: 12px;
            padding: 4px 6px 4px 0;
            cursor: pointer;
            min-width: 170px;
        }

        .call-icon-wrapper {
            width: 40px;
            height: 40px;
            border-radius: 50%;
            background: rgba(255, 255, 255, 0.1);
            display: flex;
            align-items: center;
            justify-content: center;
            flex-shrink: 0;
            transition: background 0.2s;
        }

        .msg-me .call-icon-wrapper {
            background: rgba(255, 255, 255, 0.2);
        }

        .chat-call-card:active .call-icon-wrapper {
            background: rgba(255, 255, 255, 0.3);
        }

        .call-info {
            display: flex;
            flex-direction: column;
        }

        .call-title {
            font-weight: 600;
            font-size: 15px;
            color: white;
        }

        .call-time {
            font-size: 13px;
            margin-top: 2px;
        }

        /* --- Переключатель (Toggle Switch) --- */
        .tg-switch {
            position: relative;
            display: inline-block;
            width: 42px;
            height: 24px;
        }

            .tg-switch input {
                opacity: 0;
                width: 0;
                height: 0;
            }

        .slider {
            position: absolute;
            cursor: pointer;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background-color: #555; /* Серый выкл */
            transition: .4s;
            border-radius: 24px;
        }

            .slider:before {
                position: absolute;
                content: "";
                height: 18px;
                width: 18px;
                left: 3px;
                bottom: 3px;
                background-color: white;
                transition: .4s;
                border-radius: 50%;
            }

        input:checked + .slider {
            background-color: #8774e1; /* Фиолетовый вкл */
        }

            input:checked + .slider:before {
                transform: translateX(18px);
            }

        .edit-avatar-wrapper img, .avatar-placeholder-large {
            width: 100%;
            height: 100%;
            border-radius: 50%;
            object-fit: cover;
        }

        .avatar-placeholder-large {
            background: linear-gradient(135deg, #6a11cb, #2575fc);
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 40px;
            font-weight: bold;
            color: white;
        }

        .camera-overlay {
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0,0,0,0.4);
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            backdrop-filter: blur(2px);
        }



        /* Поля ввода (Material Design стиль) */
        .edit-form-group {
            padding: 10px 20px;
        }

        .tg-input-field {
            position: relative;
            margin-bottom: 24px;
            background: transparent;
            border: 1px solid #444; /* Рамка */
            border-radius: 12px;
            padding: 0;
        }

            .tg-input-field input, .tg-input-field textarea {
                width: 100%;
                background: transparent;
                border: none;
                color: white;
                font-size: 16px;
                padding: 14px 12px;
                outline: none;
                border-radius: 12px;
            }

            .tg-input-field textarea {
                resize: none;
                min-height: 50px;
            }



            /* Плавающий лейбл */
            .tg-input-field label {
                position: absolute;
                left: 12px;
                top: 14px;
                color: #888;
                font-size: 16px;
                pointer-events: none;
                transition: 0.2s ease all;
                background: #181818;
                padding: 0 4px;
            }



            /* Состояние фокуса или заполненности */
            .tg-input-field input:focus ~ label,
            .tg-input-field input:not(:placeholder-shown) ~ label,
            .tg-input-field textarea:focus ~ label,
            .tg-input-field textarea:not(:placeholder-shown) ~ label {
                top: -10px;
                font-size: 12px;
                color: #8774e1;
            }

            .tg-input-field input:focus, .tg-input-field textarea:focus {
                border-color: #8774e1; /* Цвет акцента при фокусе */
            }


        /* Стили для списка языков */
        .lang-option {
            padding: 12px 15px;
            background: #333;
            border-radius: 8px;
            cursor: pointer;
            font-size: 15px;
            color: white;
            transition: background 0.2s;
            display: flex;
            align-items: center;
        }

            .lang-option:hover {
                background: #444;
            }

            .lang-option:active {
                background: #555;
            }

        .char-counter {
            position: absolute;
            bottom: -20px;
            right: 5px;
            font-size: 12px;
            color: #888;
        }

        .field-hint {
            font-size: 13px;
            color: #888;
            margin-top: -15px;
            margin-bottom: 15px;
            line-height: 1.4;
        }

        .edit-separator {
            height: 12px;
            background: #0f0f0f;
            border-top: 1px solid #222;
            border-bottom: 1px solid #222;
            margin-bottom: 15px;
        }

        .section-header {
            color: #8774e1;
            font-size: 14px;
            font-weight: 500;
            margin-bottom: 15px;
            text-transform: uppercase;
        }




        /* Затемнение картинки во время загрузки */
        .loading-overlay img {
            filter: brightness(0.5) blur(2px);
            transition: 0.3s;
        }




        /* Эффект кликабельности */
        .click-to-copy {
            cursor: pointer;
            position: relative;
        }

            .click-to-copy:active {
                background-color: #202b36;
            }




        /* Затемнение фона */
        .modal-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.7); /* Темный фон */
            z-index: 20000; /* Поверх всего */
            display: flex;
            justify-content: center;
            align-items: center;
            opacity: 0;
            animation: fadeIn 0.2s forwards;
        }

        @keyframes fadeIn {
            to {
                opacity: 1;
            }
        }



        /* Само окно */
        .delete-modal {
            background: #252525;
            width: 90%;
            max-width: 320px;
            border-radius: 16px;
            padding: 22px;
            box-shadow: 0 10px 30px rgba(0,0,0,0.5);
            display: flex;
            flex-direction: column;
            gap: 15px;
            transform: scale(0.9);
            animation: scaleUp 0.2s forwards;
        }

        @keyframes scaleUp {
            to {
                transform: scale(1);
            }
        }

        .delete-modal h3 {
            margin: 0;
            font-size: 18px;
            color: white;
            font-weight: 600;
        }

        .delete-modal p {
            margin: 0;
            font-size: 15px;
            color: #ccc;
            line-height: 1.4;
        }



        /* Чекбокс */
        .checkbox-container {
            display: flex;
            align-items: center;
            gap: 12px;
            cursor: pointer;
        }

            .checkbox-container input[type="checkbox"] {
                appearance: none;
                width: 20px;
                height: 20px;
                border: 2px solid #888;
                border-radius: 6px;
                background: transparent;
                cursor: pointer;
                position: relative;
                transition: 0.2s;
            }

                .checkbox-container input[type="checkbox"]:checked {
                    background: #8774e1; /* Фиолетовый цвет как в TG */
                    border-color: #8774e1;
                }

                    .checkbox-container input[type="checkbox"]:checked::after {
                        content: '✓';
                        position: absolute;
                        color: white;
                        font-size: 14px;
                        left: 3px;
                        top: -1px;
                        font-weight: bold;
                    }

            .checkbox-container label {
                font-size: 15px;
                color: white;
                cursor: pointer;
                user-select: none;
            }



        /* Кнопки */
        .modal-buttons {
            display: flex;
            justify-content: flex-end;
            gap: 15px;
            margin-top: 10px;
        }

            .modal-buttons button {
                background: none;
                border: none;
                font-size: 15px;
                font-weight: bold;
                cursor: pointer;
                padding: 5px 10px;
                border-radius: 6px;
                transition: 0.2s;
            }

        .btn-cancel {
            color: #8774e1; /* Фиолетовый */
        }

            .btn-cancel:hover {
                background: rgba(135, 116, 225, 0.1);
            }

        .btn-confirm {
            color: #ff595a; /* Красный */
        }

            .btn-confirm:hover {
                background: rgba(255, 89, 90, 0.1);
            }



        /* Контекстное меню (скрыто по умолчанию) */
        .context-menu {
            position: fixed;
            z-index: 10000;
            width: 220px;
            background: transparent;
            display: none; /* Скрыто */
            flex-direction: column;
            gap: 8px;
            opacity: 0;
            transform: scale(0.95);
            transition: opacity 0.2s, transform 0.2s;
        }

            .context-menu.active {
                display: flex;
                opacity: 1;
                transform: scale(1);
            }



        /* Бар реакций сверху */
        .reactions-bar {
            background: #252525;
            padding: 8px;
            border-radius: 14px;
            display: flex;
            justify-content: space-between;
            box-shadow: 0 4px 15px rgba(0,0,0,0.5);
        }

            .reactions-bar span {
                font-size: 20px;
                cursor: pointer;
                transition: transform 0.2s;
            }

                .reactions-bar span:hover {
                    transform: scale(1.2);
                }



        /* Основной список действий */
        .context-list {
            background: #252525; /* Цвет фона меню как в TG */
            border-radius: 14px;
            padding: 6px;
            box-shadow: 0 4px 15px rgba(0,0,0,0.5);
            display: flex;
            flex-direction: column;
        }

        .context-item {
            display: flex;
            align-items: center;
            padding: 8px 12px;
            color: white;
            font-size: 14px;
            font-weight: 500;
            cursor: pointer;
            border-radius: 8px;
            transition: background 0.1s;
        }

            .context-item:hover {
                background: #333; /* Подсветка при наведении */
            }

        .context-icon {
            margin-right: 12px;
            font-size: 16px;
            width: 20px;
            text-align: center;
        }



        /* Красная кнопка удаления */
        .context-item.delete {
            color: #ff595a;
        }

            .context-item.delete .context-icon {
                filter: grayscale(0) !important; /* Чтобы иконка не была серой */
            }

        .context-divider {
            height: 1px;
            background: #383838;
            margin: 4px 10px;
        }



        /* Всплывающее уведомление (Toast) */
        #toast-notification {
            position: fixed;
            bottom: 80px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(0, 0, 0, 0.7);
            color: white;
            padding: 10px 20px;
            border-radius: 20px;
            font-size: 14px;
            opacity: 0;
            transition: opacity 0.3s;
            z-index: 7000;
            pointer-events: none;
        }

            #toast-notification.show {
                opacity: 1;
            }

        .tg-bio-input {
            background: transparent;
            border: none;
            color: white;
            font-size: 16px;
            width: 100%;
            outline: none;
            resize: none;
            font-family: inherit;
            padding: 0;
            margin-bottom: 3px;
            min-height: 24px;
        }

            .tg-bio-input::placeholder {
                color: rgba(255, 255, 255, 0.4);
            }




        /* Стили для элементов меню (как в Telegram) */
        .action-item {
            display: flex;
            align-items: center;
            padding: 12px 16px;
            cursor: pointer;
            background: #252525;
            transition: background 0.2s;
        }

            .action-item:hover {
                background: #2f2f2f;
            }

        .action-icon {
            font-size: 20px;
            margin-right: 15px;
            width: 24px;
            text-align: center;
        }

        .action-text {
            font-size: 16px;
            color: white;
        }



        /* Панель ответа над вводом */
        .reply-bar {
            width: 100%;
            background: #17181c;
            border-top: 1px solid #333;
            padding: 8px 15px;
            display: flex;
            align-items: center;
            border-left: 3px solid #736AF0;
            /* НОВОЕ: Плавный выезд и прозрачность */
            transition: opacity 0.25s ease, transform 0.25s cubic-bezier(0.2, 0.85, 0.3, 1);
            z-index: -1; /* Панель прячется ПОД основным полем ввода */
        }

            .reply-bar.editing {
                border-left: 3px solid #007bff;
            }

            /* НОВОЕ: Переопределяем скрытие, чтобы работала анимация выезда */
            .reply-bar.hidden {
                display: flex !important;
                opacity: 0;
                transform: translateY(100%); /* Прячем её вниз на всю высоту */
                pointer-events: none; /* Запрещаем случайные нажатия */
            }

        .reply-content {
            flex: 1;
            margin-left: 10px;
            overflow: hidden;
        }

        .reply-title {
            color: #736AF0;
            font-size: 13px;
            font-weight: bold;
        }

        .reply-text {
            color: #ccc;
            font-size: 13px;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
        }

        .reply-close {
            background: none;
            border: none;
            color: #888;
            font-size: 18px;
            cursor: pointer;
            padding: 5px;
        }



        /* Стили для цитаты внутри сообщения */
        .msg-reply-quote {
            border-left: 2px solid white;
            padding-left: 8px;
            margin-bottom: 4px;
            cursor: pointer;
        }

        .msg-reply-name {
            font-size: 11px;
            color: rgba(255,255,255,0.7);
            font-weight: bold;
        }

        .msg-reply-text {
            font-size: 12px;
            color: white;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
        }

        .birth-modal {
            background: #252525;
            width: 92%;
            max-width: 360px;
            border-radius: 16px;
            padding: 18px;
            box-shadow: 0 10px 30px rgba(0,0,0,0.5);
            display: flex;
            flex-direction: column;
            gap: 14px;
        }


        /* --- ЭФФЕКТ ДОЛГОГО НАЖАТИЯ (iOS СТИЛЬ) --- */
        #chatBlurOverlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.45);
            backdrop-filter: blur(10px);
            -webkit-backdrop-filter: blur(10px);
            z-index: 2000; /* Перекрывает шапку и поле ввода */
            display: none;
            opacity: 0;
            transition: opacity 0.2s ease;
        }

            #chatBlurOverlay.active {
                opacity: 1;
            }

        .msg-highlighted {
            z-index: 2001 !important; /* Поднимаем сообщение поверх блюра */
            position: relative;
            transform: scale(1.02); /* Эффект "выдавливания" как на iPhone */
            box-shadow: 0 15px 35px rgba(0,0,0,0.6);
            transition: transform 0.2s cubic-bezier(0.175, 0.885, 0.32, 1.275) !important;
        }

        .birth-pickers {
            display: grid;
            grid-template-columns: 1fr 1fr 1fr;
            gap: 10px;
        }

            .birth-pickers select {
                width: 100%;
                background: #1f1f1f;
                border: 1px solid #444;
                color: white;
                padding: 12px 10px;
                border-radius: 12px;
                outline: none;
            }



        /* Анимация точек для статуса "печатает" */
        @keyframes blink {
            0% {
                opacity: .2;
            }

            20% {
                opacity: 1;
            }

            100% {
                opacity: .2;
            }
        }

        .typing-dots span {
            animation-name: blink;
            animation-duration: 1.4s;
            animation-iteration-count: infinite;
            animation-fill-mode: both;
        }

            .typing-dots span:nth-child(2) {
                animation-delay: .2s;
            }

            .typing-dots span:nth-child(3) {
                animation-delay: .4s;
            }

        .typing-text {
            color: #736AF0 !important; /* Фиолетовый цвет для статуса печатает */
            font-weight: bold;
        }


        /* Разделитель даты внутри чата */
        .chat-date-separator {
            align-self: center;
            background: rgba(0, 0, 0, 0.35);
            color: white;
            font-size: 13px;
            padding: 4px 12px;
            border-radius: 12px;
            margin: 10px 0;
            font-weight: 500;
            z-index: 2;
            backdrop-filter: blur(4px);
            user-select: none;
            cursor: pointer; /* ДОБАВЛЕНО */
            transition: background 0.2s; /* ДОБАВЛЕНО */
        }

            .chat-date-separator:active {
                background: rgba(0, 0, 0, 0.6);
            }

        /* Плавающая дата при скролле */
        .floating-date {
            position: absolute;
            top: 66px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(0, 0, 0, 0.45);
            color: white;
            font-size: 13px;
            padding: 4px 12px;
            border-radius: 12px;
            font-weight: 500;
            z-index: 50;
            backdrop-filter: blur(4px);
            opacity: 0;
            transition: opacity 0.3s ease;
            pointer-events: auto; /* ВАЖНО: изменено с none на auto, чтобы работал клик! */
            cursor: pointer;
        }

            .floating-date:active {
                background: rgba(0, 0, 0, 0.7);
            }

            .floating-date.visible {
                opacity: 1;
            }


        /* ==========================================
             ПРЕМИАЛЬНЫЙ ДИЗАЙН ПРОФИЛЯ
             ========================================== */

        /* Общий фон шторок профиля */
        .action-sheet.full-screen-sheet {
            background: #121316 !important; /* Цвет как у основного фона приложения */
        }

        #profileSheet {
            z-index: 6000 !important;
        }

        #editProfileSheet, #generalSettingsSheet {
            z-index: 6010 !important;
        }

        /* Красивая верхняя шапка */
        .premium-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: calc(env(safe-area-inset-top) + 15px) 15px 15px;
            background: #121316;
            border-bottom: 1px solid rgba(255, 255, 255, 0.03);
            z-index: 10;
        }

        /* Центрированная информация (Аватар и Имя) */
        .premium-profile-info {
            display: flex;
            flex-direction: column;
            align-items: center;
            padding: 30px 20px 25px;
        }

        /* Элитное свечение вокруг аватарки */
        .premium-avatar-wrap {
            width: 110px;
            height: 110px;
            border-radius: 50%;
            padding: 4px; /* Толщина градиентной рамки */
            background: linear-gradient(135deg, #736AF0, #3b82f6);
            box-shadow: 0 8px 25px rgba(115, 106, 240, 0.3);
            margin-bottom: 18px;
            position: relative;
            transition: transform 0.2s;
        }

            .premium-avatar-wrap:active {
                transform: scale(0.95);
            }

            .premium-avatar-wrap img, .premium-avatar-wrap .placeholder {
                width: 100%;
                height: 100%;
                border-radius: 50%;
                object-fit: cover;
                background: #1c1c1e;
                border: 4px solid #121316; /* Визуально отделяет рамку от фото */
                display: flex;
                align-items: center;
                justify-content: center;
                font-size: 40px;
                font-weight: bold;
                color: white;
            }

        .premium-name-input {
            background: transparent;
            border: none;
            color: white;
            font-size: 24px;
            font-weight: 700;
            width: 100%;
            text-align: center;
            outline: none;
            pointer-events: none; /* В режиме просмотра нельзя кликать */
            letter-spacing: -0.5px;
        }

        .premium-status {
            color: #736AF0;
            font-size: 14px;
            font-weight: 600;
            margin-top: 5px;
        }

        /* Карточки с настройками (как в iOS) */
        .premium-section-title {
            font-size: 13px;
            font-weight: 600;
            color: #8e8e93;
            text-transform: uppercase;
            letter-spacing: 0.8px;
            margin: 0 0 8px 25px;
        }

        .premium-section {
            background: #1c1c1e;
            border-radius: 20px;
            margin: 0 15px 25px;
            box-shadow: 0 6px 20px rgba(0,0,0,0.15);
            border: 1px solid rgba(255, 255, 255, 0.02);
            overflow: hidden;
        }

        /* Строка внутри карточки */
        .premium-item {
            display: flex;
            align-items: center;
            padding: 16px 20px;
            cursor: pointer;
            transition: background 0.2s;
            border-bottom: 1px solid rgba(255,255,255,0.03);
        }

            .premium-item:last-child {
                border-bottom: none;
            }

            .premium-item:active {
                background: rgba(255,255,255,0.05);
            }

        /* Иконка слева */
        .premium-item-icon {
            width: 36px;
            height: 36px;
            border-radius: 12px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 18px;
            margin-right: 16px;
        }

        /* Контейнер для текста */
        .premium-item-content {
            flex: 1;
            display: flex;
            flex-direction: column;
            justify-content: center;
        }

        .premium-item-value {
            font-size: 16px;
            color: white;
            font-weight: 500;
        }

        .premium-item-label {
            font-size: 12px;
            color: #8e8e93;
            margin-top: 4px;
        }

        .premium-item-value {
            font-size: 16px;
            color: white;
            font-weight: 500;
            word-break: break-all;
        }

        .premium-bio-input {
            background: transparent;
            border: none;
            color: white;
            font-size: 15px;
            font-weight: 400;
            width: 100%;
            outline: none;
            resize: none;
            padding: 0;
            font-family: inherit;
            line-height: 1.4;
        }

        /* Поля в режиме редактирования */
        .premium-input-box {
            padding: 16px 20px;
            background: transparent;
            position: relative;
            display: flex;
            flex-direction: column;
        }

            .premium-input-box label {
                font-size: 12px;
                color: #8e8e93;
                margin-bottom: 6px;
            }

            .premium-input-box input, .premium-input-box textarea {
                width: 100%;
                background: transparent;
                border: none;
                color: white;
                font-size: 16px;
                outline: none;
                font-family: inherit;
            }

                .premium-input-box input::placeholder, .premium-input-box textarea::placeholder {
                    color: #555;
                }

        .premium-input-divider {
            height: 1px;
            background: rgba(255,255,255,0.03);
            margin: 0 20px;
        }
        /* Стили для перевода */
        .translated-block {
            margin-top: 6px;
            padding-top: 6px;
            border-top: 1px solid rgba(255, 255, 255, 0.1);
            font-size: 14px;
            color: #4a9eff; /* Голубой цвет для перевода */
            font-style: italic;
            display: block;
            animation: fadeIn 0.5s;
            /* --- НОВОЕ: Перевод БОЛЬШИМИ БУКВАМИ --- */
            text-transform: uppercase;
            font-weight: bold; /* Жирный, чтобы лучше читалось */
        }


        /* --- НОВОЕ: Оригинальный текст маленькими буквами --- */
        .msg-text {
            text-transform: lowercase;
            white-space: pre-wrap; /* Заставляет браузер отображать абзацы (Enter) */
            word-break: break-word;
        }


        /* ==========================================
        АДАПТАЦИЯ ШТОРОК ДЛЯ КОМПЬЮТЕРА (ПК)
        ========================================== */
        @media (min-width: 769px) {
            .full-screen-sheet {
                top: 50% !important;
                left: 50% !important;
                bottom: auto !important;
                /* 1. Сделали шире (было 420px) */
                width: 550px !important;
                height: 85vh !important;
                max-height: 800px !important;
                border-radius: 28px !important; /* Чуть более мягкое скругление */
                /* 2. Улучшенная анимация и глубокая премиальная тень */
                transform: translate(-50%, -45%) scale(0.96) !important;
                opacity: 0;
                transition: transform 0.4s cubic-bezier(0.34, 1.56, 0.64, 1), opacity 0.3s ease !important;
                box-shadow: 0 30px 100px rgba(0,0,0,0.8), 0 0 0 1px rgba(255,255,255,0.05) !important;
                /* Прячем дефолтный скроллбар для Firefox */
                scrollbar-width: none;
            }

                .full-screen-sheet.open {
                    transform: translate(-50%, -50%) scale(1) !important;
                    opacity: 1;
                }

                /* 3. СТИЛИЗАЦИЯ СКРОЛЛБАРА (Делаем его "невидимым" или очень тонким) */
                /* Выбираем внутренний контейнер со скроллом (обычно это .edit-content-scroll) */
                .full-screen-sheet ::-webkit-scrollbar {
                    width: 4px; /* Очень тонкий */
                }

                .full-screen-sheet ::-webkit-scrollbar-track {
                    background: transparent; /* Полностью убираем дорожку (показывалку высоты) */
                }

                .full-screen-sheet ::-webkit-scrollbar-thumb {
                    background: rgba(115, 106, 240, 0.2); /* Едва заметный цвет твоего бренда */
                    border-radius: 10px;
                    transition: background 0.3s;
                }

                .full-screen-sheet :hover::-webkit-scrollbar-thumb {
                    background: rgba(115, 106, 240, 0.5); /* Проявляется только при наведении */
                }

                /* Исправление шапок для ПК */
                .full-screen-sheet .tg-header-bg,
                .full-screen-sheet .premium-header {
                    border-top-left-radius: 28px !important;
                    border-top-right-radius: 28px !important;
                    padding-top: 20px !important;
                    padding-bottom: 20px !important;
                }
        }


        /* --- ФИКС ПРЫГАЮЩЕЙ ШАПКИ И СКРОЛЛА --- */
        #editProfileSheet {
            display: block !important;
        }

            #editProfileSheet .premium-header {
                position: absolute;
                top: 0;
                left: 0;
                right: 0;
                z-index: 100;
            }

            #editProfileSheet > div:nth-child(2) {
                position: absolute;
                top: 0;
                left: 0;
                right: 0;
                bottom: 0;
                padding-top: calc(env(safe-area-inset-top) + 65px) !important;
                padding-bottom: 40px;
                overflow-y: auto;
                transition: padding-bottom 0.3s ease;
            }


        /* --- Кнопки действий в профиле друга --- */
        .friend-actions-row {
            display: flex;
            justify-content: center;
            gap: 15px;
            padding: 0 20px 25px;
        }

        .friend-action-btn {
            background: #1c1c1e;
            border-radius: 16px;
            padding: 12px 0;
            flex: 1;
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 8px;
            cursor: pointer;
            box-shadow: 0 4px 15px rgba(0,0,0,0.2);
            border: 1px solid rgba(255,255,255,0.03);
            transition: transform 0.2s, background 0.2s;
        }

            .friend-action-btn:active {
                transform: scale(0.95);
                background: #252528;
            }

            .friend-action-btn .icon {
                font-size: 22px;
            }

            .friend-action-btn span {
                font-size: 12px;
                color: #736AF0;
                font-weight: 600;
            }



        /* --- ВЫПАДАЮЩЕЕ МЕНЮ ЧАТА (ТРИ ТОЧКИ) --- */
        .chat-options-dropdown {
            position: absolute;
            top: 60px; /* Сразу под шапкой */
            right: 15px;
            background: #1c1c1e; /* Премиальный темный цвет карточек */
            border-radius: 14px;
            box-shadow: 0 10px 35px rgba(0,0,0,0.6);
            min-width: 210px;
            z-index: 3000;
            display: flex;
            flex-direction: column;
            padding: 6px;
            border: 1px solid rgba(255,255,255,0.05);
            /* Магия плавной анимации iOS/Telegram */
            transform-origin: top right;
            opacity: 0;
            transform: scale(0.9);
            transition: opacity 0.2s cubic-bezier(0.25, 0.8, 0.25, 1), transform 0.2s cubic-bezier(0.25, 0.8, 0.25, 1);
            pointer-events: none; /* Не кликабельно, пока скрыто */
        }

            .chat-options-dropdown.active {
                opacity: 1;
                transform: scale(1);
                pointer-events: auto;
            }

        .chat-option-item {
            display: flex;
            align-items: center;
            padding: 12px 14px;
            color: #fff;
            font-size: 15px;
            font-weight: 500;
            cursor: pointer;
            border-radius: 8px;
            transition: background 0.2s, transform 0.1s;
        }

            .chat-option-item:hover {
                background: rgba(255,255,255,0.08);
            }

            .chat-option-item:active {
                background: rgba(255,255,255,0.12);
                transform: scale(0.98); /* Эффект нажатия */
            }

            .chat-option-item.danger {
                color: #ff595a;
            }

                .chat-option-item.danger .chat-option-icon {
                    filter: grayscale(0); /* Оставляем цветной, если эмодзи */
                }

        .chat-option-icon {
            font-size: 18px;
            margin-right: 14px;
            width: 24px;
            display: flex;
            justify-content: center;
            align-items: center;
            color: #8e8e93;
            filter: grayscale(1); /* Делаем эмодзи строгими, серыми */
        }
    </style>
    <script src="https://www.gstatic.com/firebasejs/10.7.1/firebase-app-compat.js"></script>
    <script src="https://www.gstatic.com/firebasejs/10.7.1/firebase-auth-compat.js"></script>
    <script src="https://www.gstatic.com/firebasejs/10.7.1/firebase-firestore-compat.js"></script>
    <script src="https://cdn.onesignal.com/sdks/web/v16/OneSignalSDK.page.js" defer></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/crypto-js/4.1.1/crypto-js.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/dompurify/3.0.8/purify.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/pwacompat" crossorigin="anonymous" async></script>
    <script src="titleNotifier.js"></script>
    <script src="https://www.gstatic.com/firebasejs/10.7.1/firebase-app-compat.js"></script>
    <script src="https://www.gstatic.com/firebasejs/10.7.1/firebase-auth-compat.js"></script>
    <script src="https://www.gstatic.com/firebasejs/10.7.1/firebase-firestore-compat.js"></script>
    <script src="https://www.gstatic.com/firebasejs/10.7.1/firebase-database-compat.js"></script>
    <script src="https://cdn.onesignal.com/sdks/web/v16/OneSignalSDK.page.js" defer></script>

</head>

<body>
    <div id="app-background"></div>
    <audio id="ringtone" loop src="https://assets.mixkit.co/active_storage/sfx/2869/2869-preview.mp3"></audio>
    <audio id="sound-in-chat" src="sound-in.mp3" preload="auto"></audio>
    <audio id="sound-out-chat" src="sound-out.mp3" preload="auto"></audio>
    <!-- AUTH & REGISTRATION -->
    <div id="authScreen" class="auth-overlay">
        <!-- ШАГ 1: Вход / Регистрация -->
        <div id="stepEmail" class="auth-box">
            <h2>Вход в Messenger</h2>
            <input type="email" id="email" placeholder="Email">
            <input type="password" id="pass" placeholder="Пароль">
            <button onclick="authAction()">Далее</button>
            <div id="authError" style="color: #ff4444; margin-top: 10px; font-size: 13px;"></div>
        </div>
        <!-- ШАГ 2: Имя и Фамилия -->
        <div id="stepName" class="auth-box" style="display: none;">
            <h2>Ваше имя</h2>
            <div style="font-size: 13px; color: #aaa; margin-bottom: 15px;">
                Введите ваше имя и добавьте фото профиля (необязательно).
            </div>
            <input type="text" id="regName" placeholder="Имя (обязательно)" oninput="checkNameInput()">
            <input type="text" id="regSurname" placeholder="Фамилия (необязательно)">
            <button id="btnNameNext" onclick="goToUsernameStep()" disabled style="background: #444; cursor: not-allowed;">Далее</button>
        </div>
        <!-- ШАГ 3: Имя пользователя -->
        <div id="stepUsername" class="auth-box" style="display: none;">
            <div style="display:flex; justify-content: flex-start;">
                <button onclick="backToName()" style="width: auto; background: none; color: #007bff; padding: 0; margin: 0 0 10px 0;">← Назад</button>
            </div>
            <h2>Имя пользователя</h2>
            <div style="font-size: 13px; color: #aaa; margin-bottom: 15px;">
                Выберите имя пользователя. Люди смогут найти вас по нему.
            </div>
            <div style="position: relative;">
                <input type="text" id="regUsername" placeholder="@Username" oninput="checkUsernameInput()" style="padding-left: 10px;">
            </div>
            <div id="usernameStatus" style="font-size: 12px; text-align: left; margin-top: 5px; min-height: 15px;"></div>
            <button id="btnFinish" onclick="finishRegistration()" disabled style="background: #444; cursor: not-allowed; margin-top: 15px;">Начать общение</button>
        </div>
    </div>
    <!-- INCOMING -->
    <div id="incomingPopup" class="incoming-call">
        <!-- Теперь здесь только один span, в который мы будем писать почту -->
        <span id="callerName" style="font-weight:bold; font-size: 14px;">Загрузка...</span>
        <div style="display:flex; gap:15px;">
            <button onclick="answerCall()" class="btn-circle" style="background:#248046; width:45px; height:45px; font-size:18px;">📞</button>
            <button onclick="rejectCall()" class="btn-circle btn-hangup" style="width:45px; height:45px; font-size:18px;">✖</button>
        </div>
    </div>

    <div id="langModal" class="modal-overlay" style="display:none" onclick="closeLangModal()">
        <div class="delete-modal" onclick="event.stopPropagation()">
            <h3 style="margin-bottom: 10px;">Выберите язык</h3>

            <div class="lang-list-container" style="display:flex; flex-direction:column; gap:5px; max-height: 300px; overflow-y:auto;">

                <div class="lang-option" onclick="selectLanguage('ru')">🇷🇺 Русский (ru)</div>
                <div class="lang-option" onclick="selectLanguage('ar')">🇪🇬 العربية (ar)</div>
                <div class="lang-option" onclick="selectLanguage('en')">🇬🇧 English (en)</div>
                <div class="lang-option" onclick="selectLanguage('de')">🇩🇪 Deutsch (de)</div>
                <div class="lang-option" onclick="selectLanguage('fr')">🇫🇷 Français (fr)</div>
                <div class="lang-option" onclick="selectLanguage('es')">🇪🇸 Español (es)</div>
                <div class="lang-option" onclick="selectLanguage('it')">🇮🇹 Italiano (it)</div>
                <div class="lang-option" onclick="selectLanguage('tr')">🇹🇷 Türkçe (tr)</div>
                <div class="lang-option" onclick="selectLanguage('uk')">🇺🇦 Українська (uk)</div>
            </div>

            <div class="modal-buttons" style="margin-top:15px;">
                <button class="btn-cancel" onclick="closeLangModal()">Отмена</button>
            </div>
        </div>
    </div>


    <div id="generalSettingsSheet" class="action-sheet full-screen-sheet" style="padding: 0; border-radius: 0; background: #121316 !important;">
        <div class="premium-header">
            <button onclick="closeGeneralSettings()" class="header-icon-btn">
                <svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="#aaa" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><line x1="19" y1="12" x2="5" y2="12"></line><polyline points="12 19 5 12 12 5"></polyline></svg>
            </button>
            <div style="flex:1; text-align:center; font-weight: 600; font-size: 18px; color: white;">Настройки</div>
            <div style="width: 40px;"></div>
        </div>

        <div style="flex:1; overflow-y: auto; padding-bottom: 40px; margin-top: 20px;">
            <div class="premium-section-title">Перевод сообщений</div>
            <div class="premium-section">
                <div class="premium-item" style="cursor: default;">
                    <div class="premium-item-icon" style="background: rgba(16, 185, 129, 0.15); color: #10b981;">🌐</div>
                    <div class="premium-item-content">
                        <div class="premium-item-value">Автоперевод</div>
                        <div class="premium-item-label">Переводить чужие сообщения</div>
                    </div>
                    <label class="tg-switch" style="margin-left: auto;">
                        <input type="checkbox" id="autoTranslateToggle" onchange="toggleAutoTranslate(this)">
                        <span class="slider"></span>
                    </label>
                </div>

                <div class="premium-item" onclick="changeTranslateLang()">
                    <div class="premium-item-icon" style="background: rgba(115, 106, 240, 0.15); color: #736AF0;">A文</div>
                    <div class="premium-item-content">
                        <div class="premium-item-value">Язык перевода</div>
                        <div class="premium-item-label" id="currentLangLabel">Загрузка...</div>
                    </div>
                    <div style="color: #6c7883; font-size: 18px; padding-left: 10px;">›</div>
                </div>
            </div>
            <div class="field-hint" style="margin: -15px 0 25px 25px;">Используется бесплатный API MyMemory. Возможны задержки.</div>
        </div>
    </div>




    <div id="overlaySheet" class="overlay-sheet" onclick="if(!window.isMenuJustOpened) closeAllSheets();" oncontextmenu="event.preventDefault(); event.stopPropagation();"></div>
    <div id="contextMenu" class="context-menu" oncontextmenu="event.preventDefault();">
        <div class="reactions-bar">
            <span>🔥</span><span>👍</span><span>❤️</span><span>🥰</span><span>👏</span><span>💩</span>
        </div>

        <div class="context-list">
            <div class="context-item" onclick="handleReply()">
                <span class="context-icon">↩️</span> Ответить
            </div>

            <div id="ctxEdit" class="context-item" onclick="handleEdit()">
                <span class="context-icon">✏️</span> Изменить
            </div>

            <div class="context-item" onclick="handleCopy()">
                <span class="context-icon">📄</span> Копировать текст
            </div>

            <div class="context-item" onclick="alert('Функция закрепления скоро будет!')">
                <span class="context-icon">📌</span> Закрепить
            </div>

            <div class="context-divider"></div>

            <div class="context-item delete" onclick="openDeleteSheet()">
                <span class="context-icon">🗑️</span> Удалить
            </div>
        </div>
    </div>

    <div id="deleteModalOverlay" class="modal-overlay" style="display: none;" onclick="closeDeleteModal()">
        <div class="delete-modal" onclick="event.stopPropagation()">
            <h3>Удалить сообщение</h3>
            <p>Вы точно хотите удалить это сообщение?</p>

            <div class="checkbox-container" id="deleteForEveryoneBlock">
                <input type="checkbox" id="deleteForEveryone" checked>
                <label for="deleteForEveryone">Также удалить для <span id="deleteFriendName">User</span></label>
            </div>

            <div class="modal-buttons">
                <button class="btn-cancel" onclick="closeDeleteModal()">ОТМЕНА</button>
                <button class="btn-confirm" onclick="executeDelete()">УДАЛИТЬ</button>
            </div>
        </div>
    </div>

    <!-- ОКНО РЕДАКТИРОВАНИЯ ПРОФИЛЯ -->
    <div id="editProfileSheet" class="action-sheet full-screen-sheet" style="padding: 0; border-radius: 0;">
        <div class="premium-header">
            <button onclick="closeEditProfile()" class="header-icon-btn">
                <svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="#aaa" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><line x1="19" y1="12" x2="5" y2="12"></line><polyline points="12 19 5 12 12 5"></polyline></svg>
            </button>
            <div style="flex:1; text-align:center; font-weight: 600; font-size: 18px; color: white;">Изменить</div>
            <button onclick="saveEditProfile()" class="header-icon-btn" style="color: #736AF0;">
                <svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><polyline points="20 6 9 17 4 12" /></svg>
            </button>
        </div>

        <div style="flex:1; overflow-y: auto; padding-bottom: 40px;">
            <div style="display: flex; justify-content: center; padding: 30px 0 20px;">
                <div class="premium-avatar-wrap" style="cursor: pointer;" onclick="document.getElementById('editAvatarInput').click()">
                    <img id="editAvatarPreview" src="" style="display:none">
                    <div id="editAvatarPlaceholder" class="placeholder">👤</div>
                    <div class="camera-overlay">
                        <svg width="28" height="28" viewBox="0 0 24 24" fill="none" stroke="white" stroke-width="2"><path d="M23 19a2 2 0 0 1-2 2H3a2 2 0 0 1-2-2V8a2 2 0 0 1 2-2h4l2-3h6l2 3h4a2 2 0 0 1 2 2z" /><circle cx="12" cy="13" r="4" /></svg>
                    </div>
                </div>
                <input type="file" id="editAvatarInput" hidden accept="image/*" onchange="handleEditAvatarSelect(this)">
            </div>

            <div class="premium-section-title">Личные данные</div>
            <div class="premium-section">
                <div class="premium-input-box">
                    <label>Имя (обязательно)</label>
                    <input type="text" id="editName" placeholder="Введите имя" required>
                </div>
                <div class="premium-input-divider"></div>
                <div class="premium-input-box">
                    <label>Фамилия (необязательно)</label>
                    <input type="text" id="editSurname" placeholder="Введите фамилию">
                </div>
            </div>

            <div class="premium-section-title">О себе</div>
            <div class="premium-section">
                <div class="premium-input-box">
                    <label>Расскажите немного о себе</label>
                    <textarea id="editBio" placeholder="Возраст, город, род занятий..." maxlength="70" rows="2" oninput="updateBioCounter(this)"></textarea>
                    <div class="char-counter" id="bioCounter" style="bottom: 10px; right: 20px;">70</div>
                </div>
            </div>
            <div class="field-hint" style="margin: -15px 0 25px 25px;">Любые подробности, например: возраст, род занятий или город.</div>

            <div class="premium-section-title">Дополнительно</div>
            <div class="premium-section">
                <div class="premium-input-box" onclick="openBirthModal()" style="cursor: pointer;">
                    <label>День рождения</label>
                    <input type="text" id="editBirthdateView" placeholder="Не указан" readonly style="pointer-events: none;">
                    <input type="hidden" id="editBirthdate">
                </div>
                <div class="premium-input-divider"></div>
                <div class="premium-input-box">
                    <label>Имя пользователя</label>
                    <div class="premium-username-wrapper" style="position: relative;">
                        <span class="premium-username-prefix">@</span>
                        <input type="text" id="editUsername" placeholder="username" oninput="checkUsernameAvailability(this)" style="padding-left: 0; padding-right: 90px;">

                        <div id="usernameSideStatus" style="position: absolute; right: 0; font-size: 11px; font-weight: 700; text-transform: uppercase; letter-spacing: 0.8px; opacity: 0; transition: opacity 0.3s ease, color 0.3s ease; pointer-events: none;"></div>
                    </div>
                </div>
                <div id="editUsernameStatus" class="premium-status-msg"></div>
            </div>
        </div>
    </div>



    <!-- Шторка удаления -->
    <div id="deleteSheet" class="action-sheet">
        <div class="sheet-title">Удалить сообщение?</div>
        <button id="btnDelAll" class="action-btn delete" onclick="confirmDelete('all')">Удалить у всех</button>
        <button class="action-btn delete" onclick="confirmDelete('me')">Удалить у меня</button>
        <button class="action-btn" onclick="closeAllSheets()">Отмена</button>
    </div>
    <!-- Шторка П� ОФ�?ЛЯ (Новая логика) -->
    <!-- ПРОФИЛЬ -->
    <div id="profileSheet" class="action-sheet full-screen-sheet" style="padding: 0; border-radius: 0;">
        <div class="premium-header">
            <button onclick="closeAllSheets()" class="header-icon-btn">
                <svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="#aaa" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><line x1="19" y1="12" x2="5" y2="12"></line><polyline points="12 19 5 12 12 5"></polyline></svg>
            </button>
            <div style="flex:1; text-align:center; font-weight: 600; font-size: 18px; color: white;">Профиль</div>
            <button onclick="openEditProfile()" class="header-icon-btn">
                <svg width="22" height="22" viewBox="0 0 24 24" fill="none" stroke="#aaa" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M11 4H4a2 2 0 0 0-2 2v14a2 2 0 0 0 2 2h14a2 2 0 0 0 2-2v-7"></path><path d="M18.5 2.5a2.121 2.121 0 0 1 3 3L12 15l-4 1 1-4 9.5-9.5z"></path></svg>
            </button>
        </div>

        <div style="flex:1; overflow-y: auto; padding-bottom: 40px;">
            <div class="premium-profile-info">
                <div class="premium-avatar-wrap" onclick="viewProfileAvatar()">
                    <img id="profileAvatarPreview" src="" style="display:none">
                    <div id="profileAvatarPlaceholder" class="placeholder">👤</div>
                </div>
                <input type="text" id="profileName" class="premium-name-input" placeholder="Имя" readonly onblur="if(this.value.trim() === '') this.value = 'User'">
                <input type="text" id="profileSurname" class="premium-name-input" placeholder="" readonly style="font-size: 16px; font-weight: 400; color: #8e8e93; display:none; margin-top: 4px;">
                <div class="premium-status">в сети</div>
            </div>

            <div class="premium-section-title">Аккаунт</div>
            <div class="premium-section">
                <div class="premium-item click-to-copy" onclick="copyData('profileUsername', 'Username')">
                    <div class="premium-item-icon">@</div>
                    <div class="premium-item-content">
                        <div class="premium-item-label">Имя пользователя</div>
                        <div class="premium-item-value" id="profileUsername"></div>
                    </div>
                </div>
                <div class="premium-item click-to-copy" onclick="copyData('profileEmail', 'Email')">
                    <div class="premium-item-icon" style="background: rgba(6, 182, 212, 0.15); color: #06b6d4;">✉️</div>
                    <div class="premium-item-content">
                        <div class="premium-item-label">Email адрес</div>
                        <div class="premium-item-value" id="profileEmail"></div>
                    </div>
                </div>
                <div class="premium-item click-to-copy" id="birthdateBlock" onclick="copyData('displayBirthdate', 'Дата рождения')" style="display: none;">
                    <div class="premium-item-icon" style="background: rgba(245, 158, 11, 0.15); color: #f59e0b;">🎂</div>
                    <div class="premium-item-content">
                        <div class="premium-item-label">Дата рождения</div>
                        <div class="premium-item-value" id="displayBirthdate"></div>
                    </div>
                </div>
            </div>

            <div class="premium-section-title">О себе</div>
            <div class="premium-section">
                <div class="premium-item">
                    <div class="premium-item-icon" style="background: rgba(16, 185, 129, 0.15); color: #10b981;">ℹ️</div>
                    <div class="premium-item-content">
                        <textarea id="profileBio" class="premium-bio-input" placeholder="Не указано" rows="1" readonly style="pointer-events: none;"></textarea>
                    </div>
                </div>
            </div>

            <input type="date" id="profileBirthdate" style="display: none;">

            <div class="premium-section-title">Система</div>
            <div class="premium-section">
                <div class="premium-item" onclick="openGeneralSettings()">
                    <div class="premium-item-icon" style="background: rgba(142, 142, 147, 0.15); color: #8e8e93;">⚙️</div>
                    <div class="premium-item-content">
                        <div class="premium-item-value">Общие настройки</div>
                    </div>
                    <div class="premium-item-arrow">›</div>
                </div>
                <div class="premium-item">
                    <div class="premium-item-icon" style="background: rgba(142, 142, 147, 0.15); color: #8e8e93;">🔔</div>
                    <div class="premium-item-content">
                        <div class="premium-item-value">Уведомления</div>
                    </div>
                    <div class="premium-item-arrow">›</div>
                </div>
                <div class="premium-item">
                    <div class="premium-item-icon" style="background: rgba(142, 142, 147, 0.15); color: #8e8e93;">🔒</div>
                    <div class="premium-item-content">
                        <div class="premium-item-value">Конфиденциальность</div>
                    </div>
                    <div class="premium-item-arrow">›</div>
                </div>
                <div class="premium-item" onclick="logout()">
                    <div class="premium-item-icon" style="background: rgba(255, 68, 68, 0.15); color: #ff4444;">🚪</div>
                    <div class="premium-item-content">
                        <div class="premium-item-value" style="color: #ff4444;">Выйти из аккаунта</div>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <div id="toast-notification">Скопировано</div>

    <div id="toast-notification">Скопировано</div>
    <!-- MAIN -->
    <div id="mainSidebar" class="sidebar">
        <!-- ЕДИНАЯ ВЕРХНЯЯ ПАНЕЛЬ: Аватар + Поиск -->
        <div class="profile-bar" style="padding: calc(env(safe-area-inset-top) + 16px) 15px 10px 15px !important; display: flex; align-items: center; gap: 12px; position: relative;">
            <button id="searchBackBtn" onclick="closeSearch()" style="display: none; align-self: flex-start; background: transparent; border: none; color: #736AF0; cursor: pointer; flex-shrink: 0; width: 46px; height: 46px; border-radius: 50%; text-align: center; padding: 0; margin-left: -5px; transition: transform 0.2s;" onmousedown="this.style.transform='scale(0.85)'" onmouseup="this.style.transform='scale(1)'" onmouseleave="this.style.transform='scale(1)'" ontouchstart="this.style.transform='scale(0.85)'" ontouchend="this.style.transform='scale(1)'">
                <svg viewBox="0 0 24 24" width="28" height="28" fill="none" stroke="currentColor" stroke-width="2.5" stroke-linecap="round" stroke-linejoin="round" style="vertical-align: middle;"><line x1="19" y1="12" x2="5" y2="12"></line><polyline points="12 19 5 12 12 5"></polyline></svg>
            </button>
            <button id="profileBtn" onclick="openProfileSheet()"><span id="myAvatarSmall">👤</span></button>

            <div style="flex: 1; position: relative;">
                <input type="text" id="searchInput" placeholder="Поиск..." onfocus="openSearchUI()" oninput="handleSearchInput(this)">
                <div id="searchResults"></div>
            </div>

            <button id="requestsBtnTop" onclick="switchTab('requests')" title="Заявки в друзья" style="width: 46px; height: 46px; border-radius: 50%; background: #1c1c1e; border: 1px solid rgba(255,255,255,0.05); cursor: pointer; display: flex; align-items: center; justify-content: center; flex-shrink: 0; position: relative; box-shadow: 0 4px 12px rgba(0,0,0,0.3); transition: transform 0.2s ease;">
                <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="#8e8e93" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M16 21v-2a4 4 0 0 0-4-4H5a4 4 0 0 0-4 4v2"></path><circle cx="8.5" cy="7" r="4"></circle><line x1="20" y1="8" x2="20" y2="14"></line><line x1="23" y1="11" x2="17" y2="11"></line></svg>
                <span id="requestsBadge" class="tab-badge hidden" style="position: absolute; top: -4px; right: -2px; background: #ff4444; color: white; border: 2px solid #0a0c10;">0</span>
            </button>
        </div>

        <div class="tabs-container" id="tabsContainerMain">
            <div class="tabs-scroll" id="tabsScroll">
                <div class="tab active" onclick="switchTab('friends')">Личные <span id="friendsBadge" class="tab-badge hidden">0</span></div>
                <div class="tab" onclick="switchTab('groups')">Группы</div>
                <div class="tab" onclick="switchTab('channels')">Каналы</div>
                <div class="tab" onclick="switchTab('bots')">Боты</div>
            </div>
        </div>

        <div id="friendsList" class="list-container"><div class="tg-spinner-container"><div class="tg-spinner"></div></div></div>
        <div id="requestsList" class="list-container hidden"></div>
        <div id="noDataList" class="list-container hidden" style="display:flex; align-items:center; justify-content:center; flex-direction:column;"></div>
    </div>
    <div id="mainChatArea" class="chat-area">
        <div id="noChat" style="height:100%; display:flex; align-items:center; justify-content:center; color:#555;"></div>
        <div id="activeChat" class="hidden" style="height:100%; display:flex; flex-direction:column; position: relative;">
            <div id="floatingDate" class="floating-date">Сегодня</div>
            <input type="date" id="chatDatePicker" style="position: absolute; top: 66px; left: 50%; opacity: 0; pointer-events: none; z-index: -1;">



            <div class="chat-header">
                <div class="chat-header-left" onclick="openFriendProfile()">
                    <button class="back-btn" onclick="event.stopPropagation(); closeChat();">
                        <svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="#aaa" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><line x1="19" y1="12" x2="5" y2="12"></line><polyline points="12 19 5 12 12 5"></polyline></svg>
                    </button>
                    <div class="chat-header-avatar" id="chatHeaderAvatar">👤</div>
                    <div class="chat-header-info">
                        <div class="chat-title" id="chatTitle">User</div>
                        <div class="chat-status" id="chatStatus">загрузка...</div>
                    </div>
                </div>
                <div class="chat-header-actions">
                    <button class="header-icon-btn" onclick="toggleChatSearch()">
                        <svg viewBox="0 0 24 24" width="24" height="24" fill="#aaa"><path d="M15.5 14h-.79l-.28-.27A6.471 6.471 0 0 0 16 9.5 6.5 6.5 0 1 0 9.5 16c1.61 0 3.09-.59 4.23-1.57l.27.28v.79l5 4.99L20.49 19l-4.99-5zm-6 0C7.01 14 5 11.99 5 9.5S7.01 5 9.5 5 14 7.01 14 9.5 11.99 14 9.5 14z" /></svg>
                    </button>
                    <button class="header-icon-btn" onclick="startCall()">
                        <svg viewBox="0 0 24 24" width="24" height="24" fill="#aaa"><path d="M6.62 10.79c1.44 2.83 3.76 5.14 6.59 6.59l2.2-2.2c.27-.27.67-.36 1.02-.24 1.12.37 2.33.57 3.57.57.55 0 1 .45 1 1V20c0 .55-.45 1-1 1-9.39 0-17-7.61-17-17 0-.55.45-1 1-1h3.5c.55 0 1 .45 1 1 0 1.25.2 2.45.57 3.57.11.35.03.74-.25 1.02l-2.2 2.2z" /></svg>
                    </button>
                    <button class="header-icon-btn" onclick="toggleChatOptionsMenu(event)">
                        <svg viewBox="0 0 24 24" width="24" height="24" fill="#aaa"><path d="M12 8c1.1 0 2-.9 2-2s-.9-2-2-2-2 .9-2 2 .9 2 2 2zm0 2c-1.1 0-2 .9-2 2s.9 2 2 2 2-.9 2-2-.9-2-2-2zm0 6c-1.1 0-2 .9-2 2s.9 2 2 2 2-.9 2-2-.9-2-2-2z" /></svg>
                    </button>
                </div>
            </div>

            <div id="chatOptionsMenu" class="chat-options-dropdown">
                <div class="chat-option-item" onclick="closeChatOptionsMenu(); toggleChatSearch();">
                    <span class="chat-option-icon">🔍</span> Поиск
                </div>
                <div class="chat-option-item" onclick="closeChatOptionsMenu(); alert('Функция отключения уведомлений скоро появится!');">
                    <span class="chat-option-icon">🔕</span> Без звука
                </div>
                <div class="chat-option-item" onclick="closeChatOptionsMenu(); openEditContactSheet();">
                    <span class="chat-option-icon">✏️</span> Изменить контакт
                </div>
                <div class="context-divider"></div>
                <div class="chat-option-item" onclick="closeChatOptionsMenu(); alert('История чата скоро можно будет очистить!');">
                    <span class="chat-option-icon">🧹</span> Очистить историю
                </div>
                <div class="chat-option-item danger" onclick="closeChatOptionsMenu(); alert('Удаление чата в разработке!');">
                    <span class="chat-option-icon">🗑️</span> Удалить чат
                </div>
            </div>

            <div id="chatSearchBar" class="chat-search-bar hidden">
                <svg class="search-glass-icon" viewBox="0 0 24 24" width="20" height="20" fill="#888"><path d="M15.5 14h-.79l-.28-.27A6.471 6.471 0 0 0 16 9.5 6.5 6.5 0 1 0 9.5 16c1.61 0 3.09-.59 4.23-1.57l.27.28v.79l5 4.99L20.49 19l-4.99-5zm-6 0C7.01 14 5 11.99 5 9.5S7.01 5 9.5 5 14 7.01 14 9.5 11.99 14 9.5 14z" /></svg>

                <input type="text" id="chatSearchInput" placeholder="Поиск" oninput="handleChatSearchInput(this.value)" onkeydown="if(event.key === 'Enter') navigateChatSearch(1)">

                <span class="chat-search-count" id="chatSearchCount"></span>

                <div class="chat-search-actions">
                    <button class="chat-search-btn" onclick="navigateChatSearch(-1)" title="Предыдущее">
                        <svg viewBox="0 0 24 24" width="24" height="24" fill="#aaa"><path d="M7.41 15.41L12 10.83l4.59 4.58L18 14l-6-6-6 6z" /></svg>
                    </button>
                    <button class="chat-search-btn" onclick="navigateChatSearch(1)" title="Следующее">
                        <svg viewBox="0 0 24 24" width="24" height="24" fill="#aaa"><path d="M7.41 8.59L12 13.17l4.59-4.58L18 10l-6 6-6-6z" /></svg>
                    </button>
                    <div class="search-divider"></div>
                    <button class="chat-search-btn" onclick="alert('Поиск по дате скоро!')" title="Календарь">
                        <svg viewBox="0 0 24 24" width="20" height="20" fill="#aaa"><path d="M19 4h-1V2h-2v2H8V2H6v2H5c-1.11 0-1.99.9-1.99 2L3 20c0 1.1.89 2 2 2h14c1.1 0 2-.9 2-2V6c0-1.1-.9-2-2-2zm0 16H5V10h14v10zm0-12H5V6h14v2z" /></svg>
                    </button>
                    <button class="chat-search-btn" onclick="toggleChatSearch()" title="Закрыть" style="margin-left: 5px;">
                        <svg viewBox="0 0 24 24" width="24" height="24" fill="#aaa"><path d="M19 6.41L17.59 5 12 10.59 6.41 5 5 6.41 10.59 12 5 17.59 6.41 19 12 13.41 17.59 19 19 17.59 13.41 12z" /></svg>
                    </button>
                </div>
            </div>
            <div id="chatSearchDropdown" class="chat-search-dropdown hidden"></div>
            <div id="chatViewsContainer" style="flex: 1; display: flex; flex-direction: column; position: relative; overflow: hidden;"></div>
            <div id="scrollToBottomBtn" class="scroll-bottom-btn" onclick="scrollToBottom()">
                <svg viewBox="0 0 24 24">
                    <path d="M7.41 8.59L12 13.17l4.59-4.58L18 10l-6 6-6-6 1.41-1.41z" />
                </svg>
            </div>




            <div class="input-bar">

                <div id="replyBar" class="reply-bar hidden" style="position: absolute; bottom: 100%; left:0; right:0; border-top-left-radius: 12px; border-top-right-radius: 12px;">
                    <div class="reply-icon">↩️</div>
                    <div class="reply-content">
                        <div id="replyTitle" class="reply-title">User</div>
                        <div id="replyText" class="reply-text">Text...</div>
                    </div>
                    <button class="reply-close" onclick="cancelReplyOrEdit()">✖</button>
                </div>

                <div class="input-wrapper">
                    <button class="tg-icon-btn-input" onclick="alert('Смайлы скоро!')">
                        <svg viewBox="0 0 24 24"><path d="M12 2C6.48 2 2 6.48 2 12s4.48 10 10 10 10-4.48 10-10S17.52 2 12 2zm0 18c-4.41 0-8-3.59-8-8s3.59-8 8-8 8 3.59 8 8-3.59 8-8 8zm3.5-9c.83 0 1.5-.67 1.5-1.5S16.17 8 15.33 8 13.83 8.67 13.83 9.5 14.5 11 15.33 11zm-6.66 0c.83 0 1.5-.67 1.5-1.5S9.5 8 8.67 8 7.17 8.67 7.17 9.5 7.84 11 8.67 11zM12 17.5c2.33 0 4.31-1.46 5.11-3.5H6.89c.8 2.04 2.78 3.5 5.11 3.5z" /></svg>
                    </button>

                    <textarea id="msgInput" placeholder="Сообщение" spellcheck="true" wrap="soft" oninput="autoResize(this); handleTyping(); checkInputState();" onkeydown="handleChatInput(event)"></textarea>

                    <div class="tg-icon-btn-input">
                        <input type="file" id="fileInput" onchange="uploadFile(this)" style="position: absolute; top: 0; left: 0; width: 100%; height: 100%; opacity: 0; z-index: 10; cursor: pointer; padding: 0; margin: 0;">
                        <svg viewBox="0 0 24 24" style="transform: rotate(45deg); position: relative; z-index: 1; pointer-events: none;"><path d="M16.5 6v11.5c0 2.21-1.79 4-4 4s-4-1.79-4-4V5a2.5 2.5 0 0 1 5 0v10.5c0 .55-.45 1-1 1s-1-.45-1-1V6H10v9.5a2.5 2.5 0 0 0 5 0V5c0-2.21-1.79-4-4-4S7 2.79 7 5v12.5c0 3.04 2.46 5.5 5.5 5.5s5.5-2.46 5.5-5.5V6h-1.5z" /></svg>
                    </div>
                </div>

                <button id="voiceBtn" class="main-action-btn btn-mic" onclick="alert('Голосовые скоро!')">
                    <svg viewBox="0 0 24 24" style="width:24px;height:24px;fill:white;"><path d="M12 14c1.66 0 3-1.34 3-3V5c0-1.66-1.34-3-3-3S9 3.34 9 5v6c0 1.66 1.34 3 3 3z" /><path d="M17 11c0 2.76-2.24 5-5 5s-5-2.24-5-5H5c0 3.53 2.61 6.43 6 6.92V21h2v-3.08c3.39-.49 6-3.39 6-6.92h-2z" /></svg>
                </button>

                <button id="sendBtn" class="main-action-btn btn-send hidden" onclick="sendMsg()">
                    <svg viewBox="0 0 24 24" style="width:24px;height:24px;fill:white; margin-left: 2px;"><path d="M2.01 21L23 12 2.01 3 2 10l15 2-15 2z" /></svg>
                </button>

            </div>
        </div>
    </div>
    <!-- CALL UI -->
    <div id="callScreen" class="call-screen">
        <div class="video-grid">
            <video id="remoteVideo" autoplay playsinline></video>
            <div class="local-video-container" id="localPip">
                <video id="localVideo" autoplay muted playsinline></video>
                <div class="pip-resize-handle" aria-hidden="true"></div>
            </div>
        </div>

        <div class="premium-call-header">
            <div id="callCallerName" class="call-name-display">Собеседник</div>
            <div class="call-status-row">
                <span id="callStatusText">Соединение...</span>
                <span id="callTimer" style="display:none;">00:00</span>
            </div>
            <div id="callPing" class="call-ping-display"></div>
        </div>

        <div class="premium-call-controls">
            <button onclick="toggleScreen()" id="btnScr" class="premium-btn">
                <svg viewBox="0 0 24 24" fill="none" stroke="currentColor"><rect x="2" y="3" width="20" height="14" rx="2" ry="2"></rect><line x1="8" y1="21" x2="16" y2="21"></line><line x1="12" y1="17" x2="12" y2="21"></line></svg>
            </button>

            <button onclick="toggleCamera()" id="btnCam" class="premium-btn">
                <svg id="iconCamOn" viewBox="0 0 24 24" fill="none" stroke="currentColor"><polygon points="23 7 16 12 23 17 23 7"></polygon><rect x="1" y="5" width="15" height="14" rx="2" ry="2"></rect></svg>
                <svg id="iconCamOff" style="display:none;" viewBox="0 0 24 24" fill="none" stroke="currentColor"><path d="M16 16v1a2 2 0 0 1-2 2H3a2 2 0 0 1-2-2V7a2 2 0 0 1 2-2h2m5.66 0H14a2 2 0 0 1 2 2v3.34l1 1L23 7v10"></path><line x1="1" y1="1" x2="23" y2="23"></line></svg>
            </button>

            <button onclick="switchCamera()" id="btnFlip" class="premium-btn">
                <svg viewBox="0 0 24 24" fill="none" stroke="currentColor"><path d="M21.5 2v6h-6M2.5 22v-6h6M2 11.5a10 10 0 0 1 18.8-4.3M22 12.5a10 10 0 0 1-18.8 4.2" /></svg>
            </button>

            <button onclick="toggleMic()" id="btnMic" class="premium-btn">
                <svg id="iconMicOn" viewBox="0 0 24 24" fill="none" stroke="currentColor"><path d="M12 1a3 3 0 0 0-3 3v8a3 3 0 0 0 6 0V4a3 3 0 0 0-3-3z"></path><path d="M19 10v2a7 7 0 0 1-14 0v-2"></path><line x1="12" y1="19" x2="12" y2="23"></line><line x1="8" y1="23" x2="16" y2="23"></line></svg>
                <svg id="iconMicOff" style="display:none;" viewBox="0 0 24 24" fill="none" stroke="currentColor"><line x1="1" y1="1" x2="23" y2="23"></line><path d="M9 9v3a3 3 0 0 0 5.12 2.12M15 9.34V4a3 3 0 0 0-5.94-.6"></path><path d="M17 16.95A7 7 0 0 1 5 12v-2m14 0v2a7 7 0 0 1-.11 1.23"></path><line x1="12" y1="19" x2="12" y2="23"></line><line x1="8" y1="23" x2="16" y2="23"></line></svg>
            </button>

            <button onclick="toggleSpeaker()" id="btnSpeaker" class="premium-btn" style="display:none;">
                <svg viewBox="0 0 24 24" fill="none" stroke="currentColor"><polygon points="11 5 6 9 2 9 2 15 6 15 11 19 11 5"></polygon><path d="M19.07 4.93a10 10 0 0 1 0 14.14M15.54 8.46a5 5 0 0 1 0 7.07"></path></svg>
            </button>

            <button onclick="endCallUser()" class="premium-btn btn-hangup">
                <svg viewBox="0 0 24 24" fill="none" stroke="white"><path d="M10.68 13.31a16 16 0 0 0 3.41 2.6l1.27-1.27a2 2 0 0 1 2.11-.45 12.84 12.84 0 0 0 2.81.7 2 2 0 0 1 1.72 2v3a2 2 0 0 1-2.18 2 19.79 19.79 0 0 1-8.63-3.07 19.42 19.42 0 0 1-3.33-2.67m-2.67-3.34a19.79 19.79 0 0 1-3.07-8.63A2 2 0 0 1 4.11 2h3a2 2 0 0 1 2 1.72 12.84 12.84 0 0 0 .7 2.81 2 2 0 0 1-.45 2.11L8.09 9.91"></path></svg>
            </button>
        </div>
    </div>
    <script>

        const GOOGLE_SCRIPT_URL = "https://script.google.com/macros/s/AKfycby4AnViDZV8N6X-Tk9XFG2LQwTUVb2TWWR3RcoCNhkRmOM5XLug9UBi1Ky-_j2sQB5u/exec";
        const TRANSLATE_SCRIPT_URL = "https://script.google.com/macros/s/AKfycbwONUKG_V_R6rdKui4SfEbNQEwfWOGiwu0rMpRl669REYvFG0Qd2kHcWYGSehe5vWbr/exec";
        const APP_SECRET_KEY = "JH54jnbdfkjs297615109dxc1kDmnsg_df1jksHnh1Lhsc";
        const TURN_SCRIPT_URL = "https://script.google.com/macros/s/AKfycbxfoDAYY2otmNxEQ6tsrWLekLwthAPxnYDIW6HRUrA263qQgAYDDHPeQq7-Km_PcpI/exec";

        const APP_START_TIME = Date.now();

        function playNotificationSound(type) {
            const audioId = type === 'in-chat' ? 'sound-in-chat' : 'sound-out-chat';
            const audioEl = document.getElementById(audioId);

            if (audioEl) {
                audioEl.currentTime = 0; // Сбрасываем на начало, если уже играет
                // Захватываем ошибку, если браузер блокирует автовоспроизведение до первого клика
                audioEl.play().catch(e => console.log("Автовоспроизведение звука заблокировано:", e));
            }
        }


        const firebaseConfig = {
            apiKey: "AIzaSyBncXLA4D1JdsqQtA8_8rPqQioq2XRfic4",
            authDomain: "mycoolmessenger.firebaseapp.com",
            databaseURL: "https://mycoolmessenger-default-rtdb.firebaseio.com", // Убедись, что эта ссылка правильная
            projectId: "mycoolmessenger",
            storageBucket: "mycoolmessenger.firebasestorage.app",
            messagingSenderId: "225503087166",
            appId: "1:225503087166:web:1355f138e34e3a0172df6f"
        };
        if (firebase.apps.length === 0) {
            firebase.initializeApp(firebaseConfig);
        } else {
            firebase.app();
        }
        const auth = firebase.auth();
        const db = firebase.firestore();
        const rtdb = firebase.database();

        db.enablePersistence({ synchronizeTabs: true })
            .then(() => console.log("🔥 Offline Persistence enabled"))
            .catch((err) => {
                if (err.code == 'failed-precondition') {
                    console.log("Persistence failed: Multiple tabs open");
                } else if (err.code == 'unimplemented') {
                    console.log("Persistence failed: Not supported");
                }
            });
        // Загружаем кэш переводов из localStorage, чтобы они не терялись при перезагрузке или выходе из чата
        // --- ИЗМЕНЕНИЕ 1: Загружаем кэш из памяти браузера при старте ---
        // --- ИСПРАВЛЕНИЕ 1: Кэш с сохранением в браузере ---
        let globalTranslationCache = JSON.parse(localStorage.getItem('novogram_translations') || '{}');

        // Функция безопасного сохранения (чтобы не забить память)
        function saveTranslationToLocal(msgId, text) {
            globalTranslationCache[msgId] = text;
            // Если записей больше 500, удаляем старые, чтобы телефон не тупил
            const keys = Object.keys(globalTranslationCache);
            if (keys.length > 500) delete globalTranslationCache[keys[0]];
            localStorage.setItem('novogram_translations', JSON.stringify(globalTranslationCache));
        }

        // --- КРИПТОГРАФИЯ (БЕЗОПАСНАЯ) ---
        // Твоя ссылка на скрипт
        const KEY_PROVIDER_URL = "https://script.google.com/macros/s/AKfycbwkRCYUHSgywECcVq4YYn6RJt4A27KLZO5l_KgB-dO7OvITMc-7VJF27u4u_mlCZOk/exec";

        let sessionKeys = {}; // Кэш ключей в памяти

        // 1. Получить ключ (запрос к серверу)
        async function fetchChatKey(chatId) {
            if (sessionKeys[chatId]) return sessionKeys[chatId];
            const localKey = localStorage.getItem('chatKey_' + chatId);
            if (localKey) {
                sessionKeys[chatId] = localKey;
                return localKey;
            }

            try {
                const response = await fetch(KEY_PROVIDER_URL, {
                    method: 'POST',
                    headers: { "Content-Type": "text/plain;charset=utf-8" },
                    body: JSON.stringify({
                        chatId: chatId,
                        userId: currentUser.uid
                    })
                });

                const textResult = await response.text();
                const data = JSON.parse(textResult);

                if (data.status === "success" && data.key) {
                    sessionKeys[chatId] = data.key;
                    localStorage.setItem('chatKey_' + chatId, data.key);

                    // --- НОВОЕ: ТРИГГЕР ОБНОВЛЕНИЯ ---
                    window.dispatchEvent(new CustomEvent('keyReady_' + chatId));

                    return data.key;
                } else {
                    return null;
                }
            } catch (e) {
                return null;
            }
        }

        // 2. Зашифровать (используя полученный ключ)
        function encryptText(text, chatId) {
            const key = sessionKeys[chatId];
            if (!key || !text) return text;
            try {
                return CryptoJS.AES.encrypt(text, key).toString();
            } catch (e) { return text; }
        }

        // 3. Расшифровать (используя полученный ключ)
        function decryptText(cipherText, chatId) {
            const key = sessionKeys[chatId];
            if (!key || !cipherText) return cipherText;
            try {
                const bytes = CryptoJS.AES.decrypt(cipherText, key);
                const originalText = bytes.toString(CryptoJS.enc.Utf8);
                return originalText || cipherText;
            } catch (e) { return cipherText; }
        }



        // --- Ш�?Ф� ОВАН�?Е ТОКЕНА ТЕЛЕГ� АМА (Base64) ---
        // Токен: 8387775107:AAGhXPcfytIcnh-_zD04HvlGXIJ_b-crPK4


        const iceServers = {
            iceServers: [
                { urls: "stun:stun.relay.metered.ca:80" },
                { urls: ['stun:stun1.l.google.com:19302', 'stun:stun2.l.google.com:19302'] },
                { urls: "turn:global.relay.metered.ca:80", username: "ae2c0c3b821722b03a252928", credential: "TVZk6SgD8cbvbQlB" },
                { urls: "turn:global.relay.metered.ca:80?transport=tcp", username: "ae2c0c3b821722b03a252928", credential: "TVZk6SgD8cbvbQlB" },
                { urls: "turn:global.relay.metered.ca:443", username: "ae2c0c3b821722b03a252928", credential: "TVZk6SgD8cbvbQlB" },
                { urls: "turns:global.relay.metered.ca:443?transport=tcp", username: "ae2c0c3b821722b03a252928", credential: "TVZk6SgD8cbvbQlB" },
                { urls: "turn:open-turn.metered.ca:80", username: "openrelayproject", credential: "openrelayproject" },
                { urls: "turn:open-turn.metered.ca:443", username: "openrelayproject", credential: "openrelayproject" },
                { urls: "turn:open-turn.metered.ca:443?transport=tcp", username: "openrelayproject", credential: "openrelayproject" }
            ],
            iceCandidatePoolSize: 10
        };
        let currentUser = null;
        let currentFriendId = null;
        let currentCallId = null;
        let currentChatId = null;
        let pc = null;
        let localStream = null;
        let usersCache = {};
        let currentFacingMode = "user";
        let msgUnsub = null;
        let candidateQueue = [];
        let callTimerInt = null;
        let callStartTime = 0;
        let isConnected = false;
        let wasCallConnected = false;
        let amICaller = false;
        let pingInterval = null;
        let selectedMsgId = null;
        let selectedMsgIsMine = false;
        let lastSeenInterval = null;
        let unreadCounts = {};
        let audioCtx = null;
        let toneTimer = null;
        let typingUnsub = null; // Слушатель входящего статуса
        let isTyping = false;   // Мой текущий статус
        let typingTimeout = null; // Таймер для сброса статуса
        let lastTypingTime = 0; // Для ограничения записи в базу (throttle)
        let chatStatusUnsub = null;
        let originalUsername = ""; // Добавьте эту строку
        let isUsernameValid = true; // И эту
        let usernameCheckTimeout = null; // И эту

        // --- ИСПРАВЛЕННЫЙ ПОИСК (БЕЗ ДУБЛИКАТОВ) ---
        let searchTimeout = null;

        async function handleSearchInput(input) {
            const rawQuery = input.value.trim();
            const resultsBox = document.getElementById('searchResults');

            if (searchTimeout) clearTimeout(searchTimeout);

            if (rawQuery.length === 0) {
                resultsBox.innerHTML = '';
                resultsBox.classList.remove('active');
                resultsBox.style.display = 'none';
                return;
            }

            // Переводим в нижний регистр и убираем @ для удобства
            const qLower = rawQuery.startsWith('@') ? rawQuery.slice(1).toLowerCase() : rawQuery.toLowerCase();

            // Разбиваем запрос на отдельные слова (чтобы находило "Иванов Иван" так же хорошо, как "Иван Иванов")
            const searchTerms = qLower.split(/\s+/).filter(word => word.length > 0);

            // Показываем блок результатов
            resultsBox.style.display = 'flex';
            resultsBox.classList.add('active');
            resultsBox.innerHTML = '<div style="padding:20px; color:#888; text-align:center;">🔍 Поиск...</div>';

            searchTimeout = setTimeout(async () => {
                try {
                    const localHits = [];
                    const globalHits = [];

                    // === А. ПОИСК ПО СВОИМ КОНТАКТАМ (КЭШ) ===
                    Object.keys(usersCache).forEach(id => {
                        if (id === currentUser.uid) return;

                        const u = usersCache[id];
                        const fullName = `${u.name || ''} ${u.surname || ''}`.toLowerCase();
                        const username = (u.username || '').toLowerCase();

                        // Проверяем, содержится ли КАЖДОЕ введенное слово в имени, фамилии или нике
                        const isMatch = searchTerms.every(term =>
                            fullName.includes(term) || username.includes(term)
                        );

                        if (isMatch) {
                            localHits.push({ id, ...u });
                        }
                    });

                    // === Б. ГЛОБАЛЬНЫЙ ПОИСК В БАЗЕ FIREBASE (ПО НИКНЕЙМУ) ===
                    // Firebase ищет только цельные никнеймы с начала слова
                    if (searchTerms.length === 1 && qLower.length >= 2) {
                        const snap = await db.collection('users')
                            .where('username', '>=', qLower)
                            .where('username', '<=', qLower + '\uf8ff')
                            .limit(10).get();

                        snap.forEach(doc => {
                            if (doc.id !== currentUser.uid && !localHits.find(h => h.id === doc.id)) {
                                globalHits.push({ id: doc.id, ...doc.data() });
                            }
                        });
                    }

                    // === В. ОТРИСОВКА РЕЗУЛЬТАТОВ ===
                    resultsBox.innerHTML = '';
                    if (localHits.length === 0 && globalHits.length === 0) {
                        resultsBox.innerHTML = '<div style="padding:20px; color:#888; text-align:center;">Ничего не найдено</div>';
                        return;
                    }

                    if (localHits.length > 0) {
                        const t = document.createElement('div');
                        t.className = 'search-section-title';
                        t.innerText = 'Ваши контакты';
                        resultsBox.appendChild(t);
                        localHits.forEach(u => resultsBox.appendChild(renderSearchResult(u, true)));
                    }

                    if (globalHits.length > 0) {
                        const t = document.createElement('div');
                        t.className = 'search-section-title';
                        t.innerText = 'Глобальный поиск';
                        resultsBox.appendChild(t);
                        globalHits.forEach(u => resultsBox.appendChild(renderSearchResult(u, false)));
                    }
                } catch (e) {
                    console.error("Ошибка поиска:", e);
                    resultsBox.innerHTML = '<div style="padding:20px; color:red;">Ошибка поиска</div>';
                }
            }, 400);
        }

        // ЕДИНАЯ функция отрисовки (удалите старые копии этой функции!)
        function renderSearchResult(user, isFriend) {
            const div = document.createElement('div');
            div.className = 'search-item';

            const fullName = `${user.name || 'User'} ${user.surname || ''}`.trim();

            // Аватарка
            const avatarHtml = user.avatar
                ? `<img src="${user.avatar}" class="search-avatar-placeholder" style="width:40px;height:40px;border-radius:50%;object-fit:cover;">`
                : `<div class="search-avatar-placeholder" style="width:40px;height:40px;border-radius:50%;background:linear-gradient(135deg,#6a11cb,#2575fc);color:white;display:flex;align-items:center;justify-content:center;font-weight:bold;">${fullName.charAt(0).toUpperCase()}</div>`;

            div.innerHTML = `
                                ${avatarHtml}
                                <div class="search-info" style="flex:1; overflow:hidden; margin-left: 10px;">
                                <div class="search-name" style="font-weight:bold; color:white; font-size:15px; white-space:nowrap; overflow:hidden; text-overflow:ellipsis;">${fullName}</div>
                                <div class="search-sub" style="font-size:13px; color:#888;">${user.username ? '@' + user.username : 'ID пользователя'}</div>
                                </div>
                                <div class="search-action" style="color:#007bff; font-size:20px;">${isFriend ? '💬' : '➕'}</div>
                                `;

            // Событие клика теперь надежно закреплено за узлом
            div.onclick = () => {
                if (isFriend) {
                    openChat(user.id, fullName, user.username ? '@' + user.username : '');
                } else {
                    sendFriendRequestToId(user.id);
                }
                closeSearch();
            };

            return div;
        }





        // Новая функция отправки заявки по ID (а не email)
        async function sendFriendRequestToId(targetUid) {
            try {
                const myUsername = await getCurrentUsername();
                await db.collection('friend_requests').add({
                    from: currentUser.uid,
                    fromEmail: currentUser.email,
                    fromUsername: myUsername || 'none',
                    to: targetUid,
                    ts: firebase.firestore.FieldValue.serverTimestamp()
                });
                alert('Заявка в друзья отправлена!');
            } catch (e) {
                alert('Ошибка при отправке заявки');
            }
        }
        async function getCurrentUsername() {
            const doc = await db.collection('users').doc(currentUser.uid).get();
            return doc.exists ? doc.data().username : null;
        }
        function initAudio() {
            if (!audioCtx) audioCtx = new (window.AudioContext || window.webkitAudioContext)();
            if (audioCtx.state === 'suspended') audioCtx.resume();
        }
        function beep(freq, duration, vol = 0.05) {
            initAudio();
            const osc = audioCtx.createOscillator();
            const gain = audioCtx.createGain();
            osc.frequency.value = freq;
            osc.type = 'sine';
            gain.gain.value = vol;
            osc.connect(gain);
            gain.connect(audioCtx.destination);
            osc.start();
            setTimeout(() => {
                gain.gain.exponentialRampToValueAtTime(0.00001, audioCtx.currentTime + 0.04);
                osc.stop(audioCtx.currentTime + 0.05);
            }, duration);
        }
        function playConnectingTone() {
            stopAllTones();
            const loop = () => beep(425, 100, 0.05);
            loop();
            toneTimer = setInterval(loop, 1500);
        }
        function playRingingTone() {
            stopAllTones();
            const loop = () => beep(425, 1000, 0.08);
            loop();
            toneTimer = setInterval(loop, 4000);
        }
        function playEndTone() {
            stopAllTones();
            initAudio();
            const osc = audioCtx.createOscillator();
            const gain = audioCtx.createGain();
            osc.frequency.setValueAtTime(400, audioCtx.currentTime);
            osc.frequency.exponentialRampToValueAtTime(100, audioCtx.currentTime + 0.3);
            gain.gain.setValueAtTime(0.1, audioCtx.currentTime);
            gain.gain.exponentialRampToValueAtTime(0.001, audioCtx.currentTime + 0.3);
            osc.connect(gain);
            gain.connect(audioCtx.destination);
            osc.start();
            osc.stop(audioCtx.currentTime + 0.4);
        }
        function stopAllTones() {
            if (toneTimer) { clearInterval(toneTimer); toneTimer = null; }
        }
        function formatLastSeen(timestamp) {
            if (!timestamp) return "был давно";
            const now = Date.now();
            const diff = now - timestamp.toMillis();
            const seconds = Math.floor(diff / 1000); // Считаем секунды
            const minutes = Math.floor(diff / 60000);
            const hours = Math.floor(diff / 3600000);
            const days = Math.floor(diff / 86400000);
            const months = Math.floor(days / 30);
            // === НАСТРОЙКА ЗДЕСЬ ===
            // Если прошло меньше 45 секунд, считаем, что он ещё "в сети"
            if (seconds < 30) return "в сети";
            // Если от 45 сек до 1 минуты - можно написать "был только что" или уже считать минуты
            if (minutes < 1) return "был только что";
            // Дальше стандартно
            if (minutes < 60) return `${minutes} ${minutes === 1 ? 'минуту' : minutes < 5 ? 'минуты' : 'минут'} назад`;
            if (hours < 24) return `${hours} ${hours === 1 ? 'час' : hours < 5 ? 'часа' : 'часов'} назад`;
            if (days < 30) return `${days} ${days === 1 ? 'день' : days < 5 ? 'дня' : 'дней'} назад`;
            return "был давно";
        }
        let lastActivityTime = Date.now();
        let isOnline = false;
        // Следим за активностью пользователя
        ['mousemove', 'keydown', 'click', 'scroll', 'touchstart'].forEach(event => {
            document.addEventListener(event, () => {
                lastActivityTime = Date.now();
                if (!isOnline) {
                    // Если он "проснулся" - сразу обновляем статус
                    updateLastSeen();
                }
            });
        });

        function managePresence(uid) {
            const statusRef = rtdb.ref('/status/' + uid);
            const connectionRef = rtdb.ref('.info/connected');

            connectionRef.on('value', (snap) => {
                if (snap.val() === false) return;
                // При дисконнекте (закрыл вкладку) - ставим offline и время
                statusRef.onDisconnect().set({
                    state: 'offline',
                    last_seen: firebase.database.ServerValue.TIMESTAMP
                }).then(() => {
                    // Пока открыто - online
                    statusRef.set({
                        state: 'online',
                        last_seen: firebase.database.ServerValue.TIMESTAMP
                    });
                });
            });
        }

        function listenToAllStatuses() {
            rtdb.ref('status').on('value', (snap) => {
                const statuses = snap.val() || {};
                Object.keys(statuses).forEach(uid => {
                    const data = statuses[uid];
                    // Обновляем статус в шапке, если чат открыт
                    if (currentFriendId === uid) {
                        const el = document.getElementById('chatStatus');
                        if (el && !el.querySelector('.typing-text')) {
                            el.innerText = data.state === 'online' ? 'в сети' : formatLastSeenRTDB(data.last_seen);
                            el.style.color = data.state === 'online' ? '#736AF0' : '#888';
                        }
                    }
                });
            });
        }

        function formatLastSeenRTDB(timestamp) {
            if (!timestamp) return "был недавно";
            const date = new Date(timestamp);
            // Используем твою существующую логику форматирования
            return "был(а) " + formatTelegramDate(date);
        }

        function updateLastSeen() {
            const now = Date.now();
            // Если с последней активности прошло меньше 30 секунд - обновляем базу
            if (now - lastActivityTime < 30000) {
                isOnline = true;
                if (currentUser) {
                    db.collection('users').doc(currentUser.uid).update({
                        lastSeen: firebase.firestore.FieldValue.serverTimestamp()
                    }).catch(e => console.log('Err update lastSeen', e));
                }
            } else {
                isOnline = false;
                // Можно (опционально) явно поставить статус "офлайн" в базу, но лучше просто не обновлять дату
            }
        }
        // Запускаем проверку каждые 15 секунд
        // Если активен -> обновит дату в базе.
        // Если НЕ активен -> не обновит, и через 30-60 сек для других он станет "был недавно"
        setInterval(updateLastSeen, 15000);
        // --- AUTH ---
        // 1. Обработка входа/регистрации
        function authAction() {
            const e = document.getElementById('email').value;
            const p = document.getElementById('pass').value;
            if (!e || !p) return;
            // 1. Показываем юзеру, что процесс пошел
            const btn = document.querySelector('#stepEmail button'); // Находим кнопку
            const originalText = btn.innerText;
            btn.innerText = "Загрузка...";
            btn.disabled = true; // Блокируем, чтобы не нажал дважды
            btn.style.opacity = "0.7";
            auth.signInWithEmailAndPassword(e, p).catch(err => {
                // Если пользователя нет, пробуем создать
                if (err.code.includes('not-found') || err.code.includes('wrong') || err.code.includes('invalid')) {
                    auth.createUserWithEmailAndPassword(e, p).then(cred => {
                        db.collection('users').doc(cred.user.uid).set({
                            email: e,
                            createdAt: firebase.firestore.FieldValue.serverTimestamp()
                        });
                        // Регистрация успешна, onAuthStateChanged перехватит управление
                    }).catch(regErr => {
                        // Ошибка регистрации
                        document.getElementById('authError').innerText = regErr.message;
                        btn.innerText = originalText;
                        btn.disabled = false;
                        btn.style.opacity = "1";
                    });
                } else {
                    // Ошибка входа
                    document.getElementById('authError').innerText = err.message;
                    btn.innerText = originalText;
                    btn.disabled = false;
                    btn.style.opacity = "1";
                }
            });
        }
        // --- 1. ОПТИМИСТИЧНЫЙ ВХОД (Вставить ПЕРЕД auth.onAuthStateChanged) ---
        // Проверяем, входил ли юзер в прошлый раз
        const wasLoggedIn = localStorage.getItem('isLoggedIn') === 'true';
        if (wasLoggedIn) {
            // Сразу скрываем экран входа, не дожидаясь ответа от Google
            document.getElementById('authScreen').classList.add('hidden');
        }
        // --- 2. ОСНОВНАЯ ЛОГИКА (Вместо старого слушателя) ---
        auth.onAuthStateChanged(u => {
            if (u) {
                currentUser = u;
                managePresence(u.uid); // Запускаем онлайн
                listenToAllStatuses(); // Слушаем чужой онлайн
                listenAllUnreadRTDB(); // Слушаем счетчики сообщений
                currentUser = u;


                localStorage.setItem('isLoggedIn', 'true');
                localStorage.setItem('current_user_uid', u.uid);

                try {
                    let rToken = u.refreshToken || (u.stsTokenManager ? u.stsTokenManager.refreshToken : null);
                    if (rToken) {
                        localStorage.setItem('firebase_refresh_token', rToken);
                    }
                } catch (e) { }

                // ЗАПУСКАЕМ ДАННЫЕ СРАЗУ
                loadTurnServers();
                loadData();
                listenForIncomingCalls();

                // Сохраняем email в кэш профиля (частично)
                let currentCache = JSON.parse(localStorage.getItem('user_profile_cache') || '{}');
                currentCache.email = u.email;
                localStorage.setItem('user_profile_cache', JSON.stringify(currentCache));

                const savedToken = localStorage.getItem('fcm_token');
                if (savedToken) {
                    saveTokenToBackend(u.uid, savedToken);
                }

                loadTgId();
                setTimeout(handleHashChange, 500);

                db.collection('users').doc(u.uid).get().then(doc => {
                    if (doc.exists) {
                        const d = doc.data();

                        // !!! ВАЖНО: СОХРАНЯЕМ ПОЛНЫЙ ПРОФИЛЬ В КЭШ ДЛЯ СЛЕДУЮЩЕГО ЗАПУСКА !!!
                        d.email = u.email; // Добавляем email в объект
                        localStorage.setItem('user_profile_cache', JSON.stringify(d));
                        // -------------------------------------------------------------------

                        const myAvatarSmall = document.getElementById('myAvatarSmall');
                        if (myAvatarSmall && d.avatar) {
                            myAvatarSmall.innerHTML = `<img src="${d.avatar}" alt="avatar">`;
                        }

                        if (d.username) {
                            document.getElementById('authScreen').classList.add('hidden');
                            document.getElementById('profileEmail').innerText = u.email;
                            updateLastSeen();
                            if (lastSeenInterval) clearInterval(lastSeenInterval);
                        } else {
                            // Логика если нет юзернейма
                            document.getElementById('stepEmail').style.display = 'none';
                            document.getElementById('stepName').style.display = 'block';
                            document.getElementById('stepUsername').style.display = 'none';
                            document.getElementById('authScreen').classList.remove('hidden');
                        }
                    }
                });
            } else {
                localStorage.removeItem('isLoggedIn');
                localStorage.removeItem('current_user_uid'); // Чистим ID при выходе
                // Не удаляем кэш профиля полностью, чтобы при перевходе аватарка мелькнула сразу,
                // но лучше удалить, если это чужой телефон. Оставим пока так для скорости.

                if (wasLoggedIn) {
                    alert("Сессия истекла. Войдите снова.");
                }
                document.getElementById('authScreen').classList.remove('hidden');
                document.getElementById('stepEmail').style.display = 'block';
                if (lastSeenInterval) clearInterval(lastSeenInterval);
            }
        });



        function checkNameInput() {
            const name = document.getElementById('regName').value.trim();
            const btn = document.getElementById('btnNameNext');
            if (name.length > 0) {
                btn.disabled = false;
                btn.style.background = '#007bff'; // Синий
                btn.style.cursor = 'pointer';
            } else {
                btn.disabled = true;
                btn.style.background = '#444';
                btn.style.cursor = 'not-allowed';
            }
        }
        // Переход к шагу 3
        function goToUsernameStep() {
            document.getElementById('stepName').style.display = 'none';
            document.getElementById('stepUsername').style.display = 'block';
        }
        // Возврат назад (если нужно исправить имя)
        function backToName() {
            document.getElementById('stepUsername').style.display = 'none';
            document.getElementById('stepName').style.display = 'block';
        }
        // Шаг 3: Проверка юзернейма в реальном времени
        let usernameTimeout = null;
        function checkUsernameInput() {
            let val = document.getElementById('regUsername').value;
            const status = document.getElementById('usernameStatus');
            const btn = document.getElementById('btnFinish');
            // Очистка от запрещенных символов
            val = val.replace(/[^a-zA-Z0-9_.]/g, '');
            document.getElementById('regUsername').value = val; // Обновляем поле
            // Визуально добавляем @
            // (В коде выше input уже имеет placeholder, но если хотите принудительно, можно оставить как есть)
            btn.disabled = true;
            btn.style.background = '#444';
            btn.style.cursor = 'not-allowed';
            if (val.length < 3) {
                status.innerText = "Слишком короткое (мин. 3 символа)";
                status.style.color = "#ff4444";
                return;
            }
            status.innerText = "Проверка...";
            status.style.color = "#aaa";
            // Debounce (ждем пока перестанет печатать)
            if (usernameTimeout) clearTimeout(usernameTimeout);
            usernameTimeout = setTimeout(() => {
                // Запрос к базе
                db.collection('users').where('username', '==', val).get().then(snap => {
                    if (snap.empty) {
                        status.innerText = `@${val} свободно`;
                        status.style.color = "#4caf50"; // Зеленый
                        btn.disabled = false;
                        btn.style.background = '#007bff';
                        btn.style.cursor = 'pointer';
                    } else {
                        status.innerText = `@${val} уже занято`;
                        status.style.color = "#ff4444"; // Красный
                    }
                });
            }, 500); // Проверка через 0.5 сек после остановки ввода
        }
        // Завершение регистрации
        function finishRegistration() {
            const name = document.getElementById('regName').value.trim();
            const surname = document.getElementById('regSurname').value.trim();
            const username = document.getElementById('regUsername').value.trim();
            if (!name || !username) return;
            db.collection('users').doc(currentUser.uid).set({
                name: name,
                surname: surname,
                username: username,
                email: currentUser.email, // Обновляем на всякий случай
                lastSeen: firebase.firestore.FieldValue.serverTimestamp()
            }, { merge: true }).then(() => {
                // Успех -> Перезагружаем страницу или просто скрываем окно
                // Лучше просто скрыть окно и запустить логику, как в onAuthStateChanged
                document.getElementById('authScreen').classList.add('hidden');
                loadData();
                listenForIncomingCalls();
                loadTgId();
                if (lastSeenInterval) clearInterval(lastSeenInterval);
                lastSeenInterval = setInterval(updateLastSeen, 30000);
            });
        }
        window.addEventListener('beforeunload', updateLastSeen);
        // --- LOGIC ---
        var tabOrder = ['friends', 'groups', 'channels', 'bots'];
        var currentTabIndex = 0;

        // Логика переключения вкладок с анимацией
        function switchTab(t) {
            const friendsList = document.getElementById('friendsList');
            const requestsList = document.getElementById('requestsList');
            const noDataList = document.getElementById('noDataList');

            // Проверяем, не открыто ли сейчас окно заявок
            const isRequestsOpen = !requestsList.classList.contains('hidden');
            const newIndex = tabOrder.indexOf(t);

            // Если мы нажимаем на ту же папку, которая и так открыта, И при этом окно заявок скрыто — ничего не делаем.
            // Но если открыты заявки, то нажатие на любую папку (включая Личные) должно сработать!
            if (t !== 'requests' && newIndex === currentTabIndex && !isRequestsOpen) return;

            // 2. Вычисляем направление анимации
            let directionClass = 'slide-right';
            if (newIndex !== -1 && currentTabIndex !== -1) {
                if (newIndex < currentTabIndex) {
                    directionClass = 'slide-left';
                }
            }

            if (t !== 'requests') {
                currentTabIndex = newIndex;
            }

            // 3. Скрываем все списки и сбрасываем анимации
            [friendsList, requestsList, noDataList].forEach(el => {
                if (el) {
                    el.classList.add('hidden');
                    el.classList.remove('slide-right', 'slide-left');
                }
            });

            // 4. Логика для кнопки Заявок (сверху)
            if (t === 'requests') {
                document.querySelectorAll('.tab').forEach(el => el.classList.remove('active'));
                void requestsList.offsetWidth;
                requestsList.classList.remove('hidden');
                requestsList.classList.add('slide-right');
                return;
            }

            // 5. Подсветка активной папки
            document.querySelectorAll('.tab').forEach(el => el.classList.remove('active'));
            const clickedTab = document.querySelector(`.tab[onclick="switchTab('${t}')"]`);

            if (clickedTab) {
                clickedTab.classList.add('active');
                clickedTab.scrollIntoView({ behavior: 'smooth', inline: 'center', block: 'nearest' });
            }

            // 6. Показываем нужный контент
            let activeList;
            if (t === 'friends') {
                activeList = friendsList;
            } else {
                if (!noDataList) return;
                const tabNames = { 'groups': 'Группы', 'channels': 'Каналы', 'bots': 'Боты' };
                noDataList.innerHTML = `<div style="color:#8e8e93; font-size:15px; margin-top:40px; text-align:center;">Папка «${tabNames[t]}» пока пуста</div>`;
                activeList = noDataList;
            }

            // Фокус с анимацией
            void activeList.offsetWidth;
            activeList.classList.remove('hidden');
            activeList.classList.add(directionClass);
        }

        // ==========================================
        // НОВОЕ: СВАЙПЫ ДЛЯ ПЕРЕЛИСТЫВАНИЯ НА ТЕЛЕФОНЕ
        // ==========================================
        let tabSwipeStartX = 0;
        let tabSwipeStartY = 0;
        let tabIsSwiping = false;

        document.addEventListener('DOMContentLoaded', () => {
            const sidebar = document.getElementById('mainSidebar');
            if (!sidebar) return;

            // Касание
            sidebar.addEventListener('touchstart', (e) => {
                if (window.innerWidth > 768) return; // Работает только на телефонах
                // Запрещаем свайп, если мы нажимаем на шапку или на саму полоску папок (там свой скролл)
                if (e.target.closest('.tabs-container, .profile-bar')) return;

                tabSwipeStartX = e.touches[0].clientX;
                tabSwipeStartY = e.touches[0].clientY;
                tabIsSwiping = true;
            }, { passive: true });

            // Движение пальца
            sidebar.addEventListener('touchmove', (e) => {
                if (!tabIsSwiping) return;

                const diffX = e.touches[0].clientX - tabSwipeStartX;
                const diffY = e.touches[0].clientY - tabSwipeStartY;

                // Если юзер листает список друзей вверх-вниз — отменяем переключение папок!
                if (Math.abs(diffY) > Math.abs(diffX)) {
                    tabIsSwiping = false;
                }
            }, { passive: true });

            // Отпускание пальца
            sidebar.addEventListener('touchend', (e) => {
                if (!tabIsSwiping) return;
                const diffX = e.changedTouches[0].clientX - tabSwipeStartX;

                // Свайп влево (открываем следующую папку)
                if (diffX < -60) {
                    const nextIdx = currentTabIndex + 1;
                    if (nextIdx < tabOrder.length) switchTab(tabOrder[nextIdx]);
                }
                // Свайп вправо (открываем предыдущую папку)
                else if (diffX > 60) {
                    const prevIdx = currentTabIndex - 1;
                    if (prevIdx >= 0) switchTab(tabOrder[prevIdx]);
                }

                tabIsSwiping = false;
            });
        });

        // --- НОВОЕ: Горизонтальный скролл папок с помощью КОЛЕСИКА МЫШИ (для ПК) ---
        // --- НОВОЕ: Скролл папок колесиком И перетаскивание мышкой (как в ТГ) ---
        document.addEventListener('DOMContentLoaded', () => {
            const tabsScroll = document.getElementById('tabsScroll');
            if (tabsScroll) {
                // 1. Скролл колесиком мыши
                tabsScroll.addEventListener('wheel', (evt) => {
                    if (evt.deltaY !== 0) {
                        evt.preventDefault();
                        tabsScroll.scrollLeft += evt.deltaY;
                    }
                });

                // 2. Перетаскивание зажатой левой кнопкой мыши (Drag-to-scroll)
                let isDown = false;
                let startX;
                let scrollLeft;

                tabsScroll.addEventListener('mousedown', (e) => {
                    isDown = true;
                    tabsScroll.classList.add('is-dragging');
                    startX = e.pageX - tabsScroll.offsetLeft;
                    scrollLeft = tabsScroll.scrollLeft;
                });

                tabsScroll.addEventListener('mouseleave', () => {
                    isDown = false;
                    tabsScroll.classList.remove('is-dragging');
                });

                tabsScroll.addEventListener('mouseup', () => {
                    isDown = false;
                    tabsScroll.classList.remove('is-dragging');
                });

                tabsScroll.addEventListener('mousemove', (e) => {
                    if (!isDown) return;
                    e.preventDefault(); // Блокируем выделение текста
                    const x = e.pageX - tabsScroll.offsetLeft;
                    const walk = (x - startX) * 2; // Умножаем на 2 для скорости прокрутки
                    tabsScroll.scrollLeft = scrollLeft - walk;
                });
            }
        });
        // Слушатель входящих заявок в друзья
        function listenForFriendRequests() {
            db.collection('friend_requests')
                .where('to', '==', currentUser.uid)
                .onSnapshot(async snap => {
                    const list = document.getElementById('requestsList');
                    const badge = document.getElementById('requestsBadge');
                    // Обновляем счетчик заявок
                    if (snap.size > 0) {
                        badge.innerText = snap.size;
                        badge.classList.remove('hidden');
                    } else {
                        badge.classList.add('hidden');
                    }
                    // Если список открыт, отрисовываем
                    list.innerHTML = '';
                    if (snap.empty) {
                        list.innerHTML = '<div style="padding:20px;text-align:center;color:#888">Нет новых заявок</div>';
                        return;
                    }
                    snap.forEach(doc => {
                        const data = doc.data();
                        const div = document.createElement('div');
                        div.className = 'user-item'; // Используем тот же стиль, что и для чатов
                        // Аватарка (заглушка или можно подгрузить реальную)
                        const avatar = '<div class="user-item-avatar" style="background:#444;display:flex;align-items:center;justify-content:center;">👤</div>';
                        div.innerHTML = `
                                ${avatar}
                                <div class="user-name" style="grid-row: 1/span 2; align-self:center;">
                                ${data.fromUsername ? '@' + data.fromUsername : 'Пользователь'}
                                <div style="font-size:12px; color:#888; font-weight:normal;">Хочет добавить вас в друзья</div>
                                </div>
                                <div style="grid-column:3; grid-row:1/span 2; display:flex; gap:10px;">
                                <button onclick="accept('${doc.id}', '${data.from}', '${data.fromEmail}')" style="background:#28a745; border:none; color:white; padding:5px 10px; border-radius:5px; cursor:pointer;">✓</button>
                                <button onclick="reject('${doc.id}')" style="background:#dc3545; border:none; color:white; padding:5px 10px; border-radius:5px; cursor:pointer;">✕</button>
                                </div>
                                `;
                        list.appendChild(div);
                    });
                });
        }
        // Вспомогательная функция для обновления текста последнего сообщения в списке
        function startMessageListener(chatId, fid, createdTime) {
            let isListInitialLoad = true;
            db.collection('chats').doc(chatId).collection('msgs')
                .orderBy('ts', 'desc').limit(1)



                .onSnapshot(msgSnap => {
                    const lastEl = document.getElementById('last-' + chatId);
                    const dateEl = document.getElementById('date-' + chatId);
                    const statusEl = document.getElementById('status-' + chatId);
                    const userDiv = document.getElementById('u-' + fid);

                    let timeToDisplay = createdTime;
                    if (!msgSnap.empty) {
                        const lastData = msgSnap.docs[0].data();

                        // --- НОВАЯ ЛОГИКА ОБНОВЛЕНИЯ ТЕКСТА ---
                        const renderPreview = () => {
                            if (!lastEl) return;
                            const decrypted = decryptText(lastData.txt, chatId);

                            // Если расшифровка не удалась (вернула тот же шифр)
                            if (decrypted === lastData.txt && !lastData.sys) {
                                // Рисуем премиальные точки (индикатор защиты)
                                lastEl.innerHTML = `<span style="opacity:0.5; letter-spacing:2px; color:#736AF0;">••••••••</span>`;
                            } else {
                                let displayText = '';
                                const type = lastData.type || 'text';
                                if (type === 'image') displayText = '📷 Фотография';
                                else if (type === 'file') displayText = '📄 Файл';
                                else if (type === 'call') {
                                    const callState = decrypted.split('|')[0];
                                    displayText = (callState === 'missed' || callState === 'canceled') ? '📞 Пропущенный вызов' : '📞 Звонок';
                                } else {
                                    displayText = decrypted || '';
                                    if (displayText.length > 25) displayText = displayText.substring(0, 25) + '...';
                                }
                                if (lastData.from === currentUser.uid) displayText = 'Вы: ' + displayText;
                                lastEl.innerHTML = displayText;
                            }
                        };

                        // Вызываем отрисовку сразу
                        renderPreview();

                        // Слушаем событие: если ключ придет позже — текст обновится сам!
                        window.addEventListener('keyReady_' + chatId, renderPreview, { once: true });
                        // --------------------------------------

                        if (lastData.ts) timeToDisplay = lastData.ts.toMillis();

                        if (statusEl) {
                            if (lastData.from === currentUser.uid) {
                                let ticksHtml = lastData.read ? '<span style="margin-right:-4px;">✓</span>✓' : '✓';
                                statusEl.innerHTML = ticksHtml;
                                statusEl.style.display = 'inline-flex';
                            } else {
                                statusEl.style.display = 'none';
                            }
                        }
                    } else {
                        if (lastEl) lastEl.innerHTML = "Нет сообщений";
                        if (statusEl) statusEl.style.display = 'none';
                    }
                    // Обновляем дату
                    if (dateEl && timeToDisplay > 0) {
                        // ЗАМЕНИТЕ СТАРЫЙ IF/ELSE НА ЭТУ СТРОЧКУ:
                        dateEl.innerText = formatTelegramDate(new Date(timeToDisplay));
                    }
                    // Обновляем сортировку списка
                    if (userDiv) {
                        userDiv.setAttribute('data-time', timeToDisplay);
                        sortFriendsList();
                    }

                });
            // Слушаем непрочитанные (Badge)
            db.collection('chats').doc(chatId).collection('msgs')
                .where('to', '==', currentUser.uid)
                .where('read', '==', false)
                .onSnapshot(unreadSnap => {
                    const badgeEl = document.getElementById('badge-' + chatId);
                    const count = unreadSnap.size;
                    // Сохраняем в глобальный объект для общего счетчика (если он у вас есть)
                    if (typeof unreadCounts !== 'undefined') {
                        unreadCounts[chatId] = count;
                        updateTotalFriendsBadge();
                    }
                    if (badgeEl) {
                        if (count > 0) {
                            badgeEl.innerText = count;
                            badgeEl.classList.remove('hidden');
                        } else {
                            badgeEl.classList.add('hidden');
                        }
                    }
                    isListInitialLoad = false;
                });
        }

        // --- ЛОГИКА УДАЛЕНИЯ (ОБНОВЛЕННАЯ) ---


        // 1. Открытие окна подтверждения удаления
        function openDeleteSheet() {
            // 1. Закрываем контекстное меню
            const menu = document.getElementById('contextMenu');
            if (menu) {
                menu.classList.remove('active');
                setTimeout(() => { menu.style.display = 'none'; }, 200);
            }

            // 2. Безопасное получение имени собеседника
            const chatTitleEl = document.getElementById('chatTitle');
            let friendName = chatTitleEl ? (chatTitleEl.firstElementChild ? chatTitleEl.firstElementChild.innerText : chatTitleEl.innerText) : "собеседника";

            // 3. Подготавливаем модалку
            const friendNameSpan = document.getElementById('deleteFriendName');
            if (friendNameSpan) friendNameSpan.innerText = friendName;

            // 4. Показываем модалку
            const modal = document.getElementById('deleteModalOverlay');
            if (modal) {
                modal.style.display = 'flex';
            }
        }

        // 2. Закрытие окна (кнопка Отмена)
        function closeDeleteModal() {
            const modal = document.getElementById('deleteModalOverlay');
            if (modal) modal.style.display = 'none';

            // --- НОВОЕ: Принудительно снимаем размытие фона и выделение ---
            closeAllSheets();
        }

        // 3. Выполнение удаления (кнопка Удалить)
        function animateMessageRemoval(el) {
            if (!el || el.classList.contains('msg-deleting')) return;

            el.classList.remove('msg-highlighted'); // Убираем эффект долгого нажатия

            // Фиксируем текущие размеры в пикселях для плавной анимации
            el.style.height = el.offsetHeight + 'px';
            el.style.overflow = 'hidden';

            // Форсируем перерисовку, чтобы браузер запомнил высоту
            void el.offsetHeight;

            // Плавно сворачиваем в 0
            el.classList.add('msg-deleting');
            el.style.height = '0px';
            el.style.paddingTop = '0px';
            el.style.paddingBottom = '0px';
            el.style.marginTop = '0px';
            el.style.marginBottom = '0px';
            el.style.border = 'none';

            // Через 300мс (когда анимация закончится) окончательно стираем элемент
            setTimeout(() => {
                if (el && el.parentNode) {
                    el.remove();
                    updateDateSeparators(); // Пересчитываем плашки дат
                }
            }, 300);
        }

        // 3. Выполнение удаления (кнопка Удалить)
        function executeDelete() {
            if (!selectedMsgId) return;

            const isDeleteForEveryone = document.getElementById('deleteForEveryone').checked;
            const el = document.getElementById(`msg-${selectedMsgId}`);

            // Запускаем красивую анимацию прямо сейчас
            if (el) animateMessageRemoval(el);

            if (isDeleteForEveryone) {
                // Удаляем из базы
                db.collection('chats').doc(currentChatId).collection('msgs').doc(selectedMsgId).delete()
                    .catch(err => {
                        console.error("Ошибка удаления:", err);
                        showToast("Не удалось удалить: " + err.message);
                    });
            } else {
                // Прячем локально
                const deletedLocal = JSON.parse(localStorage.getItem('deletedMsgs') || '[]');
                deletedLocal.push(selectedMsgId);
                localStorage.setItem('deletedMsgs', JSON.stringify(deletedLocal));
            }

            closeDeleteModal();
        }

        function loadProfileFromCache() {
            const cachedProfile = localStorage.getItem('user_profile_cache');
            if (cachedProfile) {
                try {
                    const d = JSON.parse(cachedProfile);
                    // 1. Ставим аватарку
                    const myAvatarSmall = document.getElementById('myAvatarSmall');
                    if (myAvatarSmall && d.avatar) {
                        myAvatarSmall.innerHTML = `<img src="${d.avatar}" alt="avatar">`;
                    }
                    // 2. Заполняем данные в шторке профиля (чтобы там не было пусто)
                    const emailEl = document.getElementById('profileEmail');
                    if (emailEl && d.email) emailEl.innerText = d.email;

                    const nameInput = document.getElementById('profileName');
                    if (nameInput) nameInput.value = d.name || '';

                    const usernameDiv = document.getElementById('profileUsername');
                    if (usernameDiv) usernameDiv.innerText = d.username ? '@' + d.username : '@не_задан';

                } catch (e) {
                    console.log("Ошибка чтения кэша профиля", e);
                }
            }
        }

        // --- НОВАЯ ВСПОМОГАТЕЛЬНАЯ ФУНКЦИЯ (Вставить ПЕРЕД loadData) ---
        function getFriendItemHTML(fid, friendData, chatId, createdTime) {
            // Если данных нет, берем имя из кэша или пишем заглушку
            const fName = getDisplayName(fid, friendData || usersCache[fid] || {});
            const fNick = friendData ? ('@' + friendData.username) : '';

            // Аватарка
            const avatarHtml = (friendData && friendData.avatar)
                ? `<img src="${friendData.avatar}" class="user-item-avatar">`
                : `<div class="user-item-avatar" style="background:#444;display:flex;align-items:center;justify-content:center;font-size:24px;color:#888">👤</div>`;

            return `
                                ${avatarHtml}
                                <div class="user-name">${fName}</div>
                                <div class="last-msg-row">
                                <span class="last-msg" id="last-${chatId}">...</span>
                                </div>
                                <div class="meta-column">
                                <span class="last-msg-date" id="date-${chatId}"></span>
                                <div class="meta-bottom-row">
                                <span id="status-${chatId}" class="list-ticks"></span>
                                <div class="badge-count hidden" id="badge-${chatId}">0</div>
                                </div>
                                </div>
                                `;
        }

        function loadData() {
            // 1. Запускаем прослушку заявок
            if (typeof listenForFriendRequests === 'function') {
                listenForFriendRequests();
            }

            const list = document.getElementById('friendsList');
            if (list.innerHTML === '' || list.innerText.includes('Список друзей пуст')) {
                list.innerHTML = '<div class="tg-spinner-container"><div class="tg-spinner"></div></div>';
            }

            if (window.mauiInterop) {
                window.mauiInterop.postMessage("toggle_network");
            } else {
                window.needsNetworkReset = true; // Запасной вариант
            }

            if (window.mauiInterop) {
                window.mauiInterop.postMessage("toggle_network");
            } else {
                window.needsNetworkReset = true; // Запасной вариант
            }
            console.log("[JS] Установлен флаг для сброса сети через C#");

            const localFriends = localStorage.getItem('novogram_cached_friends');
            if (localFriends) {
                const parsed = JSON.parse(localFriends);
                const list = document.getElementById('friendsList');
                if (list.innerHTML === '' || list.innerText.includes('Список друзей пуст')) {
                    list.innerHTML = ''; // Очищаем заглушку
                    parsed.forEach(p => {
                        // Создаем div вручную, чтобы не дублировать код отрисовки
                        // Или просто ждем пока Firebase обновит данные, но лучше отрисовать:
                        // (Для простоты пока просто загрузим кэш в память, чтобы скрипт знал имена)
                        if (p.fid && p.data) usersCache[p.fid] = p.data;
                    });
                    // Тут можно вызвать отрисовку, но чтобы не усложнять код дублированием render-функции,
                    // Firebase Persistence из шага 1 обычно справляется с отрисовкой сам.
                    // Но сохранение usersCache в память нам очень поможет для имен в заголовках!
                }
            }

            // 2. Слушаем список друзей (ОПТИМИЗИРОВАНО + ПРЕДЗАГРУЗКА КЛЮЧЕЙ)
            db.collection('friends')
                .where('users', 'array-contains', currentUser.uid)
                .onSnapshot(async snap => {
                    const list = document.getElementById('friendsList');

                    // --- НОВОЕ: УДАЛЯЕМ КРУТИЛКУ, КАК ТОЛЬКО ПРИШЛИ ДАННЫЕ ---
                    const spinner = list.querySelector('.tg-spinner-container');
                    if (spinner) {
                        spinner.remove();
                    }
                    // ---------------------------------------------------------

                    if (snap.empty) {
                        list.innerHTML = '<div class="empty-list-msg" style="padding:20px;text-align:center;color:#888">Список друзей пуст</div>';
                        return;
                    }

                    // --- УДАЛЯЕМ НАДПИСЬ ПУСТОТЫ ПЕРЕД ДОБАВЛЕНИЕМ ДРУЗЕЙ ---
                    const emptyMsg = list.querySelector('.empty-list-msg');
                    if (emptyMsg) emptyMsg.remove();

                    // Страховка на случай, если надпись подгрузилась из старого кэша
                    if (list.innerHTML.includes('Список друзей пуст')) {
                        list.innerHTML = '';
                    }
                    // ---------------------------------------------------------

                    // Проходим только по ИЗМЕНЕНИЯМ
                    snap.docChanges().forEach(async change => {
                        const d = change.doc.data();
                        const fid = d.users.find(id => id !== currentUser.uid);
                        if (!fid) return;

                        // Если друга удалили
                        if (change.type === 'removed') {
                            const el = document.getElementById('u-' + fid);
                            if (el) el.remove();
                            return;
                        }

                        // --- 🔥 ВАЖНОЕ ИЗМЕНЕНИЕ: ФОНОВАЯ ЗАГРУЗКА КЛЮЧА 🔥 ---
                        // Вычисляем ID чата
                        const preChatId = [currentUser.uid, fid].sort().join('_');
                        // Тихо запрашиваем ключ. Мы не ставим await, чтобы не тормозить интерфейс.
                        // Скрипт пойдет за ключом в фоне.
                        fetchChatKey(preChatId).then(k => {
                            if (k) console.log("🔑 Ключ предзагружен для:", fid);
                        });
                        // -----------------------------------------------------

                        // Получаем данные друга (из кэша или базы)
                        let friendData = usersCache[fid];
                        if (!friendData) {
                            try {
                                const userSnap = await db.collection('users').doc(fid).get();
                                if (userSnap.exists) {
                                    friendData = userSnap.data();
                                    usersCache[fid] = friendData;
                                }
                            } catch (e) {
                                console.error("Ошибка загрузки профиля", e);
                            }
                        }

                        let fName = 'Загрузка...';
                        if (friendData) {
                            // Склеиваем имя и фамилию. Если фамилии нет, trim() уберет лишний пробел.
                            fName = `${friendData.name || ''} ${friendData.surname || ''}`.trim() || friendData.username || 'User';
                        }
                        const fNick = friendData && friendData.username ? ('@' + friendData.username) : '';
                        const fAvatar = friendData ? friendData.avatar : null;
                        const createdTime = d.createdAt ? d.createdAt.toMillis() : 0;
                        const chatId = preChatId; // Используем уже вычисленный ID

                        let div = document.getElementById('u-' + fid);
                        const isNew = !div;

                        if (isNew) {
                            div = document.createElement('div');
                            div.className = 'user-item';
                            div.id = 'u-' + fid;
                            div.onclick = () => openChat(fid, fName, fNick);
                        }

                        div.setAttribute('data-time', createdTime);

                        const avatarHtml = fAvatar
                            ? `<img src="${fAvatar}" class="user-item-avatar">`
                            : `<div class="user-item-avatar" style="background:#444;display:flex;align-items:center;justify-content:center;font-size:24px;color:#888">👤</div>`;

                        div.innerHTML = `
                                ${avatarHtml}
                                <div class="user-name">${fName}</div>
                                <div class="last-msg-row">
                                <span class="last-msg" id="last-${chatId}">...</span>
                                </div>
                                <div class="meta-column">
                                <span class="last-msg-date" id="date-${chatId}"></span>
                                <div class="meta-bottom-row">
                                <span id="status-${chatId}" class="list-ticks"></span>
                                <div class="badge-count hidden" id="badge-${chatId}">0</div>
                                </div>
                                </div>
                                `;

                        if (isNew) {
                            list.appendChild(div);
                            startMessageListener(chatId, fid, createdTime);
                        }
                    });

                    setTimeout(sortFriendsList, 100);
                });
        }
        function sortFriendsList() {
            const list = document.getElementById('friendsList');
            // Берем только элементы чатов (игнорируем крутилку загрузки, если она там есть)
            const items = Array.from(list.querySelectorAll('.user-item'));

            // 1. ЗАПОМИНАЕМ старые позиции элементов (до сортировки)
            const oldPositions = new Map();
            items.forEach(item => {
                oldPositions.set(item.id, item.getBoundingClientRect().top);
            });

            // 2. СОРТИРУЕМ элементы по времени
            items.sort((a, b) => {
                const timeA = parseInt(a.getAttribute('data-time') || 0);
                const timeB = parseInt(b.getAttribute('data-time') || 0);
                return timeB - timeA;
            });

            // Мгновенно перемещаем их в HTML (глаз это не заметит)
            items.forEach(item => list.appendChild(item));

            // 3. АНИМИРУЕМ переход (FLIP техника)
            items.forEach(item => {
                const oldTop = oldPositions.get(item.id);
                // Если элемент уже был в списке (не новый)
                if (oldTop !== undefined) {
                    const newTop = item.getBoundingClientRect().top;
                    const delta = oldTop - newTop;

                    // Если позиция изменилась
                    if (delta !== 0) {
                        // "Телепортируем" элемент визуально обратно на его старое место
                        item.style.transform = `translateY(${delta}px)`;
                        item.style.transition = 'none';

                        // Ждем один кадр браузера и запускаем плавный спуск на новое место
                        requestAnimationFrame(() => {
                            requestAnimationFrame(() => {
                                item.style.transform = '';
                                // Плавная кривая движения (как в iOS/Telegram)
                                item.style.transition = 'transform 0.4s cubic-bezier(0.25, 0.8, 0.25, 1)';

                                // Убираем анимацию после ее завершения, чтобы не мешала hover-эффектам
                                setTimeout(() => {
                                    item.style.transition = '';
                                }, 400);
                            });
                        });
                    }
                }
            });
        }
        function updateTotalFriendsBadge() {
            const total = Object.values(unreadCounts).reduce((a, b) => a + b, 0);
            const el = document.getElementById('friendsBadge');
            if (total > 0) { el.innerText = total; el.classList.remove('hidden'); }
            else { el.classList.add('hidden'); }
        }
        async function sendFriendRequest() {
            const e = document.getElementById('searchEmail').value;
            const snap = await db.collection('users').where('email', '==', e).get();
            if (snap.empty) return alert('Нет пользователя');
            await db.collection('friend_requests').add({ from: currentUser.uid, fromEmail: currentUser.email, to: snap.docs[0].id });
            alert('Отправлено'); document.getElementById('searchEmail').value = '';
        }
        async function accept(rid, fid, femail) {
            await db.collection('friends').add({
                users: [currentUser.uid, fid],
                emails: { [currentUser.uid]: currentUser.email, [fid]: femail },
                createdAt: firebase.firestore.FieldValue.serverTimestamp()
            });
            await db.collection('friend_requests').doc(rid).delete();
        }
        function reject(rid) { db.collection('friend_requests').doc(rid).delete(); }
        function openChat(fid, name, nick) {
            // Отменяем таймер закрытия, если юзер очень быстро кликнул
            if (typeof closeChatTimeout !== 'undefined' && closeChatTimeout) {
                clearTimeout(closeChatTimeout);
                closeChatTimeout = null;
            }

            const newHash = "#chat/" + fid;

            // Если кликнули на тот же самый чат, в котором уже находимся - игнорируем
            if (window.location.hash === newHash) return;

            // --- ТОТ САМЫЙ МИКРО-ПРЫЖОК ---
            if (window.location.hash.startsWith('#chat/')) {
                // 1. Кидаем на главную (запишется в историю для кнопки Назад)
                window.location.hash = '';

                // 2. Через 15 миллисекунд (глаз не заметит) кидаем в новый диалог.
                // Браузер сам вызовет handleHashChange, который чисто загрузит аватарки и ключи.
                setTimeout(() => {
                    window.location.hash = newHash;
                }, 15);
            } else {
                // Если открываем чат прямо из главного меню
                window.location.hash = newHash;
            }
        }

        function scrollToMsg(id) {
            const el = document.getElementById('msg-' + id);
            if (el) {
                el.scrollIntoView({ behavior: 'smooth', block: 'center' });
                // Эффект подсвечивания
                el.style.transition = "background 0.5s";
                el.style.background = "#3a3a3a";
                setTimeout(() => { el.style.background = ""; }, 1500);
            } else {
                showToast("Сообщение не найдено (возможно, старое)");
            }
        }

        // --- ИСПРАВЛЕНИЕ 2: Умная загрузка без скачков ---
        // --- ИСПРАВЛЕННАЯ ФУНКЦИЯ ЗАГРУЗКИ (ТЕПЕРЬ УДАЛЯЕТ СООБЩЕНИЯ) ---
        function loadMessages() {
            if (window.msgUnsub) {
                window.msgUnsub();
                window.msgUnsub = null;
            }

            // Мгновенно достаем или создаем слой чата
            const { list, isNew } = getOrCreateMsgList(currentChatId);

            if (isNew) {
                list.classList.add('is-loading'); // Первый заход
                // --- ИСПРАВЛЕНО: Жесткое центрирование, игнорируя отступы списка ---
                // Мы используем absolute позиционирование и transform для точного центра.
                list.innerHTML = '<div class="tg-spinner-container" style="position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); z-index: 10;"><div class="tg-spinner"></div></div>';
            } else {
                list.scrollTop = list.scrollHeight; // Повторный заход - чат появляется МГНОВЕННО
            }

            const deletedLocal = JSON.parse(localStorage.getItem('deletedMsgs') || '[]');

            let isChatInitialLoad = true;
            window.msgUnsub = db.collection('chats').doc(currentChatId).collection('msgs')
                .orderBy('ts', 'asc')
                .onSnapshot({ includeMetadataChanges: true }, snap => {

                    // --- НОВОЕ: Удаляем крутилку, как только Firebase прислал ответ ---
                    const spinner = list.querySelector('.tg-spinner-container');
                    if (spinner) spinner.remove();

                    const batch = db.batch();
                    let needCommit = false;
                    const isWindowActive = document.hasFocus() && document.visibilityState === 'visible';

                    // Удаления
                    snap.docChanges().forEach(change => {
                        if (change.type === 'removed') {
                            const el = document.getElementById('msg-' + change.doc.id);
                            if (el) animateMessageRemoval(el); // Используем плавное удаление!
                        }
                    });

                    // Проверка скролла (если мы уже видим чат)
                    // Важно: если чат скрыт (is-loading), считаем что скролл нам не важен, мы всё равно прыгнем вниз
                    const isScrolledToBottom = list.scrollHeight - list.scrollTop <= list.clientHeight + 300;

                    let allDocs = snap.docs;

                    allDocs.sort((a, b) => {
                        const timeA = a.data().ts ? a.data().ts.toMillis() : Date.now() + 999999999;
                        const timeB = b.data().ts ? b.data().ts.toMillis() : Date.now() + 999999999;
                        return timeA - timeB;
                    });

                    allDocs.forEach(doc => {
                        const msgId = doc.id;
                        const rawData = doc.data();

                        if (deletedLocal.includes(msgId)) {
                            const el = document.getElementById('msg-' + msgId);
                            if (el) el.remove();
                            return;
                        }

                        const m = { ...rawData };
                        m.txt = decryptText(rawData.txt, currentChatId);
                        const msgType = m.type || 'text';

                        const tsMillis = m.ts ? m.ts.toMillis() : Date.now();
                        const dateStr = getChatSeparatorDate(tsMillis);

                        // НОВОЕ: Генерируем "машинную" дату для поиска календарем (формат YYYY-MM-DD)
                        const dObj = new Date(tsMillis);
                        const rawDate = `${dObj.getFullYear()}-${String(dObj.getMonth() + 1).padStart(2, '0')}-${String(dObj.getDate()).padStart(2, '0')}`;

                        let div = document.getElementById('msg-' + msgId);
                        const isNew = !div;

                        if (isNew) {
                            div = document.createElement('div');
                            div.id = 'msg-' + msgId;

                            if (m.sys) div.className = 'msg msg-sys';
                            else if (m.from === currentUser.uid) div.className = 'msg msg-me';
                            else div.className = 'msg msg-other';

                            // На ПК оставляем клик правой кнопкой мыши
                            div.oncontextmenu = (e) => {
                                e.preventDefault(); e.stopPropagation();

                                // ИГНОРИРУЕМ НАТИВНЫЙ ВЫЗОВ НА ТЕЛЕФОНЕ (там работает наш touch-таймер)
                                if (window.innerWidth <= 768) return;

                                // --- НОВОЕ: Закрытие при повторном клике ---
                                const menu = document.getElementById('contextMenu');
                                if (menu && menu.classList.contains('active')) {
                                    if (selectedMsgId === msgId) {
                                        closeAllSheets(); // Закрываем
                                        return;
                                    }
                                }

                                openContextMenu(e, msgId, m.from === currentUser.uid);
                            };
                            // Одиночный клик для мобилок удален, теперь работает только долгое зажатие!
                            list.appendChild(div);
                            if (!isChatInitialLoad && m.from !== currentUser.uid) {
                                try {
                                    playNotificationSound('in-chat');
                                    // Проверяем, существует ли TitleNotifier, прежде чем его вызывать
                                    if (typeof window.TitleNotifier !== 'undefined' && typeof window.TitleNotifier.onNewMessage === 'function') {
                                        TitleNotifier.onNewMessage();
                                    }
                                } catch (notificationError) {
                                    console.warn("[NOVOGRAM_LOG] Ошибка при воспроизведении уведомления:", notificationError);
                                }
                            }
                        }

                        div.setAttribute('data-datestr', dateStr);
                        div.setAttribute('data-rawdate', rawDate); // Добавляем машинную дату для календаря

                        // Рендер контента
                        const newHtml = buildMessageHTML(m, msgId, msgType);
                        if (div.innerHTML !== newHtml) div.innerHTML = newHtml;

                        if (typeof isAutoTranslate !== 'undefined' && isAutoTranslate && m.from !== currentUser.uid && msgType === 'text' && !m.sys) {
                            appendTranslation(div, m.txt, msgId);
                        }

                        if (m.to === currentUser.uid && !m.read && isWindowActive) {
                            batch.update(doc.ref, { read: true });
                            needCommit = true;
                        }
                    });

                    if (needCommit) batch.commit();

                    updateDateSeparators();
                    // <--- !!! ИЗМЕНЕНИЕ 2: ЛОГИКА СКРОЛЛА И ПОЯВЛЕНИЯ

                    // Если список сейчас скрыт (значит это ПЕРВАЯ загрузка при открытии)
                    // Если список сейчас скрыт (значит это ПЕРВАЯ загрузка при открытии)
                    if (list.classList.contains('is-loading')) {
                        list.scrollTop = list.scrollHeight;

                        // В WebView надежнее использовать setTimeout вместо requestAnimationFrame
                        setTimeout(() => {
                            list.scrollTop = list.scrollHeight;
                            list.classList.remove('is-loading'); // Чат появляется
                        }, 150); // Даем движку 150 миллисекунд на рендеринг элементов
                    } else if (isScrolledToBottom) {
                        // --- НОВОЕ: Плавный автоскролл, если мы уже были внизу и пришло новое сообщение ---
                        setTimeout(() => {
                            list.scrollTo({ top: list.scrollHeight + 500, behavior: 'smooth' });
                        }, 50);
                    }

                    isChatInitialLoad = false;
                });
        }



        // Вспомогательная функция вставки HTML перевода (чтобы не дублировать код)
        function injectTranslationBlock(msgDiv, text) {
            if (msgDiv.querySelector('.translated-block')) return;

            const transBlock = document.createElement('div');
            transBlock.className = 'translated-block';
            transBlock.innerText = text;

            const contentSpan = msgDiv.querySelector('.msg-text');
            if (contentSpan) contentSpan.appendChild(transBlock);
            else msgDiv.appendChild(transBlock);
        }

        // --- 3. ИСПРАВЛЕННАЯ ФУНКЦИЯ ПЕРЕВОДА (API + CACHE + SCROLL FIX) ---
        // --- 3. ИСПРАВЛЕННАЯ ФУНКЦИЯ ПЕРЕВОДА (С СОХРАНЕНИЕМ В ПАМЯТЬ) ---
        // --- ИСПРАВЛЕНИЕ 3: Перевод с сохранением ---
        async function appendTranslation(msgElement, text, msgId) {
            if (!isAutoTranslate) return;
            if (msgElement.querySelector('.translated-block')) return;

            // Сначала проверяем кэш
            if (globalTranslationCache[msgId]) {
                injectTranslationBlock(msgElement, globalTranslationCache[msgId]);
                return;
            }

            const list = currentMsgList;
            // Запоминаем позицию скролла перед вставкой
            const wasAtBottom = list.scrollHeight - list.scrollTop <= list.clientHeight + 400;

            // Запрос к API
            const translatedText = await fetchTranslation(text, targetLang);

            if (!msgElement.isConnected) return;

            if (translatedText && translatedText !== text) {
                // СОХРАНЯЕМ В ПАМЯТЬ
                saveTranslationToLocal(msgId, translatedText);

                // Рисуем
                injectTranslationBlock(msgElement, translatedText);

                // Корректируем скролл мягко
                if (wasAtBottom) {
                    requestAnimationFrame(() => {
                        list.scrollTop = list.scrollHeight + 500;
                    });
                }
            }
        }

        // --- 2. ВСПОМОГАТЕЛЬНАЯ ФУНКЦИЯ HTML (чтобы не дублировать код) ---
        function buildMessageHTML(m, msgId, msgType) {
            let contentHtml = '';

            // Время
            let timeStr = '';
            if (m.ts) {
                const date = m.ts.toDate();
                timeStr = date.getHours().toString().padStart(2, '0') + ':' + date.getMinutes().toString().padStart(2, '0');
            } else {
                const now = new Date();
                timeStr = now.getHours().toString().padStart(2, '0') + ':' + now.getMinutes().toString().padStart(2, '0');
            }

            let ticksHtml = m.read ? '<span style="margin-right: -4px;">✓</span>✓' : '✓';

            // Цитата (Reply)
            if (m.replyTo) {
                contentHtml += `
                                <div class="msg-reply-quote" onclick="scrollToMsg('${m.replyTo.id}')">
                                <div class="msg-reply-name">${m.replyTo.name}</div>
                                <div class="msg-reply-text">${m.replyTo.text}</div>
                                </div>`;
            }

            // Основной контент
            if (m.sys) {
                contentHtml += m.txt;
            }
            else if (msgType === 'image') {
                let imgSrc = m.txt;
                if (m.txt.includes('id=')) { try { const fileId = m.txt.split('id=')[1]; imgSrc = `https://lh3.googleusercontent.com/d/${fileId}=w600`; } catch (e) { } }
                contentHtml += `<div class="media-container"><img src="${imgSrc}" class="chat-media-img" onclick="openImageViewer('${imgSrc}')" onerror="this.src='https://placehold.co/200x200?text=Ошибка';"></div>`;
            }
            else if (msgType === 'call') {
                const parts = m.txt.split('|');
                const callState = parts[0] || 'success';
                const durationStr = parts[1] || '';
                const isMine = (m.from === currentUser.uid);

                let titleText = '';
                let arrowHtml = '';
                let arrowColor = '#50a758'; // Зеленый

                // Логика текстов и стрелочек
                if (isMine) {
                    titleText = (callState === 'canceled' || callState === 'missed') ? 'Отмененный звонок' : 'Исходящий звонок';
                    arrowColor = (callState === 'canceled' || callState === 'missed') ? '#ff595a' : '#50a758';
                    arrowHtml = `<svg style="color:${arrowColor}; margin-right:4px;" width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="3" stroke-linecap="round" stroke-linejoin="round"><line x1="7" y1="17" x2="17" y2="7"></line><polyline points="7 7 17 7 17 17"></polyline></svg>`;
                } else {
                    titleText = (callState === 'canceled' || callState === 'missed') ? 'Пропущенный звонок' : 'Входящий звонок';
                    arrowColor = (callState === 'canceled' || callState === 'missed') ? '#ff595a' : '#50a758';
                    arrowHtml = `<svg style="color:${arrowColor}; margin-right:4px;" width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="3" stroke-linecap="round" stroke-linejoin="round"><line x1="17" y1="7" x2="7" y2="17"></line><polyline points="17 17 7 17 7 7"></polyline></svg>`;
                }

                // Форматируем длительность
                let durationDisplay = '';
                if (durationStr && durationStr !== '00:00') {
                    const dParts = durationStr.split(':');
                    if (dParts.length === 2) {
                        const mins = parseInt(dParts[0], 10);
                        const secs = parseInt(dParts[1], 10);
                        if (mins > 0) durationDisplay = ` (${mins} мин ${secs} сек)`;
                        else durationDisplay = ` (${secs} сек)`;
                    }
                }

                // ВАЖНО: Добавлено style="color: currentColor;" к SVG и убран onclick из верстки, чтобы не было конфликтов
                contentHtml += `
                                <div class="chat-call-card">
                                <div class="call-icon-wrapper">
                                <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="white" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                                <path d="M22 16.92v3a2 2 0 0 1-2.18 2 19.79 19.79 0 0 1-8.63-3.07 19.5 19.5 0 0 1-6-6 19.79 19.79 0 0 1-3.07-8.67A2 2 0 0 1 4.11 2h3a2 2 0 0 1 2 1.72 12.84 12.84 0 0 0 .7 2.81 2 2 0 0 1-.45 2.11L8.09 9.91a16 16 0 0 0 6 6l1.27-1.27a2 2 0 0 1 2.11-.45 12.84 12.84 0 0 0 2.81.7A2 2 0 0 1 22 16.92z"></path>
                                </svg>
                                </div>
                                <div class="call-info">
                                <div class="call-title">${titleText}</div>
                                <div class="call-time" style="color: ${arrowColor === '#ff595a' ? '#ff595a' : '#aaa'};">${arrowHtml}${timeStr}${durationDisplay}</div>
                                </div>
                                </div>
                                `;
            }
            else {
                // Добавили класс "chat-link" и убрали target="_blank"
                let formattedText = m.txt.replace(/(https?:\/\/[^\s]+)/g, '<a href="$1" class="chat-link" style="color:#ffffff;text-decoration:underline;">$1</a>');

                // ВАЖНО: Добавили 'class' в ALLOWED_ATTR, иначе DOMPurify его удалит
                const safeHtml = (typeof DOMPurify !== 'undefined')
                    ? DOMPurify.sanitize(formattedText, { ALLOWED_TAGS: ['a'], ALLOWED_ATTR: ['href', 'style', 'class'] })
                    : formattedText;

                contentHtml += `<span class="msg-text">${safeHtml}</span>`;
            }

            // Мета-данные (Время + Галочки) (убираем их для звонков, так как они встроены в карточку)
            if (!m.sys && msgType !== 'call') {
                let metaStyle = "";
                if (msgType === 'image') {
                    // Для картинок мета-данные поверх изображения
                    metaStyle = "position: absolute; bottom: 8px; right: 8px; background: rgba(0,0,0,0.5); padding: 2px 8px; border-radius: 12px; backdrop-filter: blur(4px); z-index: 2;";
                    // Обертка для позиционирования
                    contentHtml = `<div style="position: relative; display: inline-block; vertical-align: top; min-width: 200px;">${contentHtml}`;
                }

                let metaHtml = `
                                <span class="msg-meta" style="${metaStyle}">
                                ${m.edited ? '<span style="font-size: 11px; color: rgba(255,255,255,0.6); margin-right: 5px;">изм.</span>' : ''}
                                <span class="msg-time" style="color: rgba(255,255,255,0.6); font-size: 11px;">${timeStr}</span>
                                ${m.from === currentUser.uid ? `<span class="msg-ticks" style="color: white; font-size: 12px; margin-left: 3px;">${ticksHtml}</span>` : ''}
                                </span>`;

                if (msgType === 'image') contentHtml += metaHtml + `</div>`;
                else contentHtml += metaHtml;
            }

            return contentHtml;
        }


        let closeChatTimeout = null;

        function performCloseUI() {
            closeAllSheets(); // <--- НОВОЕ: Принудительно закрываем все меню, блюр и шторки при выходе!
            document.getElementById('scrollToBottomBtn')?.classList.remove('visible');

            if (window.msgUnsub) {
                window.msgUnsub();
                window.msgUnsub = null;
            }

            if (closeChatTimeout) {
                clearTimeout(closeChatTimeout);
                closeChatTimeout = null;
            }

            if (window.innerWidth <= 768) {
                document.getElementById('mainChatArea').classList.remove('active');
                document.getElementById('mainSidebar').classList.remove('hidden-mobile');

                closeChatTimeout = setTimeout(() => {
                    document.getElementById('activeChat').classList.add('hidden');
                    document.getElementById('noChat').classList.remove('hidden');
                }, 350);
            } else {
                document.getElementById('mainSidebar').classList.remove('hidden-mobile');
                document.getElementById('mainChatArea').classList.remove('active');
                document.getElementById('activeChat').classList.add('hidden');
                document.getElementById('noChat').classList.remove('hidden');
            }

            if (currentChatId && currentUser) {
                db.collection('chats').doc(currentChatId).collection('typing').doc(currentUser.uid).set({
                    isTyping: false
                }).catch(() => { });
            }

            if (chatStatusUnsub) { chatStatusUnsub(); chatStatusUnsub = null; }
            if (typeof typingUnsub !== 'undefined' && typingUnsub) { typingUnsub(); typingUnsub = null; }

            currentFriendId = null;
            currentChatId = null;
        }
        // Обновленная функция отправки (принимает тип: 'text', 'image', 'file')
        function sendMsg(txt, isSys = false, type = 'text') {
            const inputEl = document.getElementById('msgInput');
            const t = txt || inputEl.value.trim();
            if (!t) return;

            // ========================================================
            // --- НОВОЕ: СБРОС СТАТУСА "ПЕЧАТАЕТ" ---
            // Сбрасываем таймер и статус в базе моментально при отправке
            if (typeof typingTimeout !== 'undefined' && typingTimeout) {
                clearTimeout(typingTimeout);
            }

            // Сбрасываем флаг и пишем в базу false
            if (typeof isTyping !== 'undefined') isTyping = false;

            if (currentChatId && currentUser) {
                db.collection('chats').doc(currentChatId).collection('typing').doc(currentUser.uid).set({
                    isTyping: false
                }).catch(() => { }); // Игнорируем ошибки (не критично)
            }
            // ========================================================


            // --- ЛОГИКА РЕДАКТИРОВАНИЯ ---
            if (isEditingMode && editMessageId) {
                db.collection('chats').doc(currentChatId).collection('msgs').doc(editMessageId).update({
                    txt: encryptText(t, currentChatId),
                    edited: true // Метка, что сообщение изменено
                }).then(() => {
                    cancelReplyOrEdit();
                });
                return; // Выходим, не создаем новое
            }

            // --- ОБЫЧНАЯ ОТПРАВКА ---
            const encryptedText = encryptText(t, currentChatId);

            const msgData = {
                txt: encryptedText, // В базу летит шифр
                from: currentUser.uid,
                to: currentFriendId,
                sys: isSys,
                type: type,
                read: false,
                ts: firebase.firestore.FieldValue.serverTimestamp()
            };

            // Если есть ответ на сообщение
            if (replyMessageData) {
                msgData.replyTo = {
                    id: replyMessageData.id,
                    name: replyMessageData.name,
                    text: replyMessageData.text
                };
                cancelReplyOrEdit(); // Сбрасываем ответ после отправки
            }

            db.collection('chats').doc(currentChatId).collection('msgs').add(msgData).then(() => {
                // Подстраховочный скролл после того, как сообщение появилось в базе
                if (currentMsgList) {
                    setTimeout(() => {
                        currentMsgList.scrollTo({ top: currentMsgList.scrollHeight + 500, behavior: 'smooth' });
                    }, 50);
                }
            });

            if (!txt) {
                inputEl.value = '';
                inputEl.style.height = '40px'; // Сброс высоты
                checkInputState(); // Обновление кнопок
                inputEl.focus();

                // --- НОВОЕ: Мгновенная плавная прокрутка вниз при отправке ---
                if (currentMsgList) {
                    currentMsgList.scrollTo({ top: currentMsgList.scrollHeight + 500, behavior: 'smooth' });
                }
            }
            // УВЕДОМЛЕНИЯ (БЕЗОПАСНО ЧЕРЕЗ СЕРВЕР)
            if (!isSys && currentFriendId) {
                sendNotificationSecure(currentFriendId, t, type);
            }
        }

        window.processNativeAction = async function (action, chatId, text) {
            console.log("[NOVOGRAM_LOG] [JS] Сработала processNativeAction! Action:", action, "ChatId:", chatId);

            // Мгновенно получаем ID из памяти, не дожидаясь загрузки Firebase
            const uid = currentUser ? currentUser.uid : localStorage.getItem('current_user_uid');
            console.log("[NOVOGRAM_LOG] [JS] Мой UID:", uid);

            if (!uid) {
                console.log("[NOVOGRAM_LOG] [JS] ОШИБКА: UID пользователя пустой, отмена!");
                return;
            }

            if (action === "MARK_READ") {
                console.log("[NOVOGRAM_LOG] [JS] Начинаю поиск непрочитанных сообщений в Firebase...");
                try {
                    const snap = await db.collection('chats').doc(chatId).collection('msgs')
                        .where('to', '==', uid)
                        .where('read', '==', false).get();

                    console.log("[NOVOGRAM_LOG] [JS] Найдено непрочитанных сообщений:", snap.size);

                    if (!snap.empty) {
                        const batch = db.batch();
                        snap.docs.forEach(d => batch.update(d.ref, { read: true }));
                        await batch.commit();
                        console.log("[NOVOGRAM_LOG] [JS] УСПЕХ! Сообщения помечены прочитанными в базе.");
                        showToast("Прочитано ✓");
                    } else {
                        console.log("[NOVOGRAM_LOG] [JS] Нечего помечать, все уже прочитано.");
                    }
                } catch (e) {
                    console.error("[NOVOGRAM_LOG] [JS] Ошибка работы с базой:", e);
                }
            }
            else if (action === "REPLY_MSG") {
                try {
                    const friendId = chatId.split('_').find(id => id !== uid);

                    // ВАЖНО: Убеждаемся, что ключ шифрования загрузился перед ответом
                    await fetchChatKey(chatId);

                    const encryptedText = encryptText(text, chatId);

                    await db.collection('chats').doc(chatId).collection('msgs').add({
                        txt: encryptedText,
                        from: uid,
                        to: friendId,
                        sys: false,
                        type: 'text',
                        read: false,
                        ts: firebase.firestore.FieldValue.serverTimestamp()
                    });

                    sendNotificationSecure(friendId, text, 'text');
                    showToast("Ответ отправлен ✓");
                } catch (e) { console.error("Ошибка быстрой отправки:", e); }
            }
        };
        let isEditingMode = false;
        let editMessageId = null;
        let replyMessageData = null; // { id, name, text }


        function openActionSheet(msgId, isMine) {
            selectedMsgId = msgId;
            selectedMsgIsMine = isMine;

            // Показываем/скрываем кнопку "Изменить"
            const editBtn = document.getElementById('btnEditMsg');
            if (isMine) {
                editBtn.style.display = 'flex';
            } else {
                editBtn.style.display = 'none';
            }

            document.getElementById('overlaySheet').style.display = 'block';
            setTimeout(() => { document.getElementById('actionSheet').classList.add('open'); }, 10);
        }

        // --- КОПИРОВАТЬ ---
        function handleCopy() {
            const msgEl = document.getElementById('msg-' + selectedMsgId);
            if (msgEl) {
                // Пытаемся найти текст сообщения (исключая мета-инфо и время)
                let text = "";
                const textSpan = msgEl.querySelector('.msg-text');
                if (textSpan) {
                    text = textSpan.innerText;
                } else {
                    // Если это просто текст без span
                    text = msgEl.innerText.replace(/\n\d{2}:\d{2}.*/s, ''); // Грубая очистка времени
                }

                navigator.clipboard.writeText(text).then(() => {
                    showToast("Текст скопирован");
                });
            }
            closeAllSheets();
        }


        // --- ОТВЕТИТЬ ---
        function handleReply() {
            const msgEl = document.getElementById('msg-' + selectedMsgId);
            if (!msgEl) return closeAllSheets();

            // Безопасное получение имени собеседника
            const chatTitleEl = document.getElementById('chatTitle');
            let friendName = chatTitleEl ? (chatTitleEl.firstElementChild ? chatTitleEl.firstElementChild.innerText : chatTitleEl.innerText) : "Собеседник";

            const name = selectedMsgIsMine ? "Вы" : friendName;

            // Получаем текст
            let text = "Вложение";
            const textSpan = msgEl.querySelector('.msg-text');
            if (textSpan) text = textSpan.innerText;
            else if (msgEl.querySelector('.chat-media-img')) text = "Фотография";
            else if (msgEl.querySelector('.chat-file-card')) text = "Файл";

            startReplyUI(selectedMsgId, name, text);
            closeAllSheets();
        }

        // --- ИЗМЕНИТЬ ---
        function handleEdit() {
            const msgEl = document.getElementById('msg-' + selectedMsgId);
            if (!msgEl) return closeAllSheets();

            let text = "";
            const textSpan = msgEl.querySelector('.msg-text');
            if (textSpan) text = textSpan.innerText;

            // Если это картинка, редактирование текста пока не делаем сложным
            if (!text && (msgEl.querySelector('img') || msgEl.querySelector('a'))) {
                alert("Редактирование медиа пока недоступно");
                return closeAllSheets();
            }

            startEditUI(selectedMsgId, text);
            closeAllSheets();
        }

        function startReplyUI(id, name, text) {
            cancelReplyOrEdit(); // Сброс
            replyMessageData = { id, name, text };

            const bar = document.getElementById('replyBar');
            const title = document.getElementById('replyTitle');
            const txt = document.getElementById('replyText');
            const icon = bar.querySelector('.reply-icon');

            bar.classList.remove('hidden', 'editing');
            title.innerText = name;
            txt.innerText = text;
            icon.innerText = "↩️";

            document.getElementById('msgInput').focus();
        }

        function startEditUI(id, text) {
            cancelReplyOrEdit(); // Сброс
            isEditingMode = true;
            editMessageId = id;

            const bar = document.getElementById('replyBar');
            const title = document.getElementById('replyTitle');
            const txt = document.getElementById('replyText');
            const icon = bar.querySelector('.reply-icon');
            const input = document.getElementById('msgInput');

            bar.classList.remove('hidden');
            bar.classList.add('editing'); // Синий цвет
            title.innerText = "Редактирование";
            txt.innerText = text;
            icon.innerText = "✏️";

            input.value = text;
            input.focus();
        }

        function cancelReplyOrEdit() {
            isEditingMode = false;
            editMessageId = null;
            replyMessageData = null;

            const bar = document.getElementById('replyBar');
            if (bar) bar.classList.add('hidden');

            const inp = document.getElementById('msgInput');
            inp.value = '';
            inp.style.height = '40px'; // <-- ДОБАВИТЬ ЭТУ СТРОЧКУ (Сброс высоты)
            checkInputState(); // <-- ДОБАВИТЬ ЭТУ СТРОЧКУ (Вернуть микрофон)
        }




        // Загрузка данных в поля при открытии профиля

        function closeAllSheets(fromPopState = false) {
            // Если кликнули по фону, а открыто сразу 2 или 3 окна (например, профиль -> настройки),
            // откатываем историю сразу на нужное количество шагов назад.
            if (fromPopState !== true && typeof sheetHistoryStack !== 'undefined' && sheetHistoryStack > 0) {
                const steps = -sheetHistoryStack;
                sheetHistoryStack = 0;
                history.go(steps);
            }

            document.getElementById('actionSheet')?.classList.remove('open');
            document.getElementById('deleteSheet')?.classList.remove('open');
            document.getElementById('profileSheet')?.classList.remove('open');
            document.getElementById('editProfileSheet')?.classList.remove('open');
            document.getElementById('generalSettingsSheet')?.classList.remove('open');

            const menu = document.getElementById('contextMenu');
            if (menu) {
                menu.classList.remove('active');
                setTimeout(() => menu.style.display = 'none', 200);
            }

            // --- ОТКЛЮЧАЕМ РАЗМЫТИЕ ФОНА И ВЫДЕЛЕНИЕ ---
            document.body.classList.remove('chat-blur-active');
            document.querySelectorAll('.msg-highlighted').forEach(el => {
                el.classList.remove('msg-highlighted');
            });

            setTimeout(() => {
                const overlay = document.getElementById('overlaySheet');
                if (overlay) {
                    overlay.style.display = 'none';
                    overlay.style.background = 'rgba(0,0,0,0.5)'; // Возвращаем стандартный цвет
                }
            }, 300);

            selectedMsgId = null;
        }
        function closeAllSheets() {
            document.getElementById('actionSheet')?.classList.remove('open');
            document.getElementById('deleteSheet')?.classList.remove('open');
            document.getElementById('profileSheet')?.classList.remove('open');
            document.getElementById('editProfileSheet')?.classList.remove('open');
            document.getElementById('friendProfileSheet')?.classList.remove('open');

            const menu = document.getElementById('contextMenu');
            if (menu) {
                menu.classList.remove('active');
                setTimeout(() => menu.style.display = 'none', 200);
            }

            // --- ОТКЛЮЧАЕМ РАЗМЫТИЕ ФОНА И ВЫДЕЛЕНИЕ ---
            document.body.classList.remove('chat-blur-active');
            document.querySelectorAll('.msg-highlighted').forEach(el => {
                el.classList.remove('msg-highlighted');
            });

            setTimeout(() => {
                const overlay = document.getElementById('overlaySheet');
                if (overlay) {
                    overlay.style.display = 'none';
                    overlay.style.background = 'rgba(0,0,0,0.5)'; // Возвращаем стандартный цвет для других шторок
                }
            }, 300);

            selectedMsgId = null;
        }



        function updateCallStatus(text) { document.getElementById('callStatusText').innerText = text; }
        function startTimer() {
            // Сбрасываем старый интервал, если был
            if (callTimerInt) clearInterval(callTimerInt);
            // Если время старта еще не записано — записываем сейчас
            if (!callStartTime) callStartTime = Date.now();
            const el = document.getElementById('callTimer');
            const tick = () => {
                // Считаем разницу между "сейчас" и "стартом"
                const diff = Math.max(0, Date.now() - callStartTime);
                const totalSeconds = Math.floor(diff / 1000);
                const mm = String(Math.floor(totalSeconds / 60)).padStart(2, '0');
                const ss = String(totalSeconds % 60).padStart(2, '0');
                el.innerText = `${mm}:${ss}`;
            };
            // Запускаем тиканье каждую секунду
            tick();
            callTimerInt = setInterval(tick, 1000);
        }
        function setupPeerConnection() {
            candidateQueue = [];
            console.log("🛠️ Создаем RTCPeerConnection...");
            pc = new RTCPeerConnection(dynamicIceServers);

            // СОЗДАЕМ ТРАНСИВЕРЫ (Слоты)
            // Аудио всегда работает, видео по умолчанию "inactive" (выключено и не светится)
            pc.addTransceiver('audio', { direction: 'sendrecv' });
            pc.addTransceiver('video', { direction: 'inactive' });

            pc.oniceconnectionstatechange = () => {
                console.log("📡 [ICE State]:", pc.iceConnectionState);
                if (pc.iceConnectionState === 'connected' || pc.iceConnectionState === 'completed') {
                    if (!isConnected) {
                        isConnected = true; wasCallConnected = true;
                        updateCallStatus("В разговоре"); stopAllTones(); startTimer(); startPing();
                    }
                } else if (pc.iceConnectionState === 'failed' || pc.iceConnectionState === 'disconnected') {
                    endCall(false);
                }
            };

            pc.ontrack = e => {
                console.log("🎥 Получен поток:", e.track.kind);
                const remoteVid = document.getElementById('remoteVideo');
                if (e.streams[0]) {
                    remoteVid.srcObject = e.streams[0];
                    remoteVid.play().catch(() => { });
                }
            };

            pc.onicecandidate = e => {
                if (e.candidate && currentCallId) {
                    const sessionRef = rtdb.ref('call_sessions/' + currentCallId);
                    const path = amICaller ? 'offerCandidates' : 'answerCandidates';
                    sessionRef.child(path).push(e.candidate.toJSON());
                }
            };
        }
        function startPing() {
            const el = document.getElementById('callPing');
            if (pingInterval) clearInterval(pingInterval);
            pingInterval = setInterval(async () => {
                if (!pc) return;
                const stats = await pc.getStats();
                let rtt = null;
                stats.forEach(r => {
                    if (r.type === 'candidate-pair' && r.state === 'succeeded' && r.currentRoundTripTime) { rtt = r.currentRoundTripTime; }
                });
                if (rtt) el.innerText = `Ping: ${(rtt * 1000).toFixed(0)} ms`;
            }, 2000);
        }
        async function addCandidateSafely(candidate) {
            if (!pc) return;
            try {
                if (pc.remoteDescription && pc.remoteDescription.type) {
                    await pc.addIceCandidate(new RTCIceCandidate(candidate));
                    console.log(`📥 [Кандидат ДОБАВЛЕН]: тип=${candidate.type}, IP=${candidate.address}`);
                } else {
                    console.log("⏳ [Кандидат В ОЧЕРЕДИ] Ждем RemoteDescription...");
                    candidateQueue.push(candidate);
                }
            } catch (e) {
                console.error("❌ Ошибка добавления ICE-кандидата:", e);
            }
        }
        async function flushCandidateQueue() {
            if (!pc) return;
            console.log(`🔄 [Очередь] Добавляем ${candidateQueue.length} кандидатов из очереди...`);
            for (const cand of candidateQueue) {
                try {
                    await pc.addIceCandidate(new RTCIceCandidate(cand));
                    console.log(`📥 [Кандидат из очереди ДОБАВЛЕН]: тип=${cand.type}`);
                } catch (e) { console.error("Ошибка кандидата из очереди", e); }
            }
            candidateQueue = [];
        }
        function setLocalMirror(facing) {
            const v = document.getElementById('localVideo');
            if (!v) return;
            if (facing === 'user') v.classList.add('mirror');
            else v.classList.remove('mirror');
        }
        async function getStreamForFacing(facing, withAudio) {
            const audio = !!withAudio;

            // Задаем идеальные параметры: 720p (HD) и 24-30 кадров в секунду (кинематографично и не сильно грузит сеть)
            const videoConstraints = {
                facingMode: { ideal: facing },
                width: { ideal: 1280 },
                height: { ideal: 720 },
                frameRate: { ideal: 24, max: 30 }
            };

            // 1) пробуем с нашими HD-настройками
            try {
                return await navigator.mediaDevices.getUserMedia({
                    audio: audio,
                    video: videoConstraints
                });
            } catch (e1) {
                console.warn("Не удалось получить 720p, пробуем стандартное разрешение...");
            }

            // 2) fallback: если камера телефона не поддерживает 720p или занята, берем что дадут
            try {
                return await navigator.mediaDevices.getUserMedia({
                    audio: audio,
                    video: { facingMode: { ideal: facing } }
                });
            } catch (e2) {
                // 3) самый жесткий fallback: через enumerateDevices (как было у тебя)
                const devices = await navigator.mediaDevices.enumerateDevices();
                const cams = devices.filter(d => d.kind === 'videoinput');
                if (!cams.length) throw e2;
                const cam = (facing === 'environment') ? cams[cams.length - 1] : cams[0];
                return await navigator.mediaDevices.getUserMedia({
                    audio: audio,
                    video: { deviceId: { exact: cam.deviceId } }
                });
            }
        }
        async function getMedia(requestVideo = false) {
            try {
                // 1. Сначала всегда запрашиваем только аудио, чтобы звонок начался
                const constraints = {
                    audio: true,
                    video: false
                };

                // Если мы явно хотим начать с видео (например, видеозвонок), меняем настройки
                if (requestVideo) {
                    constraints.video = {
                        facingMode: { ideal: currentFacingMode },
                        width: { ideal: 1280 },
                        height: { ideal: 720 }
                    };
                }

                localStream = await navigator.mediaDevices.getUserMedia(constraints);

                document.getElementById('localVideo').srcObject = localStream;
                document.getElementById('localVideo').muted = true;

                // Добавляем треки в PeerConnection
                localStream.getTracks().forEach(t => pc.addTrack(t, localStream));

                // Если видео не запрашивали, кнопка камеры должна быть в состоянии "выкл"
                if (!requestVideo) {
                    updateCamBtnUI(false);
                } else {
                    updateCamBtnUI(true);
                    setLocalMirror(currentFacingMode);
                }

            } catch (e) {
                console.error("🚨 Ошибка медиа:", e);
                throw e;
            }
        }

        // Базовый конфиг (пока грузятся мощные серверы, используем дефолтные от Google)
        // Базовый конфиг (пока не загрузится Google Script)
        let dynamicIceServers = {
            iceServers: [{ urls: 'stun:stun1.l.google.com:19302' }]
        };

        // Функция тихой загрузки серверов
        async function loadTurnServers() {
            try {
                console.log("📡 Запрашиваем TURN сервера через Google Script...");
                const response = await fetch(TURN_SCRIPT_URL, {
                    method: "POST",
                    redirect: "follow",
                    headers: { "Content-Type": "text/plain;charset=utf-8" },
                    body: JSON.stringify({
                        action: "getTurn",
                        secret: APP_SECRET_KEY
                    })
                });

                const data = await response.json();
                if (data.result === "success" && data.config) {
                    dynamicIceServers = data.config;
                    console.log("✅ TURN сервера успешно загружены!");
                }
            } catch (e) {
                console.error("❌ Не удалось загрузить TURN сервера:", e);
            }
        }

        async function switchCamera() {
            if (!pc || !localStream) return;

            // 1. Находим отправителя видео (Sender)
            const sender = pc.getSenders().find(s => s.track && s.track.kind === 'video');
            if (!sender) return;

            // Если был шаринг экрана — выключаем его правильно
            if (sender.track && sender.track.label && sender.track.label.toLowerCase().includes('screen')) {
                stopScreen(sender);
            }

            // 2. Находим старый видео-трек
            const oldVideoTrack = localStream.getVideoTracks()[0];

            // Запоминаем состояние (включено видео или выключено кнопкой)
            const wasEnabled = oldVideoTrack ? oldVideoTrack.enabled : true;

            // 3. Определяем следующую камеру
            const nextFacing = (currentFacingMode === 'user') ? 'environment' : 'user';

            // 4. ВАЖНО: Останавливаем ТОЛЬКО видео. Аудио не трогаем!
            if (oldVideoTrack) oldVideoTrack.stop();

            // 5. Получаем новый видео-поток (audio: false, так как микрофон у нас уже есть)
            let newStream;
            try {
                newStream = await getStreamForFacing(nextFacing, false);
            } catch (e) {
                console.error(e);
                alert("Не удалось переключить камеру");
                return;
            }

            const newVideoTrack = newStream.getVideoTracks()[0];
            newVideoTrack.enabled = wasEnabled; // Восстанавливаем состояние (если было выключено)

            // 6. Заменяем видео-трек в соединении (собеседник увидит новую камеру)
            try {
                await sender.replaceTrack(newVideoTrack);
            } catch (e) {
                console.error("Ошибка замены трека:", e);
            }

            // 7. Пересобираем локальный поток: БЕРЕМ СТАРЫЙ АУДИО + НОВОЕ ВИДЕО
            const audioTrack = localStream.getAudioTracks()[0]; // Живой аудио-трек
            localStream = new MediaStream(); // Новый объект потока

            if (audioTrack) {
                localStream.addTrack(audioTrack); // Возвращаем живой микрофон
            }
            localStream.addTrack(newVideoTrack);  // Добавляем новую камеру

            // 8. Обновляем <video> элемент на экране
            const videoEl = document.getElementById('localVideo');
            videoEl.srcObject = localStream;
            videoEl.muted = true; // Себя мы не слышим

            // 9. Обновляем переменные
            currentFacingMode = nextFacing;
            setLocalMirror(currentFacingMode);
        }
        async function startCall() {
            if (!currentFriendId || !currentUser) return;

            amICaller = true;
            isConnected = false;
            wasCallConnected = false;

            const sessionTs = Date.now();
            currentCallId = [currentUser.uid, currentFriendId].sort().join('_') + '_' + sessionTs;

            const callRef = rtdb.ref('incoming_calls/' + currentFriendId);
            const sessionRef = rtdb.ref('call_sessions/' + currentCallId);

            document.getElementById('callScreen').style.display = 'flex';
            updateCallStatus("Подготовка...");
            playConnectingTone();

            try {
                setupPeerConnection();

                sessionRef.child('answerCandidates').on('child_added', snap => {
                    addCandidateSafely(snap.val());
                });

                await getMedia(false); // Начинаем без камеры

                const offer = await pc.createOffer();
                await pc.setLocalDescription(offer);

                await sessionRef.set({
                    offer: { type: offer.type, sdp: offer.sdp },
                    caller: currentUser.uid,
                    callerName: usersCache[currentUser.uid]?.name || "Пользователь",
                    status: 'dialing',
                    ts: sessionTs
                });

                await callRef.set({
                    sessionId: currentCallId,
                    caller: currentUser.uid,
                    callerName: usersCache[currentUser.uid]?.name || "Пользователь",
                    ts: sessionTs,
                    status: 'ringing'
                });

                sessionRef.on('value', async snap => {
                    const data = snap.val();
                    if (!data) return;

                    if (data.status === 'rejected') {
                        updateCallStatus("Занято");
                        setTimeout(() => endCall(false, true), 1500);
                        return;
                    }

                    // Звонящий: если пришел Answer на любой наш Offer (хоть первый, хоть сотый)
                    if (data.answer && pc && pc.signalingState === "have-local-offer") {
                        console.log("✅ Получен ответ (Answer), применяем...");
                        await pc.setRemoteDescription(new RTCSessionDescription(data.answer));
                        await flushCandidateQueue();
                    }

                    // Звонящий: если вдруг ДРУГ инициировал обновление (включил камеру первым)
                    if (data.ts_offer && data.caller !== currentUser.uid && pc.signalingState === "stable") {
                        console.log("📥 Друг инициировал обновление, отвечаем...");
                        await pc.setRemoteDescription(new RTCSessionDescription(data.offer));
                        const answer = await pc.createAnswer();
                        await pc.setLocalDescription(answer);
                        sessionRef.update({ answer: { type: answer.type, sdp: answer.sdp }, ts_answer: Date.now() });
                    }
                });

            } catch (err) {
                console.error("Ошибка начала звонка:", err);
                endCall(true);
            }
        }
        async function answerCall() {
            document.getElementById('ringtone').pause();
            document.getElementById('incomingPopup').style.display = 'none';
            document.getElementById('callScreen').style.display = 'flex';
            updateCallStatus("Соединение...");

            if (!currentCallId) return;

            isConnected = false;
            wasCallConnected = false;
            amICaller = false;

            const sessionRef = rtdb.ref('call_sessions/' + currentCallId);
            rtdb.ref('incoming_calls/' + currentUser.uid).remove();

            try {
                const sessionSnap = await sessionRef.once('value');
                const callData = sessionSnap.val();

                if (!callData || !callData.offer) {
                    updateCallStatus("Звонок отменен");
                    setTimeout(() => endCall(false), 2000);
                    return;
                }

                setupPeerConnection();

                // --- ВОТ ТУТ ЛОГИКА ПЕРЕСОГЛАСОВАНИЯ (Renegotiation) ---
                sessionRef.on('value', async snap => {
                    const data = snap.val();
                    if (!data) return;

                    // Отвечающий: если пришел новый Offer (друг включил/выключил камеру)
                    // Мы реагируем, если версия оффера изменилась
                    if (data.ts_offer && data.caller !== currentUser.uid && pc.signalingState !== "have-local-offer") {
                        console.log("🔄 Получен новый Offer от друга, обновляемся...");
                        await pc.setRemoteDescription(new RTCSessionDescription(data.offer));
                        const answer = await pc.createAnswer();
                        await pc.setLocalDescription(answer);
                        sessionRef.update({ answer: { type: answer.type, sdp: answer.sdp }, ts_answer: Date.now() });
                        await flushCandidateQueue();
                    }

                    // Отвечающий: если мы сами инициировали обновление, ждем Answer от друга
                    if (data.ts_answer && pc.signalingState === "have-local-offer") {
                        console.log("✅ Наш ответ на включение камеры принят другом");
                        await pc.setRemoteDescription(new RTCSessionDescription(data.answer));
                    }
                });

                sessionRef.child('offerCandidates').on('child_added', snap => {
                    addCandidateSafely(snap.val());
                });

                await getMedia(false);

                await pc.setRemoteDescription(new RTCSessionDescription(callData.offer));
                await flushCandidateQueue();

                const answer = await pc.createAnswer();
                await pc.setLocalDescription(answer);

                await sessionRef.update({
                    answer: { type: answer.type, sdp: answer.sdp },
                    status: 'connected'
                });

            } catch (e) {
                console.error("Ошибка при ответе:", e);
                endCall(true);
            }
        }
        function toggleMic() {
            if (!localStream) return;
            const track = localStream.getAudioTracks()[0]; track.enabled = !track.enabled; updateMicBtnUI(track.enabled);
        }
        function updateMicBtnUI(enabled) {
            const btn = document.getElementById('btnMic');
            const iconOn = document.getElementById('iconMicOn');
            const iconOff = document.getElementById('iconMicOff');

            if (enabled) {
                btn.classList.remove('muted-state');
                iconOn.style.display = 'block';
                iconOff.style.display = 'none';
            } else {
                btn.classList.add('muted-state');
                iconOn.style.display = 'none';
                iconOff.style.display = 'block';
            }
        }
        async function toggleCamera() {
            if (!pc) return;
            const videoTransceiver = pc.getTransceivers().find(t => t.receiver.track.kind === 'video');
            if (!videoTransceiver) return;

            const currentTrack = localStream ? localStream.getVideoTracks()[0] : null;

            // ... внутри try ...
            const stream = await navigator.mediaDevices.getUserMedia({
                video: { facingMode: { ideal: currentFacingMode }, width: { ideal: 1280 }, height: { ideal: 720 } }
            });
            const newTrack = stream.getVideoTracks()[0];

            if (!localStream) localStream = new MediaStream();
            localStream.addTrack(newTrack);
            document.getElementById('localVideo').srcObject = localStream;

            // Активируем передачу
            videoTransceiver.direction = 'sendrecv';
            await videoTransceiver.sender.replaceTrack(newTrack);

            updateCamBtnUI(true);
            setLocalMirror(currentFacingMode);

            // Запускаем цикл обновления для друга
            setTimeout(() => handleRenegotiation(), 100);
        }

        

        async function handleRenegotiation() {
            if (!pc || !currentCallId) return;
            try {
                console.log("🔄 Генерируем новый Offer для обновления потока...");
                const offer = await pc.createOffer();
                await pc.setLocalDescription(offer);

                // Отправляем в базу. Поле ts_offer заставит другого участника сработать
                await rtdb.ref('call_sessions/' + currentCallId).update({
                    offer: { type: offer.type, sdp: offer.sdp },
                    ts_offer: Date.now()
                });
            } catch (e) {
                console.error("Ошибка Renegotiation:", e);
            }
        }
        function updateCamBtnUI(enabled) {
            const btn = document.getElementById('btnCam');
            const iconOn = document.getElementById('iconCamOn');
            const iconOff = document.getElementById('iconCamOff');

            if (enabled) {
                btn.classList.remove('muted-state');
                iconOn.style.display = 'block';
                iconOff.style.display = 'none';
            } else {
                btn.classList.add('muted-state');
                iconOn.style.display = 'none';
                iconOff.style.display = 'block';
            }
        }
        async function toggleScreen() {
            const isIOS = /iPad|iPhone|iPod/.test(navigator.userAgent) && !window.MSStream;
            if (isIOS) { alert("Демонстрация экрана не поддерживается на iPhone."); return; }
            if (!localStream) return;
            try {
                const stream = await navigator.mediaDevices.getDisplayMedia({ video: true });
                const screenTrack = stream.getVideoTracks()[0];
                const sender = pc.getSenders().find(s => s.track.kind === 'video');
                if (sender) {
                    sender.replaceTrack(screenTrack);
                    document.getElementById('localVideo').srcObject = stream;
                    const btn = document.getElementById('btnScr'); const lbl = document.getElementById('lblScr');
                    btn.classList.add('btn-screen-on'); lbl.innerText = 'Ост. стрим';
                    screenTrack.onended = () => stopScreen(sender);
                }
            } catch (e) { console.log(e); }
        }
        function stopScreen(sender) {
            const camTrack = localStream.getVideoTracks()[0];
            sender.replaceTrack(camTrack);
            document.getElementById('localVideo').srcObject = localStream;
            const btn = document.getElementById('btnScr'); const lbl = document.getElementById('lblScr');
            btn.classList.remove('btn-screen-on'); lbl.innerText = 'Экран';
        }
        function listenForIncomingCalls() {
            if (!currentUser) return;

            // Слушаем папку входящих звонков ИМЕННО ДЛЯ НАС
            const incomingRef = rtdb.ref('incoming_calls/' + currentUser.uid);

            incomingRef.on('value', snap => {
                const data = snap.val();

                if (!data) {
                    // Если данные удалили (кто-то сбросил или мы ответили) - прячем плашку
                    document.getElementById('incomingPopup').style.display = 'none';
                    document.getElementById('ringtone').pause();
                    return;
                }

                // Если звонок свежий (не старше 1 минуты)
                if (Date.now() - data.ts < 60000 && data.status === 'ringing') {
                    currentCallId = data.sessionId; // Берем ID сеанса

                    const popup = document.getElementById('incomingPopup');
                    popup.style.display = 'flex';
                    document.getElementById('callerName').innerText = data.callerName || "Входящий вызов";

                    document.getElementById('ringtone').play().catch((e) => console.log("Браузер заблокировал звук", e));
                } else {
                    document.getElementById('incomingPopup').style.display = 'none';
                    document.getElementById('ringtone').pause();
                }
            });
        }

        // --- ПРОФИЛЬ СОБЕСЕДНИКА ---
        function openFriendProfile() {
            if (!currentFriendId) return;

            // Записываем шаг в историю (для кнопки Назад)
            if (typeof sheetHistoryStack !== 'undefined') sheetHistoryStack++;
            history.pushState({ isSheet: true }, "", window.location.href);

            const sheet = document.getElementById('friendProfileSheet');
            sheet.style.display = 'flex';
            document.getElementById('overlaySheet').style.display = 'block';

            setTimeout(() => { sheet.classList.add('open'); }, 10);

            // Получаем данные друга из нашего кэша (он уже загружен при входе в чат)
            const uData = usersCache[currentFriendId] || {};

            // Имя и Фамилия
            const fullName = `${uData.name || ''} ${uData.surname || ''}`.trim() || uData.username || 'Пользователь';
            document.getElementById('friendProfileName').innerText = fullName;

            // Юзернейм
            const nick = uData.username ? `@${uData.username}` : 'Не указан';
            document.getElementById('friendProfileUsername').innerText = nick;

            // О себе
            document.getElementById('friendProfileBio').innerText = uData.bio || 'Информация не указана';

            // Статус (был(а) недавно / в сети)
            document.getElementById('friendProfileStatus').innerText = uData.lastSeen ? formatLastSeen(uData.lastSeen) : 'был(а) недавно';

            // Аватарка
            const img = document.getElementById('friendProfileAvatarPreview');
            const ph = document.getElementById('friendProfileAvatarPlaceholder');
            const wrap = document.getElementById('friendProfileAvatarWrap');

            if (uData.avatar) {
                img.src = uData.avatar;
                img.style.display = 'block';
                ph.style.display = 'none';
                wrap.style.pointerEvents = 'auto'; // Можно кликнуть, чтобы увеличить
            } else {
                img.src = '';
                img.style.display = 'none';
                ph.style.display = 'flex';
                ph.innerText = fullName.charAt(0).toUpperCase();
                wrap.style.pointerEvents = 'none'; // Не увеличиваем пустую аватарку
            }
        }

        function closeFriendProfile(fromPopState = false) {
            if (fromPopState !== true && typeof sheetHistoryStack !== 'undefined' && sheetHistoryStack > 0) {
                history.back();
                return;
            }
            document.getElementById('friendProfileSheet').classList.remove('open');

            // Плавно убираем полупрозрачный фон, если нет других открытых окон
            setTimeout(() => {
                if (!document.querySelector('.action-sheet.open')) {
                    document.getElementById('overlaySheet').style.display = 'none';
                }
            }, 300);
        }

        // Функция отклонения входящего вызова
        function rejectCall() {
            document.getElementById('ringtone').pause();
            document.getElementById('ringtone').currentTime = 0;
            document.getElementById('incomingPopup').style.display = 'none';

            // Удаляем уведомление, чтобы звонок перестал звенеть
            if (currentUser) {
                rtdb.ref('incoming_calls/' + currentUser.uid).remove();
            }

            if (currentCallId) {
                // Говорим звонящему, что мы сбросили трубку
                rtdb.ref('call_sessions/' + currentCallId).update({ status: 'rejected' });
                currentCallId = null;
            }
        }
        function endCallUser() { endCall(true, false); }
        function endCall(isInitiator = true, isRemote = false) {
            document.getElementById('ringtone').pause();
            document.getElementById('ringtone').currentTime = 0;
            stopAllTones();
            if (amICaller) {
                if (wasCallConnected && isConnected) {
                    const time = document.getElementById('callTimer').innerText;
                    sendMsg(`success|${time}`, false, 'call');
                } else if (!wasCallConnected) {
                    if (isInitiator && !isRemote) {
                        sendMsg(`canceled|00:00`, false, 'call');
                    } else {
                        sendMsg(`missed|00:00`, false, 'call');
                        if (currentFriendId) {
                            db.collection('users').doc(currentFriendId).get().then(doc => {
                                if (doc.exists && doc.data().tgChatId) {
                                    sendTelegramNotification(doc.data().tgChatId, `❌ *Пропущенный звонок*\nОт: ${currentUser.email}`);
                                }
                            });
                        }
                    }
                }
            }
            if (pc) pc.close();
            if (localStream) localStream.getTracks().forEach(t => t.stop());
            if (callTimerInt) clearInterval(callTimerInt);
            if (pingInterval) clearInterval(pingInterval);
            const statusText = document.getElementById('callStatusText');
            statusText.innerText = "ЗВОНОК ЗАВЕРШЕН"; statusText.style.color = "#ff4444"; statusText.style.fontWeight = "bold";
            playEndTone();
            const screen = document.getElementById('callScreen'); screen.style.pointerEvents = 'none';
            document.getElementById('incomingPopup').style.display = 'none';
            if (isInitiator && currentCallId) { db.collection('calls').doc(currentCallId).delete().catch(() => { }); }
            pc = null; localStream = null; candidateQueue = []; isConnected = false; currentCallId = null; wasCallConnected = false; amICaller = false;
            callStartTime = 0;
            if (callTimerInt) clearInterval(callTimerInt);
            callTimerInt = null;
            setTimeout(() => {
                screen.style.display = 'none';
                document.getElementById('callTimer').innerText = "00:00";
                document.getElementById('callPing').innerText = "Ping: -";
                statusText.style.color = "#ccc"; statusText.style.fontWeight = "normal";
            }, 1500);
        }
        function saveTgId() {
            const id = document.getElementById('tgChatId').value.trim();
            if (!id) return alert("Введите ID!");
            if (currentUser) {
                db.collection('users').doc(currentUser.uid).set({ tgChatId: id }, { merge: true }).then(() => {
                    alert("ID сохранен!");
                    sendTelegramNotification(id, "✅ Уведомления подключены успешно!");
                });
            }
        }
        function loadTgId() {
            if (currentUser) {
                db.collection('users').doc(currentUser.uid).get().then(doc => {
                    if (doc.exists && doc.data().tgChatId) { document.getElementById('tgChatId').value = doc.data().tgChatId; }
                });
            }
        }

        // --- ЛОГИКА ПРОФИЛЯ ---
        // Валидация никнейма (только англ, цифры, _ и .)
        function validateUsername(input) {
            input.value = input.value.replace(/[^a-zA-Z0-9_.]/g, '');
        }
        // Обработка выбора фото
        // --- ГЛОБАЛЬНАЯ ПЕРЕМЕННАЯ ДЛЯ ССЫЛКИ НА ФОТО (Вставь перед функциями) ---
        let newUploadedAvatarUrl = null;

        // --- 1. НОВАЯ ФУНКЦИЯ ВЫБОРА И ЗАГРУЗКИ ФОТО ---
        function handleAvatarSelect(input) {
            const file = input.files[0];
            if (!file) return;

            // 1. Блокируем кнопку сохранения и показываем часы
            const saveBtn = document.querySelector('#editProfileSheet .tg-header-top button:last-child');
            if (saveBtn) {
                saveBtn.style.opacity = "0.5";
                saveBtn.style.pointerEvents = "none";
                saveBtn.innerHTML = "⏳";
            }

            const reader = new FileReader();
            reader.onload = function (e) {
                const img = new Image();
                img.src = e.target.result;
                img.onload = function () {
                    // --- НАСТРОЙКИ КАЧЕСТВА (Высокое) ---
                    const canvas = document.createElement('canvas');
                    let width = img.width;
                    let height = img.height;

                    // Ставим 1024px (было 300) - это хорошее качество
                    const MAX = 1024;

                    if (width > height) {
                        if (width > MAX) { height *= MAX / width; width = MAX; }
                    } else {
                        if (height > MAX) { width *= MAX / height; height = MAX; }
                    }

                    canvas.width = width;
                    canvas.height = height;
                    const ctx = canvas.getContext('2d');
                    ctx.drawImage(img, 0, 0, width, height);

                    // Качество 0.9 (90%)
                    const highResBase64 = canvas.toDataURL('image/jpeg', 0.9);

                    // 2. Показываем превью сразу (чтобы юзер видел, что выбрал)
                    const preview = document.getElementById('editAvatarPreview');
                    const ph = document.getElementById('editAvatarPlaceholder');
                    preview.src = highResBase64;
                    preview.style.display = 'block';
                    ph.style.display = 'none';

                    // 3. !!! ОТПРАВЛЯЕМ НА ГУГЛ ДИСК !!!
                    const rawBase64 = highResBase64.split(',')[1];

                    // Используем твою ссылку на скрипт (она уже должна быть в коде выше)
                    fetch(GOOGLE_SCRIPT_URL, {
                        method: "POST",
                        redirect: "follow",
                        headers: { "Content-Type": "text/plain;charset=utf-8" },
                        body: JSON.stringify({
                            action: "upload",
                            secret: "JH54jnbdfkjs297615109dxc1kDmnsg_df1jksHnh1Lhsc",
                            filename: "avatar_" + Date.now() + ".jpg",
                            mimeType: "image/jpeg",
                            base64: rawBase64
                        })
                    })
                        .then(res => res.json())
                        .then(data => {
                            if (data.result === "success") {
                                console.log("Аватар загружен:", data.url);
                                newUploadedAvatarUrl = data.url; // <--- ЗАПОМИНАЕМ ССЫЛКУ С ДИСКА
                                showToast("Фото загружено в облако ✓");
                            } else {
                                alert("Ошибка Google Диска: " + data.message);
                            }
                        })
                        .catch(err => {
                            console.error("Ошибка сети:", err);
                            alert("Не удалось загрузить фото. Проверьте интернет.");
                        })
                        .finally(() => {
                            // 4. Разблокируем кнопку сохранения
                            if (saveBtn) {
                                saveBtn.style.opacity = "1";
                                saveBtn.style.pointerEvents = "auto";
                                // Возвращаем галочку
                                saveBtn.innerHTML = '<svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><polyline points="20 6 9 17 4 12" /></svg>';
                            }
                        });
                }
            };
            reader.readAsDataURL(file);
        }

        // --- 2. НОВАЯ ФУНКЦИЯ СОХРАНЕНИЯ ПРОФИЛЯ ---
        function saveEditProfile() {
            const name = document.getElementById('editName').value.trim();
            if (!name) {
                showToast('Имя обязательно!');
                return;
            }

            const surname = document.getElementById('editSurname').value.trim();
            const bio = document.getElementById('editBio').value.trim();
            const birthdate = document.getElementById('editBirthdate').value;
            const username = document.getElementById('editUsername').value.trim();

            const updateData = {
                name: name,
                surname: surname,
                bio: bio,
                birthdate: birthdate,
                username: username
            };

            // !!! ЕСЛИ ЕСТЬ ССЫЛКА НА ГУГЛ ДИСК - СОХРАНЯЕМ ЕЁ !!!
            if (newUploadedAvatarUrl) {
                updateData.avatar = newUploadedAvatarUrl;
            }

            const user = firebase.auth().currentUser;
            db.collection('users').doc(user.uid).update(updateData)
                .then(() => {
                    // Обновляем данные на экране мгновенно
                    const nameInput = document.getElementById('profileName');
                    if (nameInput) nameInput.value = name;

                    const surInput = document.getElementById('profileSurname');
                    if (surInput) {
                        if (surname) {
                            surInput.value = surname;
                            surInput.style.display = "block";
                        } else {
                            surInput.style.display = "none";
                        }
                    }

                    const bioInput = document.getElementById('profileBio');
                    if (bioInput) bioInput.value = bio;

                    const nickDiv = document.getElementById('profileUsername');
                    if (nickDiv) nickDiv.innerText = username ? username : '';

                    // Если загрузили новую аватарку - обновляем её везде
                    if (newUploadedAvatarUrl) {
                        const myAvatarSmall = document.getElementById('myAvatarSmall');
                        if (myAvatarSmall) myAvatarSmall.innerHTML = `<img src="${newUploadedAvatarUrl}" style="width:100%;height:100%;border-radius:50%;object-fit:cover;">`;

                        const pImg = document.getElementById('profileAvatarPreview');
                        if (pImg) {
                            pImg.src = newUploadedAvatarUrl;
                            pImg.style.display = 'block';
                        }
                        const pPh = document.getElementById('profileAvatarPlaceholder');
                        if (pPh) pPh.style.display = 'none';

                        // Сбрасываем ссылку
                        newUploadedAvatarUrl = null;
                        if (typeof editAvatarBase64 !== 'undefined') editAvatarBase64 = null;
                    }

                    // Обновляем дату рождения
                    const birthDisplay = document.getElementById('displayBirthdate');
                    const birthBlock = document.getElementById('birthdateBlock');
                    if (birthdate) {
                        const parts = birthdate.split('-');
                        if (parts.length === 3 && birthDisplay) {
                            birthDisplay.innerText = `${parts[2]}.${parts[1]}.${parts[0]}`;
                            if (birthBlock) birthBlock.style.display = 'flex';
                        }
                    } else {
                        if (birthBlock) birthBlock.style.display = 'none';
                    }

                    showToast('Профиль обновлен');
                    closeEditProfile();
                })
                .catch(err => {
                    console.error(err);
                    showToast('Ошибка сохранения: ' + err.message);
                });
        }
        // Функция сохранения профиля
        async function saveProfile() {
            const name = document.getElementById('profileName').value.trim();
            const surname = document.getElementById('profileSurname').value.trim();
            const bio = document.getElementById('profileBio').value.trim();

            if (!name) {
                showToast("Имя не может быть пустым");
                return;
            }

            const updateData = {
                name: name,
                surname: surname,
                bio: bio
            };

            if (currentAvatarBase64) {
                updateData.avatar = currentAvatarBase64;
            }

            db.collection('users').doc(currentUser.uid).set(updateData, { merge: true })
                .then(() => {
                    showToast("Сохранено ✓");
                    closeAllSheets();
                })
                .catch(err => {
                    console.error(err);
                    showToast("Ошибка сохранения");
                });
        }

        // 3. Функция копирования
        function copyData(elementId, label) {
            const el = document.getElementById(elementId);
            if (el && el.innerText && el.innerText.trim() !== '' && el.innerText !== '@не_задан') {
                const text = el.innerText;

                navigator.clipboard.writeText(text).then(() => {
                    showToast(`${label} скопирован`);
                }).catch(err => {
                    console.error('Не удалось скопировать', err);
                });
            }
        }

        // 4. Уведомление
        function showToast(message) {
            const toast = document.getElementById('toast-notification');
            toast.innerText = message;
            toast.classList.add('show');

            setTimeout(() => {
                toast.classList.remove('show');
            }, 2000);
        }

        let sheetHistoryStack = 0; // Счетчик открытых окон для кнопки Назад

        // Загрузка данных в поля при открытии профиля
        function openProfileSheet() {
            // --- НОВОЕ: Записываем открытие в историю браузера ---
            sheetHistoryStack++;
            history.pushState({ isSheet: true }, "", window.location.href);

            document.getElementById('overlaySheet').style.display = 'block';
            const sheet = document.getElementById('profileSheet');
            setTimeout(() => sheet.classList.add('open'), 10);

            if (!currentUser) return;

            db.collection('users').doc(currentUser.uid).get().then(doc => {
                if (doc.exists) {
                    const d = doc.data();

                    // Email (Текст)
                    const emailEl = document.getElementById('profileEmail');
                    if (emailEl) emailEl.innerText = d.email;

                    // Username (Текст) - ИСПРАВЛЕНО
                    const usernameDiv = document.getElementById('profileUsername');
                    if (usernameDiv) {
                        // Если юзернейм есть в базе, ставим его, иначе заглушку
                        usernameDiv.innerText = d.username ? '@' + d.username : '@не_задан';
                    }

                    // Имя и Фамилия (Input)
                    document.getElementById('profileName').value = d.name || '';
                    document.getElementById('profileSurname').value = d.surname || '';

                    // О себе (Textarea)
                    const bioArea = document.getElementById('profileBio');
                    if (bioArea) {
                        bioArea.value = d.bio || '';
                        // Авто-подстройка высоты
                        bioArea.style.height = 'auto';
                        bioArea.style.height = bioArea.scrollHeight + 'px';
                    }

                    // Дата рождения
                    const birthInput = document.getElementById('profileBirthdate');
                    const birthDisplay = document.getElementById('displayBirthdate');
                    const birthBlock = document.getElementById('birthdateBlock');

                    if (d.birthdate) {
                        birthInput.value = d.birthdate;
                        // Красивый формат ДД.ММ.ГГГГ
                        const parts = d.birthdate.split('-');
                        if (parts.length === 3) {
                            birthDisplay.innerText = `${parts[2]}.${parts[1]}.${parts[0]}`;
                        } else {
                            birthDisplay.innerText = d.birthdate;
                        }
                        birthBlock.style.display = 'flex';
                    } else {
                        birthInput.value = '';
                        birthDisplay.innerText = '';
                        birthBlock.style.display = 'none';
                    }

                    // Аватарка
                    const img = document.getElementById('profileAvatarPreview');
                    const ph = document.getElementById('profileAvatarPlaceholder');

                    if (d.avatar) {
                        img.src = d.avatar;
                        img.style.display = 'block';
                        ph.style.display = 'none';
                    } else {
                        img.style.display = 'none';
                        ph.style.display = 'flex';
                    }
                }
            });
        }

        // --- ЕДИНЫЙ ОБРАБОТЧИК ESC ---
        document.addEventListener('keydown', function (e) {
            if (e.key === "Escape") {
                const viewer = document.getElementById('imageViewer');
                const searchRes = document.getElementById('searchResults');
                const searchInp = document.getElementById('searchInput');

                // 1. САМЫЙ ВЫСОКИЙ ПРИОРИТЕТ: Закрыть просмотр картинки
                if (viewer.classList.contains('active')) {
                    closeImageViewer();
                    return;
                }

                // 2. ЗАКРЫТЬ ШТОРКИ ПРОФИЛЯ/НАСТРОЕК (По очереди сверху вниз)
                if (document.getElementById('editProfileSheet')?.classList.contains('open')) {
                    closeEditProfile();
                    return;
                }
                if (document.getElementById('generalSettingsSheet')?.classList.contains('open')) {
                    closeGeneralSettings();
                    return;
                }
                if (document.getElementById('profileSheet')?.classList.contains('open')) {
                    closeAllSheets();
                    return;
                }

                // 3. ЗАКРЫТЬ ПОИСК
                if (searchRes.classList.contains('active') || searchInp.value.trim() !== '' || document.activeElement === searchInp) {
                    e.preventDefault();
                    closeSearch();
                    return;
                }

                // 4. НИЗКИЙ ПРИОРИТЕТ: Закрыть чат
                if (currentChatId) {
                    closeChat();
                    return;
                }
            }
        });
        const msgInput = document.getElementById('msgInput');
        const sendBtn = document.getElementById('sendBtn');
        const voiceBtn = document.querySelector('.voice-btn');

        msgInput.addEventListener('focus', () => {
            if (currentMsgList) {
                // Задержка 300мс нужна, чтобы iOS/Android физически успели выдвинуть клавиатуру
                setTimeout(() => {
                    currentMsgList.scrollTop = currentMsgList.scrollHeight + 500;
                }, 300);
            }
        });

        // 2. Самый надежный современный метод: отслеживаем изменение видимой области (VisualViewport API)
        // Срабатывает в ту же миллисекунду, когда клавиатура меняет размер экрана
        if (window.visualViewport) {
            window.visualViewport.addEventListener('resize', () => {
                // Скроллим только если мы в чате и поле ввода активно
                if (currentMsgList && document.activeElement === msgInput) {
                    currentMsgList.scrollTop = currentMsgList.scrollHeight + 500;
                }
            });
        } else {
            // Запасной вариант для старых браузеров
            window.addEventListener('resize', () => {
                if (currentMsgList && document.activeElement === msgInput) {
                    currentMsgList.scrollTop = currentMsgList.scrollHeight + 500;
                }
            });
        }




        // --- АВТОПОВОРОТ ОКОШКА СВОЕГО ВИДЕО ---
        // --- PIP: drag + resize (красиво и без багов) ---
        const localVidEl = document.getElementById('localVideo');
        const pipEl = document.getElementById('localPip');              // новый id
        const gridEl = document.querySelector('.video-grid');
        const controlsEl = document.querySelector('.controls');
        const resizeHandleEl = pipEl.querySelector('.pip-resize-handle');
        const PIP_STORAGE_KEY = 'pipState_v3';
        let pipRatio = 2 / 3;      // width/height, дефолт как у тебя 140x210
        let pipUserSized = false;  // станет true после ручного ресайза
        function clamp(v, min, max) { return Math.max(min, Math.min(max, v)); }
        function getBounds() {
            const gridRect = gridEl.getBoundingClientRect();
            const controlsRect = controlsEl.getBoundingClientRect();
            const margin = 12;
            // bottomLimit: не даём залезать под controls (они absolute и перекрывают низ)
            const bottomLimit = Math.min(gridRect.bottom, controlsRect.top) - gridRect.top - margin;
            return {
                minLeft: margin,
                minTop: margin,
                maxLeft: gridRect.width - margin,
                maxTop: bottomLimit
            };
        }
        function readPipRect() {
            return {
                left: parseFloat(pipEl.style.left || '0'),
                top: parseFloat(pipEl.style.top || '0'),
                width: parseFloat(pipEl.style.width || pipEl.offsetWidth),
                height: parseFloat(pipEl.style.height || pipEl.offsetHeight)
            };
        }
        function applyPipRect(rect, { save = true } = {}) {
            const b = getBounds();
            const minW = 110;
            const maxW = Math.max(minW, b.maxLeft - b.minLeft);
            const width = clamp(rect.width, minW, maxW);
            // высоту держим по ratio (чтобы не растягивалось)
            const height = Math.max(90, Math.round(width / pipRatio));
            const maxLeft = Math.max(b.minLeft, b.maxLeft - width);
            const maxTop = Math.max(b.minTop, b.maxTop - height);
            const left = clamp(rect.left, b.minLeft, maxLeft);
            const top = clamp(rect.top, b.minTop, maxTop);
            // важное: переходим на left/top, чтобы drag/resize были предсказуемыми
            pipEl.style.left = `${Math.round(left)}px`;
            pipEl.style.top = `${Math.round(top)}px`;
            pipEl.style.right = 'auto';
            pipEl.style.bottom = 'auto';
            pipEl.style.width = `${Math.round(width)}px`;
            pipEl.style.height = `${Math.round(height)}px`;
            if (save) {
                const state = { left: Math.round(left), top: Math.round(top), width: Math.round(width), ratio: pipRatio, userSized: pipUserSized };
                localStorage.setItem(PIP_STORAGE_KEY, JSON.stringify(state));
            }
        }
        function setDefaultPip() {
            const gridRect = gridEl.getBoundingClientRect();
            const controlsRect = controlsEl.getBoundingClientRect();
            const controlsH = Math.max(0, gridRect.bottom - controlsRect.top);
            const defW = (pipRatio >= 1) ? 210 : 140;   // похоже на твою текущую логику landscape [по смыслу]
            const left = gridRect.width - defW - 20;
            const top = gridRect.height - controlsH - Math.round(defW / pipRatio) - 160; // твой bottom:160 [по смыслу]
            pipUserSized = false;
            applyPipRect({ left, top, width: defW, height: defW / pipRatio }, { save: true });
        }
        function loadPipState() {
            try {
                const raw = localStorage.getItem(PIP_STORAGE_KEY);
                if (!raw) return false;
                const s = JSON.parse(raw);
                if (typeof s.ratio === 'number' && isFinite(s.ratio) && s.ratio > 0.1) pipRatio = s.ratio;
                pipUserSized = !!s.userSized;
                applyPipRect({ left: s.left ?? 0, top: s.top ?? 0, width: s.width ?? 140, height: 0 }, { save: false });
                return true;
            } catch (_) {
                return false;
            }
        }
        function updateRatioFromVideo() {
            if (localVidEl.videoWidth && localVidEl.videoHeight) {
                const w = localVidEl.videoWidth;
                const h = localVidEl.videoHeight;
                // Логика: если видео широкое (ПК) -> делаем вертикальное окно (2:3)
                // Если видео высокое (Телефон) -> оставляем как есть
                if (w > h) {
                    pipRatio = 2 / 3;
                } else {
                    pipRatio = w / h;
                }
                // Вычисляем новые размеры
                let currentWidth = parseFloat(pipEl.style.width) || 140;
                let newHeight = currentWidth / pipRatio;
                // Защита от глюков: если высота получилась слишком маленькой, исправляем
                if (newHeight < 100) newHeight = currentWidth * 1.5;
                applyPipRect({ width: currentWidth, height: newHeight }, true);
            }
        }
        // 1) Инициализация позиции/размера
        (function initPip() {
            // превращаем текущие bottom/right (из CSS) в left/top, чтобы дальше было стабильно
            // если есть сохранение — оно главнее
            const hasState = loadPipState();
            if (!hasState) setDefaultPip();
            // поддержка авто-ориентации без дерганий
            localVidEl.addEventListener('loadedmetadata', () => {
                updateRatioFromVideo();
                // если пользователь не менял размер — можно поставить дефолт под ориентацию
                if (!pipUserSized) setDefaultPip();
            });
            // когда меняется viewport (поворот/resize окна) — просто зажимаем в границы
            window.addEventListener('resize', () => applyPipRect(readPipRect(), { save: true }));
        })();
        // 2) Drag
        let drag = null;
        pipEl.addEventListener('pointerdown', (e) => {
            if (e.button !== 0) return;
            if (e.target === resizeHandleEl) return; // resize отдельно
            e.preventDefault();
            pipEl.classList.add('dragging');
            pipEl.setPointerCapture(e.pointerId);
            const r = readPipRect();
            drag = {
                id: e.pointerId,
                startX: e.clientX,
                startY: e.clientY,
                startLeft: r.left,
                startTop: r.top,
                width: r.width,
                height: r.height
            };
        });
        pipEl.addEventListener('pointermove', (e) => {
            if (!drag || drag.id !== e.pointerId) return;
            const dx = e.clientX - drag.startX;
            const dy = e.clientY - drag.startY;
            applyPipRect({
                left: drag.startLeft + dx,
                top: drag.startTop + dy,
                width: drag.width,
                height: drag.height
            }, { save: false });
        });
        pipEl.addEventListener('pointerup', (e) => {
            if (!drag || drag.id !== e.pointerId) return;
            pipEl.classList.remove('dragging');
            drag = null;
            applyPipRect(readPipRect(), { save: true });
        });
        // 3) Resize (с сохранением aspect ratio)
        let resize = null;
        resizeHandleEl.addEventListener('pointerdown', (e) => {
            if (e.button !== 0) return;
            e.preventDefault();
            pipEl.classList.add('resizing');
            pipEl.setPointerCapture(e.pointerId);
            const r = readPipRect();
            resize = {
                id: e.pointerId,
                startX: e.clientX,
                startY: e.clientY,
                startW: r.width,
                startLeft: r.left,
                startTop: r.top
            };
        });
        pipEl.addEventListener('pointermove', (e) => {
            if (!resize || resize.id !== e.pointerId) return;
            const dx = e.clientX - resize.startX;
            const dy = e.clientY - resize.startY;
            // берём “наиболее сильное” диагональное изменение
            const grow = Math.max(dx, dy * pipRatio);
            const newW = resize.startW + grow;
            pipUserSized = true;
            applyPipRect({
                left: resize.startLeft,
                top: resize.startTop,
                width: newW,
                height: 0
            }, { save: false });
        });
        pipEl.addEventListener('pointerup', (e) => {
            if (!resize || resize.id !== e.pointerId) return;
            pipEl.classList.remove('resizing');
            resize = null;
            applyPipRect(readPipRect(), { save: true });
        });
        // 4) Быстрый сброс (двойной клик / двойной тап)
        pipEl.addEventListener('dblclick', () => setDefaultPip());
        // Слушаем события изменения размеров видео
        localVidEl.addEventListener('loadedmetadata', checkLocalVideoOrientation);
        localVidEl.addEventListener('resize', checkLocalVideoOrientation);
        function isMobileDevice() {
            return /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent);
        }

        function checkLocalVideoOrientation() {
            if (!localStream) return;
            const videoTrack = localStream.getVideoTracks()[0];
            if (videoTrack) {
                const settings = videoTrack.getSettings();
                // Логика ориентации, если нужна, или просто заглушка, чтобы не падало
                console.log("Orientation check:", settings.width, settings.height);
            }
        }
        function updateCallControlsVisibility() {
            const isMobile = isMobileDevice();
            // Ищем кнопки
            const btnFlip = document.getElementById('btnFlip');
            const btnScr = document.getElementById('btnScr');
            // Ищем их родительские .control-item
            const flipItem = btnFlip ? btnFlip.closest('.control-item') : null;
            const scrItem = btnScr ? btnScr.closest('.control-item') : null;
            // Применяем класс скрытия:
            // - Демонстрация экрана (btnScr) скрыта на телефоне
            // - Переключение камеры (btnFlip) скрыто на ПК
            if (scrItem) {
                if (isMobile) {
                    scrItem.classList.add('control-item-hidden');
                } else {
                    scrItem.classList.remove('control-item-hidden');
                }
            }
            if (flipItem) {
                if (isMobile) {
                    flipItem.classList.remove('control-item-hidden');
                } else {
                    flipItem.classList.add('control-item-hidden');
                }
            }
            console.log('[updateCallControls] isMobile:', isMobile, '| scrItem скрыта:', scrItem?.classList.contains('control-item-hidden'), '| flipItem скрыта:', flipItem?.classList.contains('control-item-hidden'));
        }
    </script>
    <!-- OneSignal Push Logic (Вставь это в самый низ перед </body>) -->
    <script>
        // 1. Инициализация и сохранение ID пользователя
        window.OneSignalDeferred = window.OneSignalDeferred || [];
        OneSignalDeferred.push(function (OneSignal) {
            OneSignal.init({
                appId: "6af8818f-ba3a-40c4-b820-5235c1d73925", // Твой App ID
            });
            function savePlayerId() {
                if (OneSignal.User.PushSubscription.optedIn) {
                    const oneSignalId = OneSignal.User.PushSubscription.id;
                    const user = firebase.auth().currentUser;
                    if (user && oneSignalId) {
                        console.log("Сохраняем OneSignal ID:", oneSignalId);
                        db.collection('users').doc(user.uid).update({ oneSignalId: oneSignalId }).catch(e => { });
                    }
                }
            }
            OneSignal.User.PushSubscription.addEventListener("change", savePlayerId);
            firebase.auth().onAuthStateChanged(u => { if (u) setTimeout(savePlayerId, 3000); });

            OneSignal.Notifications.addEventListener("click", async (event) => {
                const action = event.result.actionId; // ID нажатой кнопки
                const data = event.notification.additionalData; // Данные чата

                if (!data || !data.chatId) return;

                if (action === "read") {
                    // Кнопка "Прочитать": отмечаем сообщения прочитанными в фоне
                    const user = firebase.auth().currentUser;
                    if (user) {
                        const snap = await db.collection('chats').doc(data.chatId).collection('msgs')
                            .where('to', '==', user.uid).where('read', '==', false).get();
                        const batch = db.batch();
                        snap.docs.forEach(d => batch.update(d.ref, { read: true }));
                        await batch.commit();
                        showToast("Сообщения прочитаны");
                    }
                } else {
                    // Клик по самому пушу или кнопке "Ответить" - открываем чат
                    window.location.hash = "#chat/" + data.senderId;
                }
            });
        });

        function closeLogoutModal() {
            // Закрываем модалку
            document.getElementById('logoutModalOverlay').style.display = 'none';
        }
        async function confirmLogout() {
            closeLogoutModal(); // Сразу прячем окно

            const user = firebase.auth().currentUser;
            if (user) {
                try {
                    // Стираем токены из базы, чтобы не приходили чужие пуши
                    await db.collection('users').doc(user.uid).update({
                        fcmToken: firebase.firestore.FieldValue.delete(),
                        oneSignalId: firebase.firestore.FieldValue.delete(),
                        lastSeen: firebase.firestore.FieldValue.serverTimestamp()
                    });
                } catch (e) {
                    console.error("Ошибка при удалении токенов:", e);
                }
            }

            // Чистим локальные метки входа
            localStorage.removeItem('isLoggedIn');
            localStorage.removeItem('current_user_uid');

            // Разлогиниваемся
            auth.signOut().then(() => {
                window.location.reload();
            });
        }

        function logout() {
            // Открываем нашу новую красивую модалку
            document.getElementById('logoutModalOverlay').style.display = 'flex';
        }
        // === РОУТЕР (НАВИГАЦИЯ) ===
        // 1. Слушаем изменения в адресной строке (например, кнопка Назад)
        window.addEventListener('hashchange', handleHashChange);
        async function handleHashChange() {
            const hash = window.location.hash;
            // Если ссылка пустая (мы в списке чатов)
            if (!hash || hash === '#') {
                performCloseUI();
                return;
            }
            // Если ссылка вида #chat/USER_ID
            if (hash.startsWith('#chat/')) {
                const userId = hash.replace('#chat/', '');

                // Если мы уже в этом чате, ничего не делаем
                if (currentFriendId === userId) return;

                if (!currentUser) return;

                // Пытаемся найти в кэше или загрузить из базы
                let userData = usersCache[userId];
                if (!userData) {
                    try {
                        document.getElementById('mainChatArea').classList.add('active');
                        document.getElementById('noChat').classList.add('hidden');
                        document.getElementById('activeChat').classList.remove('hidden');
                        document.getElementById('chatTitle').innerText = "Загрузка...";

                        const doc = await db.collection('users').doc(userId).get();
                        if (doc.exists) {
                            userData = doc.data();
                            usersCache[userId] = userData;
                        }
                    } catch (e) {
                        console.error("Ошибка роутера", e);
                    }
                }

                if (userData) {
                    // Склеиваем имя и фамилию для шапки чата
                    const name = getDisplayName(userId, userData);

                    currentFriendId = userId;
                    currentChatId = [currentUser.uid, userId].sort().join('_');

                    // --- ВАЖНО: Загружаем ключи шифрования при обновлении страницы ---
                    fetchChatKey(currentChatId);


                    if (window.innerWidth <= 768) {
                        // Плавно прячем список контактов
                        document.getElementById('mainSidebar').classList.add('hidden-mobile');
                        // Плавно выдвигаем чат
                        document.getElementById('mainChatArea').classList.add('active');
                    }

                    document.getElementById('noChat').classList.add('hidden');
                    const activeChatElement = document.getElementById('activeChat');
                    activeChatElement.classList.remove('hidden');

                    // Красивая анимация для ПК
                    if (window.innerWidth > 768) {
                        activeChatElement.classList.remove('chat-slide-animate');
                        void activeChatElement.offsetWidth; // Сброс кэша анимации
                        activeChatElement.classList.add('chat-slide-animate');
                    }

                    // Устанавливаем только имя (Ник в ТГ не пишется в шапке)
                    document.getElementById('chatTitle').innerText = name;

                    // Устанавливаем аватарку
                    const headerAvatar = document.getElementById('chatHeaderAvatar');
                    if (userData && userData.avatar) {
                        headerAvatar.innerHTML = `<img src="${userData.avatar}" style="width:100%;height:100%;object-fit:cover;">`;
                    } else {
                        // Заглушка, если нет фото
                        headerAvatar.innerHTML = '👤';
                    }

                    // =======================================================
                    // ИСПРАВЛЕНИЕ: ЗАПУСКАЕМ СЛУШАТЕЛЬ СТАТУСА ПРИ ОБНОВЛЕНИИ
                    // =======================================================

                    // 1. Сбрасываем старый, если был
                    if (chatStatusUnsub) chatStatusUnsub();

                    // 2. Ставим "загрузка" или последнее известное время сразу
                    const statusEl = document.getElementById('chatStatus');
                    if (statusEl) {
                        statusEl.innerText = userData.lastSeen ? formatLastSeen(userData.lastSeen) : 'загрузка...';
                    }

                    // 3. Запускаем живое прослушивание
                    chatStatusUnsub = db.collection('users').doc(userId).onSnapshot(userSnap => {
                        if (userSnap.exists && currentFriendId === userId) {
                            const uData = userSnap.data();
                            usersCache[userId] = uData; // Обновляем кэш

                            const el = document.getElementById('chatStatus');
                            if (el) {
                                // Обновляем статус ТОЛЬКО если сейчас НЕ идет анимация "печатает"
                                if (!el.querySelector('.typing-text')) {
                                    el.innerText = formatLastSeen(uData.lastSeen);
                                    el.style.color = "#888";
                                }
                            }
                        }
                    }, err => console.error("Ошибка слушателя статуса:", err));

                    // =======================================================

                    // =======================================================

                    loadMessages();
                    listenTypingRTDB(currentChatId, userId);

                    // --- НОВОЕ: АВТОФОКУС ПРИ ВХОДЕ В ЧАТ ---
                    setTimeout(() => {
                        const inp = document.getElementById('msgInput');
                        if (!inp) return;

                        // Проверяем, мобилка ли это
                        const isMobile = /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent);

                        if (isMobile) {
                            // ТРЮК ДЛЯ ТЕЛЕФОНОВ: Ставим inputmode='none'.
                            // Браузер ставит фокус (курсор мигает), но огромная клавиатура НЕ перекрывает чат сразу.
                            inp.setAttribute('inputmode', 'none');
                            inp.focus();

                            // Когда пользователь реально касается поля — возвращаем полноценную клавиатуру
                            inp.addEventListener('pointerdown', function () {
                                inp.removeAttribute('inputmode');
                            }, { once: true });
                        } else {
                            // На ПК просто даем обычный фокус
                            inp.removeAttribute('inputmode');
                            inp.focus();
                        }
                    }, 300); // Ждем 300мс, пока закончится анимация появления чата
                    // ------------------------------------------

                } else {
                    // Юзер не найден
                    window.location.hash = '';
                }
            }
        }
        // --- Вставь это в свой скрипт ---

        // === НАЧАЛО ВСТАВКИ: Обработка Токена из C# ===

        // Эта функция вызывается из Android (C#) автоматически
        window.setNativeOneSignalId = function (token) {
            console.log("🔥 FCM Token получен из Android:", token);
            // 1. Сохраняем в память навсегда
            localStorage.setItem('fcm_token', token);

            // 2. Если мы уже вошли, сразу шлем на сервер
            if (currentUser) {
                saveTokenToBackend(currentUser.uid, token);
            }
        };

        // Функция отправки токена в базу и на скрипт
        function saveTokenToBackend(uid, token) {
            // Сохраняем в базу данных (Firestore)
            db.collection('users').doc(uid).update({
                fcmToken: token
            }).catch(err => console.log("Ошибка сохранения токена в БД:", err));

            // Отправляем скрипту (для пушей)
            fetch(GOOGLE_SCRIPT_URL, {
                method: 'POST',
                mode: 'no-cors',
                headers: { "Content-Type": "application/json" },
                body: JSON.stringify({
                    action: 'saveToken',
                    userId: uid,
                    token: token
                })
            });
        }

        // === КОНЕЦ ВСТАВКИ ===





        async function sendNotificationSecure(friendUid, messageText, msgType = 'text', isCall = false) {
            if (!friendUid || !messageText) return;

            // 1. Определяем имя отправителя
            let senderName = "Novogram";
            if (currentUser) {
                if (usersCache[currentUser.uid] && usersCache[currentUser.uid].name) {
                    senderName = usersCache[currentUser.uid].name;
                } else if (currentUser.displayName) {
                    senderName = currentUser.displayName;
                } else {
                    senderName = "Novogram";
                }
            }

            let displayText = messageText;
            if (msgType === 'image') displayText = '📷 Фотография';
            if (msgType === 'file') displayText = '📄 Файл';
            if (isCall) displayText = '📞 Входящий звонок...';

            try {
                // 2. Получаем данные получателя
                const doc = await db.collection('users').doc(friendUid).get();
                if (!doc.exists) return;

                const userData = doc.data();

                // Ищем все возможные токены
                const fcmToken = userData.fcmToken || null;
                const tgId = userData.tgChatId || null;
                const osId = userData.oneSignalId || null;

                if (!tgId && !osId && !fcmToken) {
                    console.log("У получателя нет токенов для уведомлений.");
                    return;
                }

                // 3. Отправляем запрос (ИСПРАВЛЕННЫЙ МЕТОД)
                fetch(GOOGLE_SCRIPT_URL, {
                    method: "POST",
                    redirect: "follow", // <-- ВАЖНО: Следовать за редиректом Google
                    headers: {
                        "Content-Type": "text/plain;charset=utf-8" // <-- ВАЖНО: text/plain чтобы не было CORS ошибок
                    },
                    body: JSON.stringify({
                        action: "notification",
                        secret: APP_SECRET_KEY,

                        fcmToken: fcmToken,
                        tgId: tgId,
                        oneSignalId: osId,

                        title: senderName,
                        text: displayText,
                        isCall: isCall,
                        chatId: [currentUser.uid, friendUid].sort().join('_'),
                        senderId: currentUser.uid
                    })
                })
                    .then(response => response.json())
                    .then(data => console.log("Статус отправки:", data))
                    .catch(err => console.error("Ошибка запроса к скрипту:", err));

            } catch (e) {
                console.error("Ошибка в функции уведомления:", e);
            }
        }



        // --- 1. Функция для показа "временного" сообщения (превью) ---
        function showTempMessage(file) {
            const list = currentMsgList;
            const tempId = 'temp-' + Date.now();
            const div = document.createElement('div');
            div.id = tempId;
            div.className = 'msg msg-me'; // Сразу как "своё"
            let contentHtml = '';
            // Если это картинка — показываем её сразу
            if (file.type.startsWith('image/')) {
                const url = URL.createObjectURL(file);
                contentHtml = `
                                <div class="media-container loading-overlay" style="position: relative; display: inline-block;">
                                <img src="${url}" class="chat-media-img" style="opacity: 1;">
                                <div class="upload-spinner"></div>
                                </div>
                                `;
            }
            // Если это файл — показываем карточку
            else {
                contentHtml = `
                                <div class="chat-file-card" style="opacity: 0.7;">
                                <div class="file-icon">📄</div>
                                <div class="file-info">
                                <div class="file-name">${file.name}</div>
                                <div class="file-action">Загрузка...</div>
                                </div>
                                <div class="upload-spinner" style="width: 20px; height: 20px; border-width: 2px; left: auto; right: 10px; transform: translateY(-50%);"></div>
                                </div>
                                `;
            }
            div.innerHTML = contentHtml;
            list.appendChild(div);

            // --- НОВОЕ: Плавный скролл при прикреплении файла ---
            setTimeout(() => {
                list.scrollTo({ top: list.scrollHeight + 500, behavior: 'smooth' });
            }, 50);

            return tempId; // Возвращаем ID, чтобы потом удалить это сообщение
        }

        // --- 2. Основная функция загрузки ---
        // !!! Убедись, что переменная GOOGLE_SCRIPT_URL объявлена выше !!!
        async function uploadFile(input) {
            const file = input.files[0];
            if (!file) return;

            // Ограничение 10 МБ
            if (file.size > 10 * 1024 * 1024) {
                alert("Файл слишком большой! Максимум 10 МБ.");
                return;
            }

            // Показываем превью
            const tempMsgId = showTempMessage(file);

            const msgInput = document.getElementById('msgInput');
            const originalPlaceholder = msgInput.placeholder;
            msgInput.placeholder = "Загрузка файла...";
            msgInput.disabled = true;

            try {
                // Конвертируем в Base64
                const toBase64 = f => new Promise((resolve, reject) => {
                    const reader = new FileReader();
                    reader.readAsDataURL(f);
                    reader.onload = () => resolve(reader.result.split(',')[1]);
                    reader.onerror = error => reject(error);
                });

                const base64Data = await toBase64(file);

                // ОТПРАВЛЯЕМ ЗАПРОС С СЕКРЕТОМ И ACTION
                const response = await fetch(GOOGLE_SCRIPT_URL, {
                    method: "POST",
                    redirect: "follow",
                    headers: {
                        "Content-Type": "text/plain;charset=utf-8"
                    },
                    body: JSON.stringify({
                        action: "upload",  // <--- ВАЖНО: говорим серверу, что это загрузка
                        secret: "JH54jnbdfkjs297615109dxc1kDmnsg_df1jksHnh1Lhsc", // <--- ВАЖНО: твой ключ
                        filename: file.name,
                        mimeType: file.type,
                        base64: base64Data
                    })
                });

                const data = await response.json();

                // Удаляем превью
                const tempEl = document.getElementById(tempMsgId);
                if (tempEl) tempEl.remove();

                if (data.result === "success") {
                    const type = file.type.startsWith('image/') ? 'image' : 'file';
                    sendMsg(data.url, false, type);
                } else {
                    throw new Error(data.message || "Ошибка скрипта");
                }
            } catch (error) {
                console.error("Ошибка загрузки:", error);
                const tempEl = document.getElementById(tempMsgId);
                if (tempEl) tempEl.remove();
                alert("Ошибка загрузки: " + error.message);
            } finally {
                msgInput.placeholder = originalPlaceholder;
                msgInput.disabled = false;
                input.value = '';
                msgInput.focus();
            }
        }
        // Функции для просмотра фото
        function openImageViewer(src) {
            const viewer = document.getElementById('imageViewer');
            const img = document.getElementById('imageViewerImg');
            // Меняем ссылку на качество повыше для просмотра (если это гугл диск)
            // Добавляем параметр =w2000 (ширина 2000px)
            let highResSrc = src;
            if (src.includes('lh3.googleusercontent.com')) {
                highResSrc = src.split('=')[0] + '=w2000';
            }
            img.src = highResSrc;
            viewer.classList.add('active');
        }
        function closeImageViewer() {
            const viewer = document.getElementById('imageViewer');
            viewer.classList.remove('active');
            setTimeout(() => {
                document.getElementById('imageViewerImg').src = ''; // Очистка
            }, 300);
        }
        function closeChat() {
            // 1. Проверяем, есть ли хеш (например, #chat/123)
            if (window.location.hash) {
                // 2. Убираем хеш из адресной строки без перезагрузки
                history.pushState("", document.title, window.location.pathname + window.location.search);
                // 3. Вызываем обработчик смены хеша вручную, чтобы он запустил performCloseUI()
                handleHashChange();
            } else {
                // Если хеша нет (странный случай), просто закрываем UI
                performCloseUI();
            }
        }
        function closeSearch() {
            const searchInput = document.getElementById('searchInput');
            const resBox = document.getElementById('searchResults');

            // Очищаем ввод
            searchInput.value = '';
            resBox.innerHTML = '';
            resBox.classList.remove('active');

            // Возвращаем кнопку профиля и прячем кнопку назад
            document.getElementById('profileBtn').style.display = 'flex';
            document.getElementById('searchBackBtn').style.display = 'none';

            // Возвращаем табы и кнопку заявок
            document.getElementById('tabsContainerMain').classList.remove('hidden');
            document.getElementById('requestsBtnTop').style.display = 'flex';

            // Возвращаем список друзей (или активную вкладку)
            document.getElementById('friendsList').classList.remove('hidden');
        }



        // И обнови openSearchUI, чтобы display переключался
        function openSearchUI() {
            // Прячем кнопку профиля, показываем кнопку "Назад" в поиске
            document.getElementById('profileBtn').style.display = 'none';
            document.getElementById('searchBackBtn').style.display = 'block';

            // Скрываем списки друзей, заявок и табы
            document.getElementById('friendsList').classList.add('hidden');
            document.getElementById('requestsList').classList.add('hidden');
            document.getElementById('tabsContainerMain').classList.add('hidden');
            document.getElementById('requestsBtnTop').style.display = 'none';

            // Показываем контейнер поиска
            const resBox = document.getElementById('searchResults');
            resBox.classList.add('active');
        }








        function openContextMenu(e, msgId, isMine, isMobile = false) {
            window.isMenuJustOpened = true;
            window.ignoreScrollClose = true; // Защита от дрожания пальца

            if (window.menuScrollTimeout) clearTimeout(window.menuScrollTimeout);
            window.menuScrollTimeout = setTimeout(() => {
                window.isMenuJustOpened = false;
                window.ignoreScrollClose = false;
            }, 500); // Через полсекунды снимаем защиту

            document.querySelectorAll('.msg-highlighted').forEach(el => {
                el.classList.remove('msg-highlighted');
            });

            selectedMsgId = msgId;
            selectedMsgIsMine = isMine;

            const menu = document.getElementById('contextMenu');
            const btnEdit = document.getElementById('ctxEdit');
            const msgEl = document.getElementById('msg-' + msgId);

            if (isMine) btnEdit.style.display = 'flex';
            else btnEdit.style.display = 'none';

            // --- ВКЛЮЧАЕМ РАЗМЫТИЕ И ВЫДЕЛЯЕМ СООБЩЕНИЕ ---
            document.body.classList.add('chat-blur-active');
            if (msgEl) msgEl.classList.add('msg-highlighted');

            // Используем невидимый прозрачный слой для перехвата клика мимо меню
            const overlay = document.getElementById('overlaySheet');
            if (overlay) {
                overlay.style.background = 'transparent'; // Убираем черноту, т.к. мы уже затемнили фон CSS-ом
                overlay.style.display = 'block';
            }

            menu.style.display = 'flex';

            // Даем браузеру долю секунды, чтобы применить display:flex и вычислить размеры меню
            setTimeout(() => {
                if (isMobile && msgEl) {
                    const rect = msgEl.getBoundingClientRect();
                    const menuH = menu.offsetHeight;
                    const menuW = menu.offsetWidth;

                    // Вертикально: показываем меню ровно ПОД сообщением. Если не влезает — НАД ним.
                    let topPos = rect.bottom + 10;
                    if (topPos + menuH > window.innerHeight - 20) {
                        topPos = rect.top - menuH - 10;
                    }

                    // Горизонтально: выравниваем по левому или правому краю сообщения
                    let leftPos;
                    if (isMine) {
                        leftPos = rect.right - menuW;
                        if (leftPos < 10) leftPos = 10; // Защита от выхода за экран
                    } else {
                        leftPos = rect.left;
                        if (leftPos + menuW > window.innerWidth - 10) leftPos = window.innerWidth - menuW - 10;
                    }

                    menu.style.position = 'fixed';
                    menu.style.top = `${topPos}px`;
                    menu.style.left = `${leftPos}px`;
                    menu.style.transform = 'none';
                } else if (e) {
                    // Для ПК - открываем по координатам мышки
                    let x = e.clientX;
                    let y = e.clientY;
                    if (x + menu.offsetWidth > window.innerWidth) x -= menu.offsetWidth;
                    if (y + menu.offsetHeight > window.innerHeight) y -= menu.offsetHeight;
                    menu.style.left = `${x}px`;
                    menu.style.top = `${y}px`;
                    menu.style.transform = 'none';
                }

                menu.classList.add('active');
            }, 10);
        }





        document.addEventListener('scroll', () => {
            // НА МОБИЛКЕ ОТКЛЮЧАЕМ ЗАКРЫТИЕ ПО СКРОЛЛУ (чтобы меню не прыгало)
            if (window.innerWidth <= 768) return;

            if (window.ignoreScrollClose) return;

            const menu = document.getElementById('contextMenu');
            if (menu && menu.style.display === 'flex') {
                closeAllSheets();
            }
        }, true);

        let editAvatarBase64 = null;


        function openEditProfile() {
            console.log("Открываем редактирование профиля...");

            // Записываем шаг в историю (для кнопки Назад)
            if (typeof sheetHistoryStack !== 'undefined') sheetHistoryStack++;
            history.pushState({ isSheet: true }, "", window.location.href);

            const sheet = document.getElementById('editProfileSheet');
            sheet.style.display = 'flex'; // Принудительно показываем блоку, что он flex

            // Даем 10мс на рендеринг, чтобы сработала плавная анимация выезда
            setTimeout(() => {
                sheet.classList.add('open');
            }, 10);

            // Безопасная загрузка данных
            try {
                const user = firebase.auth().currentUser;
                if (!user) return;

                db.collection('users').doc(user.uid).get().then(doc => {
                    if (doc.exists) {
                        const d = doc.data();

                        document.getElementById('editName').value = d.name || '';
                        document.getElementById('editSurname').value = d.surname || '';
                        document.getElementById('editBio').value = d.bio || '';

                        if (typeof updateBioCounter === 'function') updateBioCounter(document.getElementById('editBio'));

                        if (d.birthdate) {
                            document.getElementById('editBirthdate').value = d.birthdate;
                            if (typeof syncBirthdateView === 'function') syncBirthdateView();
                        } else {
                            document.getElementById('editBirthdate').value = '';
                        }

                        if (typeof originalUsername !== 'undefined') originalUsername = d.username || '';
                        document.getElementById('editUsername').value = d.username || '';
                        document.getElementById('editUsernameStatus').style.display = 'none';

                        const img = document.getElementById('editAvatarPreview');
                        const ph = document.getElementById('editAvatarPlaceholder');

                        if (d.avatar) {
                            img.src = d.avatar;
                            img.style.display = 'block';
                            ph.style.display = 'none';
                            if (typeof editAvatarBase64 !== 'undefined') editAvatarBase64 = d.avatar;
                        } else {
                            img.style.display = 'none';
                            ph.style.display = 'flex';
                            ph.innerText = (d.name || 'U').charAt(0).toUpperCase();
                            if (typeof editAvatarBase64 !== 'undefined') editAvatarBase64 = null;
                        }
                    }
                }).catch(e => console.error("Ошибка загрузки данных для редактирования:", e));
            } catch (e) {
                console.error("Критическая ошибка:", e);
            }
        }

        function closeEditProfile(fromPopState = false) {
            // 1. Принудительно прячем клавиатуру и сбрасываем огромный отступ
            if (document.activeElement) {
                document.activeElement.blur();
            }
            const scrollContainer = document.querySelector('#editProfileSheet > div:nth-child(2)');
            if (scrollContainer) {
                scrollContainer.style.paddingBottom = '40px';
            }

            // 2. Системное закрытие (как было у вас)
            if (fromPopState !== true && typeof sheetHistoryStack !== 'undefined' && sheetHistoryStack > 0) {
                history.back();
                return;
            }

            document.getElementById('editProfileSheet').classList.remove('open');
        }

        function updateBioCounter(el) {
            const count = el.value.length;
            const remaining = 70 - count;
            document.getElementById('bioCounter').innerText = remaining;
            if (remaining < 0) {
                document.getElementById('bioCounter').style.color = 'red';
            } else {
                document.getElementById('bioCounter').style.color = '#888';
            }
        }

        function handleEditAvatarSelect(input) {
            const file = input.files[0];
            if (!file) return;

            const reader = new FileReader();
            reader.onload = function (e) {
                // Сжатие и отображение (используем существующую логику сжатия если есть, или просто отображаем)
                const img = new Image();
                img.src = e.target.result;
                img.onload = function () {
                    // Простая логика canvas для сжатия до 500x500
                    const canvas = document.createElement('canvas');
                    let width = img.width;
                    let height = img.height;
                    const MAX = 500;
                    if (width > height) {
                        if (width > MAX) { height *= MAX / width; width = MAX; }
                    } else {
                        if (height > MAX) { width *= MAX / height; height = MAX; }
                    }
                    canvas.width = width;
                    canvas.height = height;
                    const ctx = canvas.getContext('2d');
                    ctx.drawImage(img, 0, 0, width, height);

                    editAvatarBase64 = canvas.toDataURL('image/jpeg', 0.8);

                    // Обновляем UI
                    const preview = document.getElementById('editAvatarPreview');
                    const ph = document.getElementById('editAvatarPlaceholder');
                    preview.src = editAvatarBase64;
                    preview.style.display = 'block';
                    ph.style.display = 'none';
                }
            };
            reader.readAsDataURL(file);
        }



        // Переменная для таймера (добавьте в начало скрипта, если еще нет)
        // let usernameCheckTimeout = null;

        function checkUsernameAvailability(input) {
            let val = input.value;
            const cleanVal = val.replace(/[^a-zA-Z0-9_]/g, '');

            if (val !== cleanVal) {
                input.value = cleanVal;
                val = cleanVal;
            }

            const statusEl = document.getElementById('editUsernameStatus');
            const sideStatusEl = document.getElementById('usernameSideStatus'); // <-- НОВЫЙ ЭЛЕМЕНТ
            const saveBtn = document.querySelector('#editProfileSheet .premium-header button:last-child');
            const prefix = document.querySelector('.premium-username-prefix');

            if (typeof usernameCheckTimeout !== 'undefined' && usernameCheckTimeout) {
                clearTimeout(usernameCheckTimeout);
            }

            const setValid = (isValid) => {
                if (typeof isUsernameValid !== 'undefined') isUsernameValid = isValid;
                if (saveBtn) {
                    saveBtn.style.opacity = isValid ? "1" : "0.5";
                    saveBtn.style.pointerEvents = isValid ? "auto" : "none";
                }
            };

            // ОБНОВЛЕНО: Функция теперь принимает и длинный текст (вниз), и короткий (сбоку)
            const showStatus = (longText, shortText, type) => {
                statusEl.className = `premium-status-msg visible ${type}`;

                // Показываем надпись сбоку
                if (sideStatusEl) {
                    sideStatusEl.innerText = shortText;
                    sideStatusEl.style.opacity = "1";
                }

                if (type === 'loading') {
                    statusEl.innerHTML = `<div class="status-spinner-small"></div> <span>${longText}</span>`;
                    if (prefix) prefix.style.color = '#8e8e93';
                    if (sideStatusEl) sideStatusEl.style.color = '#8e8e93'; // Серый
                } else if (type === 'success') {
                    statusEl.innerHTML = `<svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2.5" stroke-linecap="round" stroke-linejoin="round"><polyline points="20 6 9 17 4 12"></polyline></svg> <span>${longText}</span>`;
                    if (prefix) prefix.style.color = '#10b981';
                    if (sideStatusEl) sideStatusEl.style.color = '#10b981'; // Изумрудный
                } else if (type === 'error') {
                    statusEl.innerHTML = `<svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2.5" stroke-linecap="round" stroke-linejoin="round"><line x1="18" y1="6" x2="6" y2="18"></line><line x1="6" y1="6" x2="18" y2="18"></line></svg> <span>${longText}</span>`;
                    if (prefix) prefix.style.color = '#ff595a';
                    if (sideStatusEl) sideStatusEl.style.color = '#ff595a'; // Красный
                }
            };

            if (val.length === 0) {
                statusEl.className = 'premium-status-msg'; // Скрываем нижний текст
                if (prefix) prefix.style.color = '#736AF0';
                if (sideStatusEl) sideStatusEl.style.opacity = "0"; // Скрываем боковой текст
                setValid(false);
                return;
            }

            if (val.length < 3) {
                showStatus("Минимальная длина — 3 символа", "Короткое", "error");
                setValid(false);
                return;
            }

            const myOldNick = typeof originalUsername !== 'undefined' ? originalUsername : '';
            if (val.toLowerCase() === myOldNick.toLowerCase()) {
                showStatus("Это ваше текущее имя пользователя", "Текущее имя", "success");
                setValid(true);
                return;
            }

            showStatus("Проверка доступности...", "Поиск...", "loading");
            setValid(false);

            const lowerVal = val.toLowerCase();
            const upperVal = val.toUpperCase();
            const capVal = val.charAt(0).toUpperCase() + val.slice(1).toLowerCase();
            const variations = [...new Set([val, lowerVal, upperVal, capVal])];

            usernameCheckTimeout = setTimeout(() => {
                db.collection('users').where('username', 'in', variations).get().then(snap => {
                    if (snap.empty) {
                        showStatus(`Имя @${val} доступно`, "Свободно", "success");
                        setValid(true);
                    } else {
                        showStatus("Это имя уже занято", "Занято", "error");
                        setValid(false);
                    }
                }).catch(err => {
                    console.error(err);
                    showStatus("Ошибка проверки соединения", "Ошибка", "error");
                    setValid(false);
                });
            }, 500);
        }


        // 1. Умное форматирование даты для разделителей (Сегодня, Вчера, 15 февраля)
        function getChatSeparatorDate(ts) {
            if (!ts) return "Неизвестно";
            const msgDate = new Date(ts);
            const now = new Date();

            const today = new Date(now.getFullYear(), now.getMonth(), now.getDate()).getTime();
            const target = new Date(msgDate.getFullYear(), msgDate.getMonth(), msgDate.getDate()).getTime();
            const diffDays = Math.floor((today - target) / (1000 * 60 * 60 * 24));

            if (diffDays === 0) return "Сегодня";
            if (diffDays === 1) return "Вчера";

            const months = ["января", "февраля", "марта", "апреля", "мая", "июня", "июля", "августа", "сентября", "октября", "ноября", "декабря"];
            let res = `${msgDate.getDate()} ${months[msgDate.getMonth()]}`;

            if (msgDate.getFullYear() !== now.getFullYear()) res += ` ${msgDate.getFullYear()} г.`;
            return res;
        }

        let lastClickedDateStr = null;
        let dateClickTimeout = null;

        function handleDateClick(dateStr) {
            // Если мы уже нажимали на ЭТУ ЖЕ дату только что -> открываем календарь
            if (lastClickedDateStr === dateStr) {
                const picker = document.getElementById('chatDatePicker');
                if (picker) {
                    try { picker.showPicker(); } catch (e) { picker.click(); }
                }
                lastClickedDateStr = null; // Сбрасываем
            } else {
                // Первый клик -> Ищем первое сообщение этого дня
                const msgs = document.querySelectorAll('.msg');
                let target = null;
                for (let i = 0; i < msgs.length; i++) {
                    if (msgs[i].getAttribute('data-datestr') === dateStr) {
                        target = msgs[i];
                        break;
                    }
                }

                if (target) {
                    // Прыгаем к сообщению
                    const scrollTarget = target.previousElementSibling && target.previousElementSibling.classList.contains('chat-date-separator')
                        ? target.previousElementSibling
                        : target;

                    scrollTarget.scrollIntoView({ behavior: 'smooth', block: 'start' });
                    // Подсветка (как в ТГ)
                    const oldBg = target.style.background;
                    target.style.transition = 'background 0.5s';
                    target.style.background = 'rgba(115, 106, 240, 0.4)';
                    setTimeout(() => target.style.background = oldBg, 1000);

                    // Запоминаем, что мы сюда уже прыгнули
                    lastClickedDateStr = dateStr;
                    // Если юзер не кликнул второй раз в течение 3 сек, сбрасываем статус
                    if (dateClickTimeout) clearTimeout(dateClickTimeout);
                    dateClickTimeout = setTimeout(() => { lastClickedDateStr = null; }, 3000);
                }
            }
        }

        function handleCalendarChange(e) {
            const selectedDate = e.target.value; // формат YYYY-MM-DD
            if (!selectedDate) return;

            const msgs = Array.from(document.querySelectorAll('.msg'));
            let targetMsg = null;

            // Ищем первое сообщение, дата которого >= выбранной
            for (let i = 0; i < msgs.length; i++) {
                const msgDate = msgs[i].getAttribute('data-rawdate');
                if (msgDate && msgDate >= selectedDate) {
                    targetMsg = msgs[i];
                    break;
                }
            }

            // Если не нашли (выбрали будущее), берем самое последнее сообщение в чате
            if (!targetMsg && msgs.length > 0) {
                targetMsg = msgs[msgs.length - 1];
            }

            if (targetMsg) {
                // Прыгаем к сообщению (в самый верх)
                targetMsg.scrollIntoView({ behavior: 'smooth', block: 'start' });
                const oldBg = targetMsg.style.background;
                targetMsg.style.transition = 'background 0.5s';
                targetMsg.style.background = 'rgba(115, 106, 240, 0.4)';
                setTimeout(() => targetMsg.style.background = oldBg, 1000);
            } else {
                showToast("В чате еще нет сообщений");
            }
        }

        // 2. Функция, которая расставляет плашки-разделители между сообщениями
        function updateDateSeparators() {
            const list = currentMsgList;
            const oldSeparators = list.querySelectorAll('.chat-date-separator');
            oldSeparators.forEach(el => el.remove());

            const msgs = list.querySelectorAll('.msg');
            let lastDateStr = null;

            msgs.forEach(msg => {
                const dateStr = msg.getAttribute('data-datestr');
                if (!dateStr) return;

                if (dateStr !== lastDateStr) {
                    const sep = document.createElement('div');
                    sep.className = 'chat-date-separator';
                    sep.innerText = dateStr;
                    // ВЕШАЕМ КЛИК НА РАЗДЕЛИТЕЛЬ:
                    sep.onclick = () => handleDateClick(dateStr);
                    list.insertBefore(sep, msg);
                    lastDateStr = dateStr;
                }
            });
        }


        // 3. Логика плавающей даты (Скролл теперь обрабатывается в handleChatScroll)
        document.addEventListener('DOMContentLoaded', () => {
            const floatingDate = document.getElementById('floatingDate');
            const chatDatePicker = document.getElementById('chatDatePicker');

            if (floatingDate) {
                floatingDate.onclick = () => handleDateClick(floatingDate.innerText);
            }

            if (chatDatePicker) {
                chatDatePicker.addEventListener('change', handleCalendarChange);
            }
        });

        function pad2(n) { return String(n).padStart(2, '0'); }
        function daysInMonth(y, m1to12) { return new Date(y, m1to12, 0).getDate(); }

        function setSelectValue(sel, val) {
            sel.value = String(val);
        }

        function fillSelect(sel, from, to, fmt = v => v) {
            sel.innerHTML = '';
            for (let v = from; v <= to; v++) {
                const opt = document.createElement('option');
                opt.value = String(v);
                opt.textContent = fmt(v);
                sel.appendChild(opt);
            }
        }

        function syncBirthdateView() {
            const hidden = document.getElementById('editBirthdate');
            const view = document.getElementById('editBirthdateView');
            if (!hidden || !view) return;

            if (!hidden.value) {
                view.value = '';
                return;
            }
            const [y, m, d] = hidden.value.split('-');
            view.value = `${pad2(d)}.${pad2(m)}.${y}`;
        }

        function openBirthModal() {
            const modal = document.getElementById('birthModal');
            const hidden = document.getElementById('editBirthdate');

            const daySel = document.getElementById('bdDay');
            const monthSel = document.getElementById('bdMonth');
            const yearSel = document.getElementById('bdYear');

            const now = new Date();
            let y = now.getFullYear(), m = now.getMonth() + 1, d = now.getDate();

            if (hidden && hidden.value) {
                const parts = hidden.value.split('-');
                if (parts.length === 3) {
                    y = parseInt(parts[0], 10);
                    m = parseInt(parts[1], 10);
                    d = parseInt(parts[2], 10);
                }
            }

            const minYear = 1900;
            const maxYear = 2011;

            if (y > maxYear) y = maxYear;

            fillSelect(yearSel, minYear, maxYear);
            fillSelect(monthSel, 1, 12, v => pad2(v));

            setSelectValue(yearSel, y);
            setSelectValue(monthSel, m);

            function refreshDays() {
                const yy = parseInt(yearSel.value, 10);
                const mm = parseInt(monthSel.value, 10);
                const maxD = daysInMonth(yy, mm);
                const curD = Math.min(parseInt(daySel.value || d, 10), maxD);

                fillSelect(daySel, 1, maxD, v => pad2(v));
                setSelectValue(daySel, curD);
            }

            yearSel.onchange = refreshDays;
            monthSel.onchange = refreshDays;

            refreshDays();
            modal.style.display = 'flex';
        }

        function closeBirthModal() {
            const modal = document.getElementById('birthModal');
            if (modal) modal.style.display = 'none';
        }

        function applyBirthdate() {
            const daySel = document.getElementById('bdDay');
            const monthSel = document.getElementById('bdMonth');
            const yearSel = document.getElementById('bdYear');

            const y = yearSel.value;
            const m = pad2(monthSel.value);
            const d = pad2(daySel.value);

            document.getElementById('editBirthdate').value = `${y}-${m}-${d}`;
            syncBirthdateView();
            closeBirthModal();
        }

        document.addEventListener('DOMContentLoaded', () => {
            const view = document.getElementById('editBirthdateView');
            if (view) {
                view.addEventListener('click', openBirthModal);
            }
            syncBirthdateView();
        });

        // Функция для просмотра аватарки профиля
        function viewProfileAvatar() {
            const img = document.getElementById('profileAvatarPreview');
            // Открываем просмотрщик, только если картинка загружена и отображается
            if (img && img.style.display !== 'none' && img.src) {
                openImageViewer(img.src);
            }
        }

        function openGeneralSettings() {
            console.log("Открываем общие настройки...");

            if (typeof sheetHistoryStack !== 'undefined') sheetHistoryStack++;
            history.pushState({ isSheet: true }, "", window.location.href);

            const sheet = document.getElementById('generalSettingsSheet');
            sheet.style.display = 'flex';

            setTimeout(() => {
                sheet.classList.add('open');
            }, 10);

            // Инициализируем тумблеры внутри настроек
            if (typeof initSettingsUI === 'function') initSettingsUI();
        }

        function closeGeneralSettings(fromPopState = false) {
            if (fromPopState !== true && typeof sheetHistoryStack !== 'undefined' && sheetHistoryStack > 0) {
                history.back();
                return;
            }

            const sheet = document.getElementById('generalSettingsSheet');
            sheet.classList.remove('open');
        }



        fetch(KEY_PROVIDER_URL, { method: 'GET', mode: 'no-cors' }).catch(() => { });
        window.addEventListener('click', function (e) {
            // Если меню только что открылось — пропускаем клик (флаг снимется сам по таймеру)
            if (window.isMenuJustOpened) return;

            const menu = document.getElementById('contextMenu');
            if (menu && menu.style.display === 'flex' && !menu.contains(e.target)) {
                closeAllSheets();
            }
        });

        // --- ЛОГИКА ПРОЧТЕНИЯ ПРИ ВОЗВРАЩЕНИИ НА ВКЛАДКУ ---

        function markCurrentChatRead() {
            if (!currentChatId || !currentUser) return;
            // Обнуляем счетчик в RTDB
            rtdb.ref(`unread/${currentUser.uid}/${currentChatId}`).set(0);

            // В фоне помечаем в Firestore (для истории), но это уже не горит
            db.collection('chats').doc(currentChatId).collection('msgs')
                .where('to', '==', currentUser.uid).where('read', '==', false).get()
                .then(snap => {
                    const batch = db.batch();
                    snap.docs.forEach(doc => batch.update(doc.ref, { read: true }));
                    batch.commit();
                });
        }

        function listenAllUnreadRTDB() {
            rtdb.ref(`unread/${currentUser.uid}`).on('value', (snap) => {
                const data = snap.val() || {};
                unreadCounts = data; // Синхронизируем с твоей переменной

                Object.keys(data).forEach(chatId => {
                    const badgeEl = document.getElementById('badge-' + chatId);
                    if (badgeEl) {
                        const count = data[chatId];
                        if (count > 0) {
                            badgeEl.innerText = count;
                            badgeEl.classList.remove('hidden');
                        } else {
                            badgeEl.classList.add('hidden');
                        }
                    }
                });
                updateTotalFriendsBadge(); // Твоя функция общего счетчика на папке
            });
        }

        // Запускаем проверку, когда пользователь фокусируется на окне
        window.addEventListener('focus', markCurrentChatRead);

        // Запускаем проверку, когда вкладка становится видимой
        document.addEventListener('visibilitychange', () => {
            if (document.visibilityState === 'visible') {
                markCurrentChatRead();
            }
        });

        // Дополнительно: при клике в любую часть окна (на случай глюков фокуса)
        window.addEventListener('click', () => {
            // Небольшая задержка, чтобы не спамить запросами
            if (currentChatId) markCurrentChatRead();
        });

        // 1. Отправка статуса
        function handleTyping() {
            if (!currentChatId || !currentUser) return;
            const now = Date.now();

            if (!isTyping || (now - lastTypingTime > 2000)) {
                isTyping = true;
                lastTypingTime = now;
                rtdb.ref(`typing/${currentChatId}/${currentUser.uid}`).set(true);
            }

            if (typingTimeout) clearTimeout(typingTimeout);
            typingTimeout = setTimeout(() => {
                isTyping = false;
                rtdb.ref(`typing/${currentChatId}/${currentUser.uid}`).remove();
            }, 3000);
        }

        // Эту функцию вызови ОДИН РАЗ внутри handleHashChange, когда открывается чат
        function listenTypingRTDB(chatId, friendId) {
            const ref = rtdb.ref(`typing/${chatId}/${friendId}`);

            ref.on('value', (snap) => {
                const statusEl = document.getElementById('chatStatus');
                if (!statusEl) return;

                if (snap.val() === true) {
                    statusEl.innerHTML = '<span class="typing-text">печатает<span class="typing-dots"><span>.</span><span>.</span><span>.</span></span></span>';
                    statusEl.style.color = '#736AF0';
                } else {
                    // Просто запрашиваем актуальный статус из RTDB
                    rtdb.ref('status/' + friendId).once('value', s => {
                        const d = s.val();
                        if (d && currentFriendId === friendId) {
                            statusEl.innerText = d.state === 'online' ? 'в сети' : formatLastSeenRTDB(d.last_seen);
                            statusEl.style.color = d.state === 'online' ? '#736AF0' : '#888';
                        }
                    });
                }
            });
        }

        // 2. Слушатель (вызывай это внутри openChat)
        function listenTyping(chatId, friendId) {
            const typingRef = rtdb.ref(`typing/${chatId}/${friendId}`);
            typingRef.on('value', (snap) => {
                const statusEl = document.getElementById('chatStatus');
                if (snap.val() === true) {
                    statusEl.innerHTML = '<span class="typing-text">печатает<span class="typing-dots"><span>.</span><span>.</span><span>.</span></span></span>';
                } else {
                    // Если перестал печатать — возвращаем "в сети / был тогда-то"
                    // (данные берем из кэша или новой функции статуса)
                }
            });
        }




        // --- ЛОГИКА ПЕРЕВОДА ---

        // Загружаем настройки из памяти
        let isAutoTranslate = localStorage.getItem('isAutoTranslate') === 'true';
        let targetLang = localStorage.getItem('targetLang') || 'ru';

        // Инициализация UI настроек при открытии
        function initSettingsUI() {
            const toggle = document.getElementById('autoTranslateToggle');
            if (toggle) toggle.checked = isAutoTranslate;

            // Обновляем метку языка текущим значением из localStorage
            const label = document.getElementById('currentLangLabel');
            if (label) {
                label.innerText = `Код языка: ${targetLang}`;
            }
        }

        // Переключение тумблера
        function toggleAutoTranslate(el) {
            isAutoTranslate = el.checked;
            localStorage.setItem('isAutoTranslate', isAutoTranslate);
            showToast(isAutoTranslate ? "Автоперевод включен" : "Автоперевод выключен");
        }

        // Смена языка (простой prompt)
        // --- НОВАЯ ЛОГИКА ВЫБОРА ЯЗЫКА ---

        // 1. Открывает окно вместо prompt
        function changeTranslateLang() {
            const modal = document.getElementById('langModal');
            if (modal) {
                modal.style.display = 'flex';
            } else {
                console.error("Modale window #langModal not found!");
            }
        }

        // 2. Закрывает окно
        function closeLangModal() {
            document.getElementById('langModal').style.display = 'none';
        }

        // 3. Сохраняет выбор
        // 3. Сохраняет выбор
        function selectLanguage(code) {
            const langs = {
                'ar': 'Egyptian', // Добавлено
                'ru': 'Русский',
                'en': 'English',
                'de': 'Deutsch',
                'fr': 'Français',
                'es': 'Español',
                'it': 'Italiano',
                'tr': 'Türkçe',
                'uk': 'Українська'
            };

            // Сохраняем в память и локальное хранилище
            targetLang = code;
            localStorage.setItem('targetLang', targetLang);

            // Обновляем текст в настройках
            updateLangLabel();

            // Уведомление
            showToast(`Язык изменен на: ${langs[code] || code}`);

            // Закрываем окно
            closeLangModal();
        }

        // Обновляем метку в меню настроек
        function updateLangLabel() {
            const el = document.getElementById('currentLangLabel');
            if (el) {
                const langNames = {
                    'ar': 'Egyptian', // Добавлено
                    'ru': 'Русский',
                    'en': 'English',
                    'de': 'Deutsch',
                    'es': 'Español',
                    'fr': 'Français',
                    'it': 'Italiano',
                    'tr': 'Türkçe',
                    'uk': 'Українська'
                };
                const name = langNames[targetLang] || targetLang.toUpperCase();
                el.innerText = `${name} (${targetLang})`;
            }
        }

        // ==========================================
        // ЛОГИКА ПОИСКА ПО ЧАТУ (ТЕЛЕГРАМ СТИЛЬ)
        // ==========================================
        let chatSearchMatches = [];
        let chatSearchCurrentIndex = -1;
        let chatSearchDebounce;

        function toggleChatSearch() {
            const bar = document.getElementById('chatSearchBar');
            const dropdown = document.getElementById('chatSearchDropdown');
            const inp = document.getElementById('chatSearchInput');

            if (bar.classList.contains('hidden')) {
                bar.classList.remove('hidden');
                inp.focus();
            } else {
                bar.classList.add('hidden');
                dropdown.classList.add('hidden');
                inp.value = '';
                clearChatSearch();
            }
        }

        function handleChatSearchInput(query) {
            clearTimeout(chatSearchDebounce);
            chatSearchDebounce = setTimeout(() => {
                performChatSearch(query);
            }, 300); // Ищем через 0.3 сек после остановки ввода
        }

        function clearChatSearch() {
            chatSearchMatches = [];
            chatSearchCurrentIndex = -1;
            document.getElementById('chatSearchCount').innerText = "";
            document.getElementById('chatSearchDropdown').innerHTML = "";
        }

        function performChatSearch(query) {
            clearChatSearch();
            const dropdown = document.getElementById('chatSearchDropdown');
            if (!query.trim()) { dropdown.classList.add('hidden'); return; }

            const lowerQuery = query.toLowerCase();

            // Ищем список сообщений именно активного чата
            const activeList = document.getElementById('msgList_' + currentChatId);
            if (!activeList) return;

            const msgs = activeList.querySelectorAll('.msg');
            const friendData = usersCache[currentFriendId] || {};
            const friendName = (friendData.name || 'User');

            msgs.forEach(msgBlock => {
                const textSpan = msgBlock.querySelector('.msg-text');
                if (!textSpan) return;

                const text = textSpan.innerText;
                if (text.toLowerCase().includes(lowerQuery)) {
                    const isMine = msgBlock.classList.contains('msg-me');
                    const timeEl = msgBlock.querySelector('.msg-time');

                    chatSearchMatches.push({
                        id: msgBlock.id,
                        text: text,
                        isMine: isMine,
                        name: isMine ? "Вы" : friendName,
                        time: timeEl ? timeEl.innerText : '',
                        element: msgBlock
                    });
                }
            });

            // Отрисовка результатов в выпадающем списке
            dropdown.innerHTML = '';
            if (chatSearchMatches.length === 0) {
                dropdown.innerHTML = '<div style="padding:20px; text-align:center; color:#888;">Ничего не найдено</div>';
            } else {
                chatSearchMatches.forEach((res, index) => {
                    const div = document.createElement('div');
                    div.className = 'search-msg-item';
                    div.id = 'search-item-' + index;
                    div.innerHTML = `
                                            <div class="search-msg-content">
                                                <div class="search-msg-header">
                                                    <span class="search-msg-name">${res.name}</span>
                                                    <span class="search-msg-time">${res.time}</span>
                                                </div>
                                                <div class="search-msg-text">${res.text}</div>
                                            </div>
                                        `;
                    div.onclick = () => {
                        chatSearchCurrentIndex = index;
                        jumpToMessageAndCloseDropdown();
                    };
                    dropdown.appendChild(div);
                });
            }

            dropdown.classList.remove('hidden');
            if (chatSearchMatches.length > 0) {
                chatSearchCurrentIndex = chatSearchMatches.length - 1;
                updateSearchUI();
            }
        }

        function navigateChatSearch(direction) {
            if (chatSearchMatches.length === 0) return;

            // Навигация стрелками
            chatSearchCurrentIndex += direction;

            // Зацикливание
            if (chatSearchCurrentIndex < 0) chatSearchCurrentIndex = chatSearchMatches.length - 1;
            if (chatSearchCurrentIndex >= chatSearchMatches.length) chatSearchCurrentIndex = 0;

            updateSearchUI();

            // Скроллим само сообщение в чате
            const targetMsg = chatSearchMatches[chatSearchCurrentIndex].element;
            targetMsg.scrollIntoView({ behavior: 'smooth', block: 'center' });
            glowMessage(targetMsg);
        }

        function updateSearchUI() {
            // Обновляем текст счетчика (в ТГ идет обратный отсчет: 1 из 10 - это самое свежее)
            const displayIndex = chatSearchMatches.length - chatSearchCurrentIndex;
            document.getElementById('chatSearchCount').innerText = `${displayIndex} из ${chatSearchMatches.length}`;

            // Выделяем активный элемент в выпадающем списке
            document.querySelectorAll('.search-msg-item').forEach(el => el.classList.remove('active'));
            const activeItem = document.getElementById('search-item-' + chatSearchCurrentIndex);
            if (activeItem) {
                activeItem.classList.add('active');
                activeItem.scrollIntoView({ behavior: 'smooth', block: 'nearest' });
            }
        }

        function jumpToMessageAndCloseDropdown() {
            const targetMsg = chatSearchMatches[chatSearchCurrentIndex].element;

            // Скрываем меню, но оставляем шапку открытой
            document.getElementById('chatSearchDropdown').classList.add('hidden');

            // Скроллим к сообщению
            targetMsg.scrollIntoView({ behavior: 'smooth', block: 'center' });
            updateSearchUI(); // Обновить счетчик

            glowMessage(targetMsg);
        }

        // Вспомогательная функция для вспышки (подсветки) сообщения при переходе к нему
        function glowMessage(element) {
            element.style.transition = 'background 0.5s ease';
            const originalBg = element.style.background || element.style.backgroundColor;
            // Делаем вспышку синей, как в ТГ, или серой
            element.style.backgroundColor = 'rgba(115, 106, 240, 0.4)';
            setTimeout(() => {
                element.style.backgroundColor = originalBg;
            }, 1000);
        }

        function updateLangLabel() {
            const el = document.getElementById('currentLangLabel');
            if (el) {
                const langNames = { 'ru': 'Русский', 'en': 'English', 'de': 'Deutsch', 'es': 'Español' };
                const name = langNames[targetLang] || targetLang.toUpperCase();
                el.innerText = `${name} (${targetLang})`;
            }
        }





        // --- API ПЕРЕВОДА ---
        // --- API ПЕРЕВОДА ---
        // --- КОНФИГУРАЦИЯ GOOGLE SCRIPTS ---


        // --- ЛОГИКА ПЕРЕВОДА ЧЕРЕЗ GOOGLE SCRIPT ---

        async function fetchTranslation(text, toLang) {
            try {
                // Отправляем данные на твой новый скрипт
                const response = await fetch(TRANSLATE_SCRIPT_URL, {
                    method: "POST",
                    mode: "cors", // Google Script поддерживает cors при правильной публикации
                    body: JSON.stringify({
                        action: "translate",
                        text: text,
                        toLang: toLang
                    })
                });

                const data = await response.json();

                if (data.status === "success" && data.translatedText) {
                    const result = data.translatedText;

                    // Если Google вернул тот же текст (языки совпали), не показываем блок перевода
                    if (result.trim().toLowerCase() === text.trim().toLowerCase()) {
                        return null;
                    }

                    return result;
                } else {
                    console.error("Ошибка скрипта перевода:", data.message);
                    return null;
                }
            } catch (e) {
                console.error("Критическая ошибка запроса перевода:", e);
                return null;
            }
        }

        // Универсальная функция переключения аудио-выхода
        async function setAudioOutput(toEarpiece) {
            console.log("Переключение звука. В ухо:", toEarpiece);

            // 1. Проверка: Мы в MAUI приложении?
            if (window.DotNet) {
                // Если ты настроил Bridge, вызываем C# метод
                // Если нет, Android сам часто переключает в Mode_In_Communication при WebRTC
                console.log("Попытка вызвать системный переключатель MAUI");
            }

            // 2. Логика для браузера (и WebView)
            const remoteVid = document.getElementById('remoteVideo');
            if (remoteVid && remoteVid.setSinkId) {
                // В современных браузерах можно программно выбирать устройство,
                // но на мобилках это чаще управляется системой.
            }

            showToast(toEarpiece ? "Звук: Динамик уха" : "Звук: Громкая связь");
        }

        let isEarpiece = false;

        // 1. Проверка среды при старте звонка
        function updateSpeakerButtonVisibility() {
            // В MAUI Blazor Hybrid обычно доступен объект window.chrome.webview или DotNet
            const isApp = window.chrome && window.chrome.webview;
            const speakerBtn = document.getElementById('speakerControl');
            if (isApp && speakerBtn) {
                speakerBtn.style.display = 'flex'; // Показываем кнопку только в приложении
            }
        }

        // 2. Функция переключения
        function toggleSpeaker() {
            isEarpiece = !isEarpiece;
            const btn = document.getElementById('btnSpeaker');
            const lbl = document.getElementById('lblSpeaker');

            if (isEarpiece) {
                btn.innerHTML = '👂';
                lbl.innerText = 'Громкая';
                btn.classList.add('btn-active-white');
            } else {
                btn.innerHTML = '🔈';
                lbl.innerText = 'В ухо';
                btn.classList.remove('btn-active-white');
            }

            // ВЫЗОВ C# КОДА (MAUI)
            if (window.chrome && window.chrome.webview) {
                // Передаем команду в MainActivity.cs
                window.chrome.webview.postMessage(JSON.stringify({
                    action: "setAudioMode",
                    earpiece: isEarpiece
                }));
            }
        }

        // 3. Вызови проверку кнопок в момент открытия экрана звонка
        // Добавь это внутрь функции startCall() и answerCall()
        // updateSpeakerButtonVisibility();


        // ... (твой код updateCallControlsVisibility и OneSignal) ...

        // --- МГНОВЕННЫЙ ЗАПУСК ---
        // Если мы помним, что юзер был залогинен, пытаемся нарисовать интерфейс сразу
        // --- МГНОВЕННЫЙ ЗАПУСК ---
        if (localStorage.getItem('isLoggedIn') === 'true' && localStorage.getItem('current_user_uid')) {
            console.log("🚀 Мгновенный старт из кэша");

            document.getElementById('authScreen').classList.add('hidden');
            loadProfileFromCache();

            // --- ИСПРАВЛЕНИЕ: Даем скрипту ID пользователя ДО ответа от Firebase ---
            if (!currentUser) {
                currentUser = {
                    uid: localStorage.getItem('current_user_uid')
                };
            }

            // Теперь loadData() не упадет с ошибкой и данные начнут грузиться мгновенно
            loadTurnServers();
            loadData();
        }

        // Авто-увеличение высоты поля ввода
        function autoResize(textarea) {
            // Сбрасываем строго до 1 строки, а не до 'auto', чтобы WebView не тупил
            textarea.style.height = '40px';

            // Если контента больше, чем на 1 строку, увеличиваем высоту (до 100px)
            const newHeight = Math.min(textarea.scrollHeight, 100);
            textarea.style.height = newHeight + 'px';
        }

        // Логика переключения кнопок Микрофон / Самолетик
        function checkInputState() {
            const val = document.getElementById('msgInput').value.trim();
            const voiceBtn = document.getElementById('voiceBtn');
            const sendBtn = document.getElementById('sendBtn');

            if (val.length > 0) {
                voiceBtn.classList.add('hidden');
                sendBtn.classList.remove('hidden');
            } else {
                voiceBtn.classList.remove('hidden');
                sendBtn.classList.add('hidden');
            }
        }

        // Умное форматирование даты (как в Telegram)
        function formatTelegramDate(date) {
            if (!date) return "";
            const now = new Date();
            const msgDate = new Date(date);

            // Сбрасываем время для сравнения только дат
            const today = new Date(now.getFullYear(), now.getMonth(), now.getDate()).getTime();
            const target = new Date(msgDate.getFullYear(), msgDate.getMonth(), msgDate.getDate()).getTime();
            const diffDays = Math.floor((today - target) / (1000 * 60 * 60 * 24));

            // Сегодня -> 14:30
            if (diffDays === 0) {
                return msgDate.getHours().toString().padStart(2, '0') + ':' + msgDate.getMinutes().toString().padStart(2, '0');
            }
            // Вчера -> вчера
            if (diffDays === 1) return "вчера";
            // Позавчера -> позавчера
            if (diffDays === 2) return "позавчера";
            // В пределах недели -> ПН, ВТ...
            if (diffDays < 7) {
                const weekDays = ["ВС", "ПН", "ВТ", "СР", "ЧТ", "ПТ", "СБ"];
                return weekDays[msgDate.getDay()];
            }
            // В этом году -> 11.02
            if (msgDate.getFullYear() === now.getFullYear()) {
                return msgDate.getDate().toString().padStart(2, '0') + '.' + (msgDate.getMonth() + 1).toString().padStart(2, '0');
            }
            // Прошлые года -> 11.12.25
            return msgDate.getDate().toString().padStart(2, '0') + '.' +
                (msgDate.getMonth() + 1).toString().padStart(2, '0') + '.' +
                msgDate.getFullYear().toString().slice(-2);
        }


        let currentMsgList = null;

        function getOrCreateMsgList(chatId) {
            const container = document.getElementById('chatViewsContainer');

            // Скрываем все открытые чаты
            const allLists = container.querySelectorAll('.messages');
            allLists.forEach(el => el.style.display = 'none');

            // Ищем контейнер именно для этого диалога
            let list = document.getElementById('msgList_' + chatId);
            let isNew = false;

            if (!list) {
                // Если зашли в первый раз - создаем слой
                list = document.createElement('div');
                list.id = 'msgList_' + chatId;
                list.className = 'messages';
                list.addEventListener('scroll', handleChatScroll); // Вешаем скролл

                // СЛУШАТЕЛИ ДЛЯ СВАЙПА
                list.addEventListener('touchstart', handleChatTouchStart, { passive: true });
                list.addEventListener('touchmove', handleChatTouchMove, { passive: false });
                list.addEventListener('touchend', handleChatTouchEnd);
                list.addEventListener('touchcancel', handleChatTouchEnd);
                if (!container.dataset.eventsAdded) {
                    container.addEventListener('contextmenu', handleDesktopSideRightClick);
                    container.addEventListener('dblclick', handleDesktopSideDoubleClick);
                    container.dataset.eventsAdded = 'true';
                }
                // --------------------------------------------------------

                container.appendChild(list);
                isNew = true;
            }

            // Показываем текущий
            list.style.display = 'flex';
            currentMsgList = list;

            return { list, isNew };
        }

        // ==========================================
        // ЛОГИКА МЕНЮ ЧАТА (ТРИ ТОЧКИ)
        // ==========================================

        function toggleChatOptionsMenu(e) {
            e.stopPropagation(); // Не даем клику уйти дальше на фон
            const menu = document.getElementById('chatOptionsMenu');

            if (menu.classList.contains('active')) {
                closeChatOptionsMenu();
            } else {
                menu.classList.add('active');
            }
        }

        function closeChatOptionsMenu() {
            const menu = document.getElementById('chatOptionsMenu');
            if (menu) menu.classList.remove('active');
        }

        // Автоматическое закрытие меню при клике мимо него
        document.addEventListener('click', function (e) {
            const menu = document.getElementById('chatOptionsMenu');
            // Если меню открыто, и клик был НЕ по самому меню
            if (menu && menu.classList.contains('active') && !e.target.closest('#chatOptionsMenu')) {
                closeChatOptionsMenu();
            }
        });

        // --- ФУНКЦИЯ "ПИНКА" СЕТИ (Digital CPR) ---
        async function kickstartNetwork() {
            console.log("[NOVOGRAM_LOG] Принудительный перезапуск сетевого слоя...");
            try {
                // 1. Говорим Firestore "отключись от сети"
                await db.disableNetwork();

                // 2. Ждем 1 секунду (как ты и делал вручную)
                await new Promise(resolve => setTimeout(resolve, 1000));

                // 3. Говорим "подключайся обратно"
                await db.enableNetwork();
                console.log("[NOVOGRAM_LOG] Сетевой слой успешно перезапущен!");
            } catch (e) {
                console.error("[NOVOGRAM_LOG] Ошибка при перезапуске сети:", e);
            }
        }

        // Запускаем этот "пинок" сразу при загрузке страницы
        document.addEventListener('DOMContentLoaded', () => {
            // Даем 500мс на первичную инициализацию и бьем в колокола
            setTimeout(kickstartNetwork, 500);
        });




        // ==========================================
        // ЛОГИКА СВАЙПА И ДОЛГОГО НАЖАТИЯ + СВАЙП НАЗАД
        // ==========================================
        let swipeTarget = null;
        let swipeStartX = 0;
        let swipeStartY = 0;
        let swipeCurrentX = 0;
        let isSwipeHorizontal = false;
        let isSwipeVertical = false;
        let swipeHapticTriggered = false;
        let longPressTimer = null;
        let isLongPressTriggered = false;

        // Переменные для нового свайпа "Назад"
        let isBackSwiping = false;
        let backSwipeCurrentX = 0;

        function handleChatTouchStart(e) {
            if (window.innerWidth > 768) return;

            const touch = e.touches[0];
            swipeStartX = touch.clientX;
            swipeStartY = touch.clientY;

            swipeTarget = e.target.closest('.msg');
            swipeCurrentX = 0;
            isSwipeHorizontal = false;
            isSwipeVertical = false;
            swipeHapticTriggered = false;
            isLongPressTriggered = false;

            isBackSwiping = false;
            backSwipeCurrentX = 0;

            if (swipeTarget) {
                if (longPressTimer) clearTimeout(longPressTimer);
                longPressTimer = setTimeout(() => {
                    // Если палец не двигался и мы не делаем свайп назад
                    if (!isSwipeHorizontal && !isSwipeVertical && swipeTarget && !isBackSwiping) {
                        isLongPressTriggered = true;
                        if (navigator.vibrate) navigator.vibrate(40);

                        const msgId = swipeTarget.id.replace('msg-', '');
                        const isMine = swipeTarget.classList.contains('msg-me');

                        openContextMenu(null, msgId, isMine, true);
                        swipeTarget = null;
                    }
                }, 400);

                let icon = swipeTarget.querySelector('.swipe-reply-icon');
                if (!icon) {
                    icon = document.createElement('div');
                    icon.className = 'swipe-reply-icon';
                    icon.innerHTML = '↩️';
                    swipeTarget.appendChild(icon);
                }
            }
        }

        function handleChatTouchMove(e) {
            if (window.innerWidth > 768) return;
            const touch = e.touches[0];
            const deltaX = touch.clientX - swipeStartX;
            const deltaY = touch.clientY - swipeStartY;

            // Если палец дрогнул - отменяем долгое нажатие
            if (Math.abs(deltaX) > 8 || Math.abs(deltaY) > 8) {
                if (longPressTimer) clearTimeout(longPressTimer);
            }

            if (!isSwipeHorizontal && !isSwipeVertical) {
                if (Math.abs(deltaY) > Math.abs(deltaX)) {
                    isSwipeVertical = true;
                } else if (Math.abs(deltaX) > 5) {
                    isSwipeHorizontal = true;

                    // Условие: Айфон ли это?
                    const isIOS = /iPad|iPhone|iPod/.test(navigator.userAgent) && !window.MSStream;

                    if (deltaX > 0 && !isIOS) {
                        // 1. Свайп ВПРАВО (Выход из чата) - ТОЛЬКО НЕ НА IOS
                        isBackSwiping = true;
                        swipeTarget = null; // Отменяем логику сообщения
                    } else if (deltaX < 0 && swipeTarget) {
                        // 2. Свайп ВЛЕВО по сообщению (Ответ)
                        isBackSwiping = false;
                    } else {
                        // Неопределенный свайп
                        isSwipeHorizontal = false;
                        isSwipeVertical = true;
                    }
                } else {
                    return;
                }
            }

            if (isSwipeVertical) return;

            if (isSwipeHorizontal) {
                if (e.cancelable) e.preventDefault(); // Блокируем системную физику

                if (isBackSwiping) {
                    // --- КРАСИВАЯ АНИМАЦИЯ ЗАКРЫТИЯ ЧАТА ---
                    backSwipeCurrentX = Math.max(0, deltaX);

                    const chatArea = document.getElementById('mainChatArea');
                    const sidebar = document.getElementById('mainSidebar');
                    const screenWidth = window.innerWidth;

                    // Двигаем окно чата за пальцем
                    chatArea.style.transition = 'none';
                    chatArea.style.transform = `translateX(${backSwipeCurrentX}px)`;

                    // Двигаем список диалогов под чатом (от -30% до 0%)
                    let progress = backSwipeCurrentX / screenWidth;
                    if (progress > 1) progress = 1;

                    const sidebarOffset = -30 + (progress * 30);
                    sidebar.style.transition = 'none';
                    sidebar.style.transform = `translateX(${sidebarOffset}%)`;

                } else if (swipeTarget) {
                    // --- АНИМАЦИЯ ОТВЕТА НА СООБЩЕНИЕ ---
                    swipeCurrentX = Math.max(deltaX, -65);
                    swipeTarget.classList.add('swiping');
                    swipeTarget.style.transform = `translateX(${swipeCurrentX}px)`;

                    const icon = swipeTarget.querySelector('.swipe-reply-icon');
                    if (icon) {
                        if (swipeCurrentX <= -50) {
                            icon.classList.add('active');
                            if (!swipeHapticTriggered) {
                                if (navigator.vibrate) navigator.vibrate(30);
                                swipeHapticTriggered = true;
                            }
                        } else {
                            icon.classList.remove('active');
                            swipeHapticTriggered = false;
                        }
                    }
                }
            }
        }

        function handleChatTouchEnd(e) {
            if (longPressTimer) clearTimeout(longPressTimer);

            if (isLongPressTriggered) {
                isLongPressTriggered = false;
                if (e.cancelable) e.preventDefault();
                return;
            }

            if (isBackSwiping) {
                // --- ЗАВЕРШЕНИЕ СВАЙПА "НАЗАД" ---
                const chatArea = document.getElementById('mainChatArea');
                const sidebar = document.getElementById('mainSidebar');
                const screenWidth = window.innerWidth;

                // Возвращаем управление CSS-классам для плавной доводки
                chatArea.style.transition = '';
                sidebar.style.transition = '';

                // Если протащили экран больше чем на 25% -> закрываем окончательно
                if (backSwipeCurrentX > screenWidth * 0.25) {
                    chatArea.style.transform = '';
                    sidebar.style.transform = '';
                    closeChat();
                } else {
                    // Иначе "отскакиваем" обратно в открытый чат
                    chatArea.style.transform = '';
                    sidebar.style.transform = '';
                }

                isBackSwiping = false;
                isSwipeHorizontal = false;
                return;
            }

            if (swipeTarget) {
                // --- ЗАВЕРШЕНИЕ СВАЙПА "ОТВЕТ" ---
                const icon = swipeTarget.querySelector('.swipe-reply-icon');

                if (swipeCurrentX <= -50) {
                    triggerSwipeReply(swipeTarget);
                }

                swipeTarget.classList.remove('swiping');
                swipeTarget.style.transform = '';
                if (icon) icon.classList.remove('active');

                swipeTarget = null;
            }

            isSwipeHorizontal = false;
            isSwipeVertical = false;
        }

        function triggerSwipeReply(msgEl) {
            const msgId = msgEl.id.replace('msg-', '');
            const isMine = msgEl.classList.contains('msg-me');
            let text = "Вложение";
            const textSpan = msgEl.querySelector('.msg-text');
            if (textSpan) text = textSpan.innerText;
            else if (msgEl.querySelector('.chat-media-img')) text = "Фотография";
            else if (msgEl.querySelector('.chat-file-card')) text = "Файл";

            const chatTitleEl = document.getElementById('chatTitle');
            let friendName = chatTitleEl ? (chatTitleEl.firstElementChild ? chatTitleEl.firstElementChild.innerText : chatTitleEl.innerText) : "Собеседник";

            const name = isMine ? "Вы" : friendName;
            startReplyUI(msgId, name, text);
        }

        // ==========================================
        // ЛОГИКА КЛИКОВ РЯДОМ С СООБЩЕНИЕМ (ПК)
        // ==========================================

        // Умная функция: вычисляет сообщение, находящееся на той же высоте, что и мышка
        function getMsgByYCoordinate(y) {
            if (!currentMsgList) return null;
            // Ищем все пузыри сообщений, игнорируя плашки дат и системные уведомления
            const msgs = currentMsgList.querySelectorAll('.msg:not(.msg-sys)');
            for (let i = 0; i < msgs.length; i++) {
                const rect = msgs[i].getBoundingClientRect();
                // Проверяем, находится ли мышка по высоте на уровне этого сообщения (с зазором 6px)
                if (y >= rect.top - 6 && y <= rect.bottom + 6) {
                    return msgs[i];
                }
            }
            return null;
        }

        // Правый клик (Вызов меню)
        function handleDesktopSideRightClick(e) {
            if (window.innerWidth <= 768) return;
            if (e.target.closest('.msg')) return;

            const msgEl = getMsgByYCoordinate(e.clientY);
            if (msgEl) {
                e.preventDefault();
                const msgId = msgEl.id.replace('msg-', '');
                const isMine = msgEl.classList.contains('msg-me');

                // --- НОВОЕ: Закрытие при повторном клике ---
                const menu = document.getElementById('contextMenu');
                if (menu && menu.classList.contains('active')) {
                    if (selectedMsgId === msgId) {
                        closeAllSheets(); // Если кликнули по тому же сообщению - закрываем
                        return;
                    }
                }

                openContextMenu(e, msgId, isMine);
            }
        }


        // ДВОЙНОЙ левый клик (Быстрый ответ: работает и по фону, и по самому сообщению)
        function handleDesktopSideDoubleClick(e) {
            if (window.innerWidth <= 768) return;

            // Ищем сообщение: либо мы кликнули прямо по нему, либо по фону рядом
            const msgEl = e.target.closest('.msg') || getMsgByYCoordinate(e.clientY);

            if (msgEl) {
                e.preventDefault();

                // Очищаем синее выделение текста, которое браузер делает автоматически при двойном клике
                if (window.getSelection) {
                    window.getSelection().removeAllRanges();
                }

                triggerSwipeReply(msgEl);
            }
        }



        let scrollDateTimeout = null;
        let scrollThrottleTimer = null; // Убедитесь, что эта переменная есть

        function handleChatScroll(e) {
            const list = e.target;

            // --- НОВОЕ: Логика кнопки "Вниз" ---
            const scrollBtn = document.getElementById('scrollToBottomBtn');
            if (scrollBtn) {
                // Если мы поднялись выше чем на 200px от конца - показываем кнопку
                if (list.scrollHeight - list.scrollTop - list.clientHeight > 200) {
                    scrollBtn.classList.add('visible');
                } else {
                    scrollBtn.classList.remove('visible');
                }
            }
            // -----------------------------------

            const floatingDate = document.getElementById('floatingDate');
            if (!floatingDate) return;

            clearTimeout(scrollDateTimeout);
            scrollDateTimeout = setTimeout(() => {
                floatingDate.classList.remove('visible');
            }, 1000);

            if (scrollThrottleTimer) return;

            scrollThrottleTimer = setTimeout(() => {
                const listRect = list.getBoundingClientRect();
                const topEl = document.elementFromPoint(listRect.left + listRect.width / 2, listRect.top + 30);

                if (topEl) {
                    const target = topEl.closest('.msg, .chat-date-separator');
                    if (target) {
                        const dateStr = target.getAttribute('data-datestr') || target.innerText;
                        if (dateStr && floatingDate.innerText !== dateStr) {
                            floatingDate.innerText = dateStr;
                        }
                        floatingDate.classList.add('visible');
                    }
                }
                scrollThrottleTimer = null;
            }, 100);
        }


        function scrollToBottom() {
            if (currentMsgList) {
                // Мягко скроллим с запасом в самый низ
                currentMsgList.scrollTo({
                    top: currentMsgList.scrollHeight + 1000,
                    behavior: 'smooth'
                });
            }
        }

        // --- УМНАЯ ФУНКЦИЯ ДЛЯ ВВОДА (С РАЗДЕЛЕНИЕМ ПК / ТЕЛЕФОН) ---
        function handleChatInput(e) {
            if (e.key === 'Enter') {
                // Определяем, сидит ли пользователь с мобильного устройства
                const isMobile = /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent);

                if (isMobile) {
                    // НА ТЕЛЕФОНЕ: Просто позволяем системе сделать перенос строки.
                    // Ничего не блокируем и не отправляем сообщение.
                    return;
                } else {
                    // НА ПК:
                    if (e.shiftKey || e.ctrlKey) {
                        // Если нажат Shift+Enter или Ctrl+Enter -> перенос строки
                        return;
                    } else {
                        // Обычный Enter без модификаторов -> отправка сообщения
                        e.preventDefault(); // Блокируем стандартный перенос строки
                        sendMsg();

                        // Сброс высоты поля после отправки
                        const inp = document.getElementById('msgInput');
                        inp.style.height = '40px';
                        checkInputState();
                    }
                }
            }
        }
        // Запрещаем системное событие копирования (кроме полей ввода)
        document.addEventListener('copy', function (e) {
            if (e.target.tagName !== 'INPUT' && e.target.tagName !== 'TEXTAREA') {
                e.preventDefault();
                // Опционально: можно показать уведомление
                // showToast("Копирование запрещено");
            }
        });

        // Запрещаем горячие клавиши Ctrl+C / Cmd+C (кроме полей ввода)
        document.addEventListener('keydown', function (e) {
            if ((e.ctrlKey || e.metaKey) && (e.key === 'c' || e.key === 'C')) {
                if (e.target.tagName !== 'INPUT' && e.target.tagName !== 'TEXTAREA') {
                    e.preventDefault();
                }
            }
        });

        // Автоматически определяем, что мы внутри мобильного приложения (WebView)
        document.addEventListener("DOMContentLoaded", () => {
            // window.chrome.webview - это для MAUI Blazor, 'wv' - стандартная метка Android WebView
            const isApp = (window.chrome && window.chrome.webview) || navigator.userAgent.includes('wv');

            if (isApp) {
                document.body.classList.add('is-app');
                console.log("📱 Включен режим мобильного приложения (WebView оптимизации)");
            }
        });

        // --- СЛУШАТЕЛЬ СИСТЕМНОЙ КНОПКИ "НАЗАД" (И СВАЙПА НА ТЕЛЕФОНЕ) ---
        // --- СЛУШАТЕЛЬ СИСТЕМНОЙ КНОПКИ "НАЗАД" (И СВАЙПА НА ТЕЛЕФОНЕ) ---
        window.addEventListener('popstate', (e) => {
            if (typeof sheetHistoryStack !== 'undefined' && sheetHistoryStack > 0) {
                sheetHistoryStack--;

                // Проверяем, какая шторка открыта сейчас сверху, и закрываем именно её
                if (document.getElementById('friendProfileSheet')?.classList.contains('open')) {
                    closeFriendProfile(true); // <-- Теперь правильно закрывает и убирает затемнение
                } else if (document.getElementById('editProfileSheet')?.classList.contains('open')) {
                    closeEditProfile(true);
                } else if (document.getElementById('generalSettingsSheet')?.classList.contains('open')) {
                    closeGeneralSettings(true);
                } else if (document.getElementById('profileSheet')?.classList.contains('open')) {
                    closeAllSheets(true);
                }
            }
        });

        // ==========================================
        // ЛОГИКА ПЕРЕХОДА ПО ССЫЛКАМ (Telegram Style)
        // ==========================================
        let currentLinkToOpen = "";

        document.addEventListener('click', function (e) {
            const link = e.target.closest('a.chat-link');

            if (link) {
                e.preventDefault();
                e.stopPropagation();

                currentLinkToOpen = link.getAttribute('href');
                document.getElementById('linkModalUrlText').innerText = currentLinkToOpen;
                document.getElementById('linkModalOverlay').style.display = 'flex';
            }
        });

        function closeLinkModal() {
            document.getElementById('linkModalOverlay').style.display = 'none';
            currentLinkToOpen = "";
        }

        function confirmAndOpenLink() {
            if (!currentLinkToOpen) return;

            // Проверяем, работаем ли мы внутри Android-приложения
            const isAndroidApp = /Android/i.test(navigator.userAgent) &&
                (window.chrome && window.chrome.webview || navigator.userAgent.includes('wv'));

            if (isAndroidApp && currentLinkToOpen.startsWith('http')) {
                // МАГИЯ ANDROID INTENT: Заставляем систему открыть браузер Chrome/Яндекс
                try {
                    const urlObj = new URL(currentLinkToOpen);
                    const scheme = urlObj.protocol.replace(':', ''); // 'https' или 'http'
                    const hostAndPath = currentLinkToOpen.replace(urlObj.protocol + '//', '');

                    const intentUrl = `intent://${hostAndPath}#Intent;scheme=${scheme};action=android.intent.action.VIEW;end;`;
                    window.location.href = intentUrl;
                } catch (e) {
                    window.open(currentLinkToOpen, '_blank');
                }
            } else {
                // Для компьютеров и iPhone
                window.open(currentLinkToOpen, '_blank');
            }

            closeLinkModal();
        }

        // ==========================================
        // УМНЫЙ СКРОЛЛ ПРИ ОТКРЫТИИ КЛАВИАТУРЫ (PREMIUM UX)
        // ==========================================
        document.addEventListener('DOMContentLoaded', () => {
            // Находим контейнер со скроллом внутри шторки редактирования (это второй div внутри #editProfileSheet)
            const scrollContainer = document.querySelector('#editProfileSheet > div:nth-child(2)');
            const allEditInputs = document.querySelectorAll('#editProfileSheet input, #editProfileSheet textarea');

            allEditInputs.forEach(input => {
                input.addEventListener('focus', function () {
                    // Применяем магию только для телефонов
                    if (window.innerWidth <= 768) {
                        // 1. Даем огромный временный запас снизу. Это нужно, чтобы даже самое
                        // нижнее поле (Юзернейм) физически могло дотянуться до центра экрана.
                        scrollContainer.style.paddingBottom = '60vh';

                        // 2. Ждем ровно 300мс (пока система выдвинет клавиатуру)
                        setTimeout(() => {
                            // 3. Плавно центрируем поле над клавиатурой
                            this.scrollIntoView({ behavior: 'smooth', block: 'center' });
                        }, 300);
                    }
                });

                input.addEventListener('blur', function () {
                    if (window.innerWidth <= 768) {
                        // Как только убрали фокус (клавиатура прячется), возвращаем родной отступ
                        setTimeout(() => {
                            scrollContainer.style.paddingBottom = '40px';
                        }, 100);
                    }
                });
            });
        });

        // ==========================================
        // ЛОКАЛЬНЫЕ ИМЕНА КОНТАКТОВ И УДАЛЕНИЕ
        // ==========================================

        // Читаем локальное имя из памяти устройства
        function getCustomContactData(uid) {
            if (!currentUser) return null;
            const data = JSON.parse(localStorage.getItem('custom_contacts_' + currentUser.uid) || '{}');
            return data[uid] || null;
        }

        // Вычисляет итоговое имя для отображения везде
        function getDisplayName(uid, originalData) {
            if (!originalData) return "Загрузка...";
            const custom = getCustomContactData(uid);

            if (custom && (custom.name || custom.surname)) {
                return `${custom.name || ''} ${custom.surname || ''}`.trim();
            }

            return `${originalData.name || ''} ${originalData.surname || ''}`.trim() || originalData.username || 'Пользователь';
        }

        function openEditContactSheet() {
            if (!currentFriendId) return;

            if (typeof sheetHistoryStack !== 'undefined') sheetHistoryStack++;
            history.pushState({ isSheet: true }, "", window.location.href);

            const sheet = document.getElementById('editContactSheet');
            sheet.style.display = 'flex';
            document.getElementById('overlaySheet').style.display = 'block';
            setTimeout(() => sheet.classList.add('open'), 10);

            const uData = usersCache[currentFriendId] || {};
            const originalName = `${uData.name || ''} ${uData.surname || ''}`.trim() || uData.username || 'Пользователь';

            // Заполняем шапку
            document.getElementById('contactOriginalName').innerText = originalName;

            // Аватар
            const img = document.getElementById('contactEditAvatar');
            const ph = document.getElementById('contactEditPlaceholder');
            if (uData.avatar) {
                img.src = uData.avatar;
                img.style.display = 'block';
                ph.style.display = 'none';
            } else {
                img.style.display = 'none';
                ph.style.display = 'flex';
                ph.innerText = originalName.charAt(0).toUpperCase();
            }

            // Заполняем поля, если они уже были изменены ранее
            const customData = getCustomContactData(currentFriendId) || {};
            document.getElementById('contactLocalName').value = customData.name !== undefined ? customData.name : (uData.name || '');
            document.getElementById('contactLocalSurname').value = customData.surname !== undefined ? customData.surname : (uData.surname || '');
            document.getElementById('contactLocalNote').value = customData.note || '';

            updateContactNoteCounter(document.getElementById('contactLocalNote'));
        }

        function closeEditContactSheet(fromPopState = false) {
            if (fromPopState !== true && typeof sheetHistoryStack !== 'undefined' && sheetHistoryStack > 0) {
                history.back();
                return;
            }

            if (document.activeElement) document.activeElement.blur();
            document.getElementById('editContactSheet').classList.remove('open');

            setTimeout(() => {
                if (!document.querySelector('.action-sheet.open')) {
                    document.getElementById('overlaySheet').style.display = 'none';
                }
            }, 300);
        }

        function updateContactNoteCounter(el) {
            const remaining = 128 - el.value.length;
            document.getElementById('contactNoteCounter').innerText = remaining;
        }

        function saveLocalContact() {
            if (!currentFriendId || !currentUser) return;

            const newName = document.getElementById('contactLocalName').value.trim();
            const newSurname = document.getElementById('contactLocalSurname').value.trim();
            const newNote = document.getElementById('contactLocalNote').value.trim();

            const allContacts = JSON.parse(localStorage.getItem('custom_contacts_' + currentUser.uid) || '{}');

            allContacts[currentFriendId] = {
                name: newName,
                surname: newSurname,
                note: newNote
            };

            localStorage.setItem('custom_contacts_' + currentUser.uid, JSON.stringify(allContacts));

            showToast("Контакт обновлен");
            closeEditContactSheet();

            // Мгновенно обновляем интерфейс
            const finalName = getDisplayName(currentFriendId, usersCache[currentFriendId]);

            // Обновляем шапку чата
            const titleEl = document.getElementById('chatTitle');
            if (titleEl) titleEl.innerText = finalName;

            // Обновляем имя в списке друзей (если он отрендерен)
            const listCard = document.querySelector(`#u-${currentFriendId} .user-name`);
            if (listCard) listCard.innerText = finalName;
        }

        // Логика удаления из друзей
        async function removeFriendAction() {
            if (!confirm("Вы уверены, что хотите удалить пользователя из списка друзей? Чат будет сохранен, но вы не увидите его в основном списке.")) return;

            try {
                // Ищем запись в коллекции friends, где есть мы и друг
                const snap = await db.collection('friends')
                    .where('users', 'array-contains', currentUser.uid)
                    .get();

                let friendDocId = null;
                snap.forEach(doc => {
                    const data = doc.data();
                    if (data.users.includes(currentFriendId)) {
                        friendDocId = doc.id;
                    }
                });

                if (friendDocId) {
                    await db.collection('friends').doc(friendDocId).delete();
                    showToast("Пользователь удален из друзей");
                    closeEditContactSheet();
                    closeChat(); // Закрываем чат и возвращаем на главный экран
                } else {
                    alert("Ошибка: Пользователь не найден в списке друзей.");
                }
            } catch (e) {
                console.error(e);
                alert("Ошибка при удалении.");
            }
        }

    </script>

    <div id="birthModal" class="modal-overlay" style="display:none" onclick="closeBirthModal()">
        <div class="birth-modal" onclick="event.stopPropagation()">
            <h3 style="margin:0; font-size:18px; color:white; font-weight:600;">День рождения</h3>

            <div class="birth-pickers">
                <select id="bdDay"></select>
                <select id="bdMonth"></select>
                <select id="bdYear"></select>
            </div>

            <div class="modal-buttons">
                <button class="btn-cancel" onclick="closeBirthModal()">Отмена</button>
                <button class="btn-confirm" style="color:#8774e1" onclick="applyBirthdate()">Готово</button>
            </div>
        </div>
    </div>


    <div id="imageViewer" class="image-viewer" onclick="closeImageViewer()">
        <span class="close-viewer-btn">&times;</span>
        <img id="imageViewerImg" src="" onclick="event.stopPropagation()">
    </div>

    <div id="linkModalOverlay" class="modal-overlay" style="display: none;" onclick="closeLinkModal()">
        <div class="link-modal" onclick="event.stopPropagation()">
            <div class="link-modal-icon">🌍</div>
            <h3>Переход по ссылке</h3>
            <p>Вы собираетесь покинуть Novogram и перейти на внешний сайт. Будьте осторожны.</p>
            <div class="link-url-box" id="linkModalUrlText"></div>
            <div class="link-modal-buttons">
                <button class="btn-link-open" onclick="confirmAndOpenLink()">Перейти</button>
                <button class="btn-link-cancel" onclick="closeLinkModal()">Отмена</button>
            </div>
        </div>
    </div>

    <div id="logoutModalOverlay" class="modal-overlay" style="display: none;" onclick="closeLogoutModal()">
        <div class="link-modal" onclick="event.stopPropagation()">
            <div class="link-modal-icon">🚪</div>
            <h3>Выход из аккаунта</h3>
            <p>Вы уверены, что хотите выйти? Для входа потребуется ввести пароль.</p>
            <div class="link-modal-buttons">
                <button class="btn-link-open" style="background: #ff4444; box-shadow: 0 4px 15px rgba(255, 68, 68, 0.4);" onclick="confirmLogout()">Выйти</button>
                <button class="btn-link-cancel" onclick="closeLogoutModal()">Отмена</button>
            </div>
        </div>
    </div>

    <div id="friendProfileSheet" class="action-sheet full-screen-sheet" style="padding: 0; border-radius: 0;">
        <div class="premium-header">
            <button onclick="closeFriendProfile()" class="header-icon-btn">
                <svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="#aaa" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><line x1="19" y1="12" x2="5" y2="12"></line><polyline points="12 19 5 12 12 5"></polyline></svg>
            </button>
            <div style="flex:1; text-align:center; font-weight: 600; font-size: 18px; color: white;">Информация</div>
            <div style="width: 40px;"></div>
        </div>

        <div style="flex:1; overflow-y: auto; padding-bottom: 40px;">
            <div class="premium-profile-info" style="padding-bottom: 15px;">
                <div class="premium-avatar-wrap" id="friendProfileAvatarWrap" onclick="openImageViewer(this.querySelector('img').src)">
                    <img id="friendProfileAvatarPreview" src="" style="display:none">
                    <div id="friendProfileAvatarPlaceholder" class="placeholder">👤</div>
                </div>
                <div id="friendProfileName" class="premium-name-input" style="margin-bottom: 5px;">Загрузка...</div>
                <div id="friendProfileStatus" class="premium-status" style="color: #8e8e93; font-weight: normal;">загрузка...</div>
            </div>

            <div class="friend-actions-row">
                <div class="friend-action-btn" onclick="startCall()">
                    <div class="icon">📞</div>
                    <span>Звонок</span>
                </div>
                <div class="friend-action-btn" onclick="alert('Уведомления отключены')">
                    <div class="icon">🔕</div>
                    <span>Без звука</span>
                </div>
                <div class="friend-action-btn" onclick="closeFriendProfile(); toggleChatSearch();">
                    <div class="icon">🔍</div>
                    <span>Поиск</span>
                </div>
            </div>

            <div class="premium-section-title">Аккаунт</div>
            <div class="premium-section">
                <div class="premium-item click-to-copy" onclick="copyData('friendProfileUsername', 'Username')">
                    <div class="premium-item-icon">@</div>
                    <div class="premium-item-content">
                        <div class="premium-item-label">Имя пользователя</div>
                        <div class="premium-item-value" id="friendProfileUsername">@username</div>
                    </div>
                </div>
                <div class="premium-item">
                    <div class="premium-item-icon" style="background: rgba(16, 185, 129, 0.15); color: #10b981;">ℹ️</div>
                    <div class="premium-item-content">
                        <div class="premium-item-label">О себе</div>
                        <div class="premium-item-value" id="friendProfileBio" style="white-space: pre-wrap; font-size: 15px;">Информация не указана</div>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <div id="editContactSheet" class="action-sheet full-screen-sheet" style="padding: 0; border-radius: 0; background: #1c1c1e !important;">
        <div class="premium-header" style="background: transparent; border-bottom: none;">
            <button onclick="closeEditContactSheet()" class="header-icon-btn">
                <svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="#aaa" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><line x1="19" y1="12" x2="5" y2="12"></line><polyline points="12 19 5 12 12 5"></polyline></svg>
            </button>
            <div style="flex:1; text-align:center; font-weight: 600; font-size: 18px; color: white;">Изменить</div>
            <button onclick="saveLocalContact()" class="header-icon-btn" style="color: #736AF0;">
                <svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><polyline points="20 6 9 17 4 12" /></svg>
            </button>
        </div>

        <div style="flex:1; overflow-y: auto; padding-bottom: 40px;">
            <div class="premium-profile-info" style="padding-bottom: 5px;">
                <div class="premium-avatar-wrap" style="pointer-events: none; width: 100px; height: 100px; background: none; box-shadow: none; border-radius: 50%; padding: 0;">
                    <img id="contactEditAvatar" src="" style="display:none; border: none;">
                    <div id="contactEditPlaceholder" class="placeholder" style="border: none;">👤</div>
                </div>
                <div id="contactOriginalName" style="color: white; font-size: 20px; font-weight: bold; margin-top: 10px; letter-spacing: -0.3px;">Загрузка...</div>
            </div>

            <div style="padding: 20px;">
                <div class="tg-input-field" style="background: transparent;">
                    <input type="text" id="contactLocalName" placeholder=" ">
                    <label style="background: #1c1c1e;">Имя</label>
                </div>
                <div class="tg-input-field" style="background: transparent;">
                    <input type="text" id="contactLocalSurname" placeholder=" ">
                    <label style="background: #1c1c1e;">Фамилия</label>
                </div>
                <div class="tg-input-field" style="background: transparent; margin-bottom: 5px;">
                    <textarea id="contactLocalNote" placeholder=" " rows="2" maxlength="128" oninput="updateContactNoteCounter(this)"></textarea>
                    <label style="background: #1c1c1e;">Заметка</label>
                    <div class="char-counter" id="contactNoteCounter" style="bottom: -20px;">128</div>
                </div>
                <div style="font-size: 13px; color: #8e8e93; margin-bottom: 30px; padding-left: 5px;">Заметку видите только Вы.</div>

                <div class="premium-section" style="margin: 0; background: transparent; box-shadow: none; border: none;">
                    <div class="premium-item" onclick="removeFriendAction()" style="background: #252525; border-radius: 12px; border: none;">
                        <div class="premium-item-icon" style="background: transparent; color: #ff595a; margin-right: 12px; width: auto; font-size: 24px;">
                            <svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M16 21v-2a4 4 0 0 0-4-4H5a4 4 0 0 0-4 4v2"></path><circle cx="8.5" cy="7" r="4"></circle><line x1="18" y1="8" x2="23" y2="13"></line><line x1="23" y1="8" x2="18" y2="13"></line></svg>
                        </div>
                        <div class="premium-item-content">
                            <div class="premium-item-value" style="color: #ff595a;">Удалить из друзей</div>
                        </div>
                    </div>
                </div>
            </div>
        </div>
    </div>

</body>
</html>
